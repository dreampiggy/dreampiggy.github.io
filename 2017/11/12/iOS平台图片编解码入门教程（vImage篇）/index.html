<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
  <link rel="mask-icon" href="/favicon/favicon-96x96.png" color="#222">
  <link rel="manifest" href="/favicon/manifest.json">
  <meta name="msapplication-config" content="/favicon/browserconfig.xml">
  <meta name="google-site-verification" content="FxluveaUq3p4_U7oafDkQ66kfrF7UzlQBqz76MqdZ20">
  <meta name="baidu-site-verification" content="YrIvWUx4XP">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dreampiggy.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="这篇教程，是系列教程的第三篇，前篇名为iOS平台图片编解码入门教程（第三方编解码篇）。由于vImage已经属于较为底层框架，这一篇将不会特别着重图片封装格式的编解码，会介绍一些Bitmap级别的操作，包括了图像的色彩转换，Alpha合成、基本几何变换等实际用法。由于教程侧重是图像格式，所以不会介绍vImage强大的Convolution等知识，这方面涉及到数字图像处理的复杂知识，不是教程的目标">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS平台图片编解码入门教程（vImage篇）">
<meta property="og:url" content="http://dreampiggy.com/2017/11/12/iOS%E5%B9%B3%E5%8F%B0%E5%9B%BE%E7%89%87%E7%BC%96%E8%A7%A3%E7%A0%81%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%88vImage%E7%AF%87%EF%BC%89/index.html">
<meta property="og:site_name" content="小猪的博客">
<meta property="og:description" content="这篇教程，是系列教程的第三篇，前篇名为iOS平台图片编解码入门教程（第三方编解码篇）。由于vImage已经属于较为底层框架，这一篇将不会特别着重图片封装格式的编解码，会介绍一些Bitmap级别的操作，包括了图像的色彩转换，Alpha合成、基本几何变换等实际用法。由于教程侧重是图像格式，所以不会介绍vImage强大的Convolution等知识，这方面涉及到数字图像处理的复杂知识，不是教程的目标">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/dreampiggy/vImageProcessor/master/Example/Screenshot/Screenshot1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/dreampiggy/vImageProcessor/master/Example/Screenshot/Screenshot2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/dreampiggy/vImageProcessor/master/Example/Screenshot/Screenshot3.png">
<meta property="article:published_time" content="2017-11-12T10:32:45.000Z">
<meta property="article:modified_time" content="2024-01-01T05:26:27.849Z">
<meta property="article:author" content="DreamPiggy">
<meta property="article:tag" content="iOS">
<meta property="article:tag" content="Image">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/dreampiggy/vImageProcessor/master/Example/Screenshot/Screenshot1.png">

<link rel="canonical" href="http://dreampiggy.com/2017/11/12/iOS%E5%B9%B3%E5%8F%B0%E5%9B%BE%E7%89%87%E7%BC%96%E8%A7%A3%E7%A0%81%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%88vImage%E7%AF%87%EF%BC%89/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>iOS平台图片编解码入门教程（vImage篇） | 小猪的博客</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-87402232-1"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-87402232-1');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="小猪的博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">小猪的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">iOS开发 Web开发 Geek</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-develop">

    <a href="/develop/" rel="section"><i class="fa fa-code fa-fw"></i>开发</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/dreampiggy" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dreampiggy.com/2017/11/12/iOS%E5%B9%B3%E5%8F%B0%E5%9B%BE%E7%89%87%E7%BC%96%E8%A7%A3%E7%A0%81%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%88vImage%E7%AF%87%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="DreamPiggy">
      <meta itemprop="description" content="DreamPiggy的个人博客，分享一些关于iOS开发，Web开发以及其它好玩东西的地方">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小猪的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          iOS平台图片编解码入门教程（vImage篇）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-11-12 10:32:45" itemprop="dateCreated datePublished" datetime="2017-11-12T10:32:45+00:00">2017-11-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-01 05:26:27" itemprop="dateModified" datetime="2024-01-01T05:26:27+00:00">2024-01-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>这篇教程，是系列教程的第三篇，前篇名为iOS平台图片编解码入门教程（第三方编解码篇）。由于vImage已经属于较为底层框架，这一篇将不会特别着重图片封装格式的编解码，会介绍一些Bitmap级别的操作，包括了图像的色彩转换，Alpha合成、基本几何变换等实际用法。由于教程侧重是图像格式，所以不会介绍vImage强大的Convolution等知识，这方面涉及到数字图像处理的复杂知识，不是教程的目标</p>
</blockquote>
<h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><p><a target="_blank" rel="noopener" href="https://developer.apple.com/library/content/documentation/Performance/Conceptual/vImage/Introduction/Introduction.html">vImage</a>是Apple的Accelerate库的一部分，侧重于高性能的图像Bitmap级别的处理。库本身全部是C的接口，而且不同于Core系列的（Core Graphics/Core Foundation）C接口，是比较贴近传统C语言的接口，不会有XXXRef这种贴心的定义，而且很多接口需要自己手动分配内存。</p>
<p>vImage按照功能，可以分为Alpha Compositing（Alpha合成）、Geometry（几何变换）、Conversion（色彩转换）、Convolution（卷积，用于图像滤镜）Morphology（形态学处理）等。这里主要介绍的，就是色彩转换，Alpha合成，以及几何变换的内容。</p>
<p>首先需要对vImage的基本接口有所了解，有这么几个概念：</p>
<ul>
<li><code>vImage_Buffer</code>: 对应Bitmap的数据，只有最基本的width、height、rowBytes(stride)以及data</li>
<li><code>vImage_CGImageFormat</code>: 每个vImage的功能，会提供不同色彩格式的类似接口，比如会有ARGB8888，Planar8的同样功能。这里ARGB8888指的是ARGB排列，每通道占8个Bit，也就是一个Piexel占32Bit。而vImage还有一个常见的色彩格式Plane8，指的是只有一个通道（平面），按照顺序排列，比如<code>&#123;R, R, R, R&#125;</code>这样，更方便进行计算</li>
<li><code>vImage_Flags</code>: 每个vImage接口，都会有一个<code>flags </code>参数来控制一些选项，比如说可以自己定义内存分配，背景色填充策略，重采样策略等，默认的是<code>kvImageNoFlags</code></li>
<li><code>vImage_Error</code>: 每个vImage的接口，都会返回这个result，来让用户确认是否成功，以及失败的原因，在Debug下比较有帮助</li>
</ul>
<p>为了统一期间，以下的内容，都是基于ARGB8888色彩格式的输入来说明的。其他的情况处理，参考同名接口的不同格式即可。</p>
<h1 id="色彩转换"><a href="#色彩转换" class="headerlink" title="色彩转换"></a>色彩转换</h1><p>色彩转换指的是将图像的Bitmap格式，从一个色彩格式，比如ARGB8888，转换到另一个色彩格式，比如说RGB888的功能。对于RGB来说，一般来说就是通道的增加和减少。当然还有RGB转为Planar8的情况。</p>
<p>vImage对这些色彩转换的功能，统一提供了方法<code>vImageConvert_AtoB</code>，比如ARGB8888转RGB888，就可以用下面的代码来处理。顺便通过这个代码，来简单了解vImage的API的基本用法。</p>
<p>先来定义几个简单的结构体，方便后续使用：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了方便，我们首先直接定义好ARGB8888的format结构体，后续需要多次使用</span></span><br><span class="line"><span class="keyword">static</span> vImage_CGImageFormat vImageFormatARGB8888 = (vImage_CGImageFormat) &#123;</span><br><span class="line">    .bitsPerComponent = <span class="number">8</span>, <span class="comment">// 8位</span></span><br><span class="line">    .bitsPerPixel = <span class="number">32</span>, <span class="comment">// ARGB4通道，4*8</span></span><br><span class="line">    .colorSpace = <span class="literal">NULL</span>, <span class="comment">// 默认就是sRGB</span></span><br><span class="line">    .bitmapInfo = kCGImageAlphaFirst | kCGBitmapByteOrderDefault, <span class="comment">// 表示ARGB</span></span><br><span class="line">    .version = <span class="number">0</span>, <span class="comment">// 或许以后会有版本区分，现在都是0</span></span><br><span class="line">    .decode = <span class="literal">NULL</span>, <span class="comment">// 和`CGImageCreate`的decode参数一样，可以用来做色彩范围映射的，NULL就是[0, 1.0]</span></span><br><span class="line">    .renderingIntent = kCGRenderingIntentDefault, <span class="comment">// 和`CGImageCreate`的intent参数一样，当色彩空间超过后如何处理</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// RGB888的format结构体</span></span><br><span class="line"><span class="keyword">static</span> vImage_CGImageFormat vImageFormatRGB888 = (vImage_CGImageFormat) &#123;</span><br><span class="line">    .bitsPerComponent = <span class="number">8</span>, <span class="comment">// 8位</span></span><br><span class="line">    .bitsPerPixel = <span class="number">24</span>, <span class="comment">// RGB3通道，3*8</span></span><br><span class="line">    .colorSpace = <span class="literal">NULL</span>,</span><br><span class="line">    .bitmapInfo = kCGImageAlphaNone | kCGBitmapByteOrderDefault, <span class="comment">// 表示RGB</span></span><br><span class="line">    .version = <span class="number">0</span>,</span><br><span class="line">    .decode = <span class="literal">NULL</span>,</span><br><span class="line">    .renderingIntent = kCGRenderingIntentDefault,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 字节对齐使用，vImage如果不是64字节对齐的，会有额外开销</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> size_t vImageByteAlign(size_t size, size_t alignment) &#123;</span><br><span class="line">    <span class="keyword">return</span> ((size + (alignment - <span class="number">1</span>)) / alignment) * alignment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，就是完整的转换代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">CGImageRef</span>)nonAlphaImageWithImage:(<span class="built_in">CGImageRef</span>)aImage</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 首先，我们声明input和output的buffer</span></span><br><span class="line">    __block vImage_Buffer a_buffer = &#123;&#125;, output_buffer = &#123;&#125;;</span><br><span class="line">    @onExit &#123;</span><br><span class="line">        <span class="comment">// 由于vImage的API需要手动管理内存，避免内存泄漏</span></span><br><span class="line">        <span class="comment">// 为了方便错误处理清理内存，可以使用clang attibute的cleanup（这里是libextobjc的宏）</span></span><br><span class="line">        <span class="comment">// 如果不这样，还有一种方式，就是使用goto，定义一个fail:的label，所有return NULL改成`goto fail`;</span></span><br><span class="line">        <span class="keyword">if</span> (a_buffer.data) free(a_buffer.data);</span><br><span class="line">        <span class="keyword">if</span> (output_buffer.data) free(output_buffer.data);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 首先，创建一个buffer，可以用vImage提供的CGImage的便携构造方法，里面需要传入原始数据所需要的format，这里就是ARGB8888</span></span><br><span class="line">    vImage_Error a_ret = vImageBuffer_InitWithCGImage(&amp;a_buffer, &amp;vImageFormatARGB8888, <span class="literal">NULL</span>, aImage, kvImageNoFlags);</span><br><span class="line">    <span class="comment">// 所有vImage的方法一般都有一个result，判断是否成功</span></span><br><span class="line">    <span class="keyword">if</span> (a_ret != kvImageNoError) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 接着，我们需要对output buffer开辟内存，这里由于是RGB888，对应的rowBytes是3 * width，注意还需要64字节对齐，否则vImage处理会有额外的开销。</span></span><br><span class="line">    output_buffer.width = a_buffer.width;</span><br><span class="line">    output_buffer.height = a_buffer.height;</span><br><span class="line">    output_buffer.rowBytes = vImageByteAlign(output_buffer.width * <span class="number">3</span>, <span class="number">64</span>);</span><br><span class="line">    output_buffer.data = malloc(output_buffer.rowBytes * output_buffer.height);</span><br><span class="line">    <span class="comment">// 这里使用vImage的convert方法，转换色彩格式</span></span><br><span class="line">    vImage_Error ret = vImageConvert_ARGB8888toRGB888(&amp;a_buffer, &amp;output_buffer, kvImageNoFlags);</span><br><span class="line">    <span class="keyword">if</span> (ret != kvImageNoError) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 此时已经output buffer已经转换完成，输出回CGImage</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> outputImage = vImageCreateCGImageFromBuffer(&amp;output_buffer, &amp;vImageFormatRGB888, <span class="literal">NULL</span>, <span class="literal">NULL</span>, kvImageNoFlags, &amp;ret);</span><br><span class="line">    <span class="keyword">if</span> (ret != kvImageNoError) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> outputImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="任意色彩格式转换"><a href="#任意色彩格式转换" class="headerlink" title="任意色彩格式转换"></a>任意色彩格式转换</h2><p>除了一系列<code>vImageConvert_AtoB</code>的转换，vImage还提供了一个非常抽象的接口，叫做<code>vImageConvert_AnyToAny</code>，只需要你提供一个input format，一个output format，就可以直接转换。这个接口比较强大，不仅能够handler所有支持的色彩格式，而且还能支持<code>CVImageBuffer</code>（通过这个<code>vImageConverter</code>来构造）。所以一般如果做库封装，做一些色彩转换的case的时候，就可以试着用这个接口。</p>
<p>因此，我们之前的ARGB8888ToRGB888的色彩转换，可以这样写，更为通用。示例代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vImageConverterRef converter = vImageConverter_CreateWithCGImageFormat(&amp;vImageFormatARGB8888, &amp;vImageFormatRGB888, <span class="literal">NULL</span>, kvImageNoFlags, &amp;ret);</span><br><span class="line"><span class="keyword">if</span> (ret != kvImageNoError) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">ret = vImageConvert_AnyToAny(converter, &amp;a_buffer, &amp;output_buffer, <span class="literal">NULL</span>, kvImageNoFlags);</span><br></pre></td></tr></table></figure>


<h1 id="Alpha合成"><a href="#Alpha合成" class="headerlink" title="Alpha合成"></a>Alpha合成</h1><p><img src="https://raw.githubusercontent.com/dreampiggy/vImageProcessor/master/Example/Screenshot/Screenshot1.png" alt="Alpha合成"></p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Alpha_compositing">Alpha合成</a>指的是将两张含有Alpha通道的图（被Blend的叫做bottom，Blend的叫做top），通过一定的公式合成成为一张新的含Alpha通道的图，一般来说用于给图像添加遮罩、覆盖等，常见的图像处理软件都有这个功能。其实本质上来说，Alpha合成，就是对图像的每一个像素值，进行这样一个计算：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resultAlpha = (topAlpha * <span class="number">255</span> + (<span class="number">255</span> - topAlpha)</span><br><span class="line">                 * bottomAlpha + <span class="number">127</span>) / <span class="number">255</span></span><br><span class="line">resultColor = (topAlpha * topColor + (((<span class="number">255</span> - topAlpha)</span><br><span class="line">                 * bottomAlpha + <span class="number">127</span>) / <span class="number">255</span>) * bottomColor +  <span class="number">127</span>)</span><br><span class="line">                    / resultAlpha</span><br></pre></td></tr></table></figure>

<p>公式看起来比较复杂，因此这里顺便可以介绍一下关于<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000002990030">premultiplied-alpha</a>的概念，直观地说，就是将<code>(r, g, b, a)</code>预先乘以了对应的alpha通道的值，成为<code>(r * a, g * a, b * a, a)</code>。这个带来的好处，就是Alpha合成的时候，可以少一次乘法，而且简化了计算，成为这样子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">resultColor = (topColor + (((<span class="number">255</span> - topAlpha)</span><br><span class="line">                 * bottomAlpha + <span class="number">127</span>) / <span class="number">255</span>) * bottomColor +  <span class="number">127</span>)</span><br></pre></td></tr></table></figure>

<p>在vImage中，已经提供了一个接口来专门处理Alpha合成，针对nonpremultiplied的，是<code>vImageAlphaBlend_ARGB8888</code>，而针对premultiplied，是<code>vImagePremultipliedAlphaBlend_ARGB8888</code>。需要注意的是，这个接口要求的两个buffer，宽度和高度必须相等，因此，我们对于Color和Image的遮罩，需要进行处理，保证这两个buffer满足要求。</p>
<h2 id="Alpha-Blend-Color"><a href="#Alpha-Blend-Color" class="headerlink" title="Alpha Blend Color"></a>Alpha Blend Color</h2><p>这个用处，一般是用来做图像的遮罩的，可以对图像整体盖一层有透明度的颜色，比如说夜间模式，纯色滤镜等。根据上面说的，如果需要对一个Bitmap使用vImage进行Alpha Blend，我们需要保证两个buffer的宽度和高度相同，因此可以使用<code>vImageBufferFill_ARGB8888</code>填充整个Color来构造一个与输入图像Buffer相同宽高的新buffer，然后用它来进行Alpha Blend。</p>
<p>代码示例：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGImageRef</span> aImage; <span class="comment">// 输入的bottom Image</span></span><br><span class="line"><span class="built_in">CGColorRef</span> color; <span class="comment">// 输入的color</span></span><br><span class="line">__block vImage_Buffer a_buffer = &#123;&#125;, b_buffer = &#123;&#125;, output_buffer = &#123;&#125;; <span class="comment">// 分别是bottom buffer，top buffer和最后的output buffer</span></span><br><span class="line">Pixel_8888 pixel_color = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="type">double</span> *components = <span class="built_in">CGColorGetComponents</span>(color);</span><br><span class="line"><span class="keyword">const</span> size_t components_size = <span class="built_in">CGColorGetNumberOfComponents</span>(color);</span><br><span class="line"><span class="comment">// 对CGColor进行转换到Pixel_8888</span></span><br><span class="line"><span class="keyword">if</span> (components_size == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// white, alpha</span></span><br><span class="line">    pixel_color[<span class="number">0</span>] = components[<span class="number">1</span>] * <span class="number">255</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// red, green, blue, (alpha)</span></span><br><span class="line">    pixel_color[<span class="number">0</span>] = components_size == <span class="number">3</span> ? <span class="number">255</span> : components[<span class="number">3</span>] * <span class="number">255</span>;</span><br><span class="line">    pixel_color[<span class="number">1</span>] = components[<span class="number">0</span>] * <span class="number">255</span>;</span><br><span class="line">    pixel_color[<span class="number">2</span>] = components[<span class="number">1</span>] * <span class="number">255</span>;</span><br><span class="line">    pixel_color[<span class="number">3</span>] = components[<span class="number">2</span>] * <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 填充color到top buffer</span></span><br><span class="line">vImage_Error b_ret = vImageBufferFill_ARGB8888(&amp;b_buffer, pixel_color , kvImageNoFlags);</span><br><span class="line"><span class="keyword">if</span> (b_ret != kvImageNoError) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// Alpha Blend</span></span><br><span class="line">vImage_Error ret = vImageAlphaBlend_ARGB8888(&amp;b_buffer, &amp;a_buffer, &amp;output_buffer, kvImageNoFlags);</span><br></pre></td></tr></table></figure>


<h2 id="Alpha-Blend-Image"><a href="#Alpha-Blend-Image" class="headerlink" title="Alpha Blend Image"></a>Alpha Blend Image</h2><p>上面说到了关于Color的Alpha Blend，不同于Color这种需要填充全部宽度，如果对于一个Image需要进行Alpha Blend，我们大部分情况都是需要制定一个起始点的，因为不能保证所有输入的两个Image的宽高相同。因此设计的时候，可以给用户提供一个point参数，以这个坐标点开始来绘制Alpha Blend，类似于很多图像编辑软件提供的图层功能。</p>
<p>由于vImage的Alpha Blend需要两个等宽高的Buffer，因此我们需要对用户提供的Top Image进行处理，通过平移变换移动到指定的Point以后，填充其余部分为Clear Color。最后进行Alpha Blend即可。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGImageRef</span> aImage, bImage; <span class="comment">// 输入的bottom Image和top Image</span></span><br><span class="line">__block vImage_Buffer a_buffer = &#123;&#125;, b_buffer = &#123;&#125;, c_buffer = &#123;&#125;, output_buffer = &#123;&#125;;</span><br><span class="line"><span class="comment">//c buffer指的是将top Image进行处理后的临时buffer，使得宽高同bottom image相同</span></span><br><span class="line"><span class="comment">// 这里我们使用到了线性变换的平移变换，以(0,0)放置top image，然后偏移point个像素点，其余部分填充clear color，即可得到这个处理后的c buffer</span></span><br><span class="line"><span class="built_in">CGAffineTransform</span> transform = <span class="built_in">CGAffineTransformMakeTranslation</span>(point.x, point.y);</span><br><span class="line">vImage_CGAffineTransform cg_transform = *((vImage_CGAffineTransform *)&amp;transform);</span><br><span class="line">Pixel_8888 clear_color = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">vImage_Error c_ret = vImageAffineWarpCG_ARGB8888(&amp;b_buffer, &amp;c_buffer, <span class="literal">NULL</span>, &amp;cg_transform, clear_color, kvImageBackgroundColorFill);</span><br><span class="line"><span class="keyword">if</span> (c_ret != kvImageNoError) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 略过output buffer初始化</span></span><br><span class="line"><span class="comment">// 将bottom image和处理后的c buffer进行Alpha Blend</span></span><br><span class="line">vImage_Error ret = vImageAlphaBlend_ARGB8888(&amp;c_buffer, &amp;a_buffer, &amp;output_buffer, kvImageNoFlags);</span><br></pre></td></tr></table></figure>

<h1 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h1><p>几何变换，指的是将一个原始的Bitmap，通过线性方法进行处理，实现比如平移、缩放、旋转、错切等操作的图像处理技术。</p>
<p>可能大部分人已经知道了（之前也说过），Core Graphics的坐标系统，和UIKit的坐标系统，在Y坐标上是相反的。UIKit的使用的是Y轴正向垂直向下的左手系，而Core Graphics和普通的右手系直角坐标系相同。vImage也遵守了右手系，因此之后介绍的变换都是按照右手系的，如果想处理UIKit的坐标系，自己转换一下即可（一般就是取<code>image.height - offsetY</code>即可）</p>
<p>关于要介绍的的这些几何变换，虽然都最后可以统一到到线性变换上，只不过效率上可能相比单独的方法来说有所损耗，因此单独对每个功能所需要的vImage接口进行了介绍。关于线性变换不太理解的，可以参考一下之前的一篇教程：<a href="http://dreampiggy.com/2016/09/27/core-graphicsfang-she-bian-huan/">Core Graphics仿射变换知识</a></p>
<h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><p><img src="https://raw.githubusercontent.com/dreampiggy/vImageProcessor/master/Example/Screenshot/Screenshot2.png" alt="缩放"></p>
<p>缩放是最简单的一个处理过程，但是由于缩放之后，之前的同一个像素点，现在可能会映射到4个或者更多像素点，或者是原本4个像素点，现在需要映射到1个像素点。这就会涉及到一个叫做<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Image_scaling">图像重采样</a>的过程。具体来说，就是对每一个像素，所在的Bitmap的子矩阵（比如3x3），通过一定的算法计算，得到对应的缩放以后的中心像素的值。同时，这个像素值可能变成浮点数，还需要进行处理，最后填到采样后的Bitmap相应的位置上。常见的简单处理有最邻近算法、双线性算法、双立方算法等。</p>
<p>vImage默认使用的是<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Lanczos_resampling">Lanczos Algorithm</a>，具体的介绍可以参考Wikipedia和DSP相关的书籍。这里有一个直观的对比表现<a target="_blank" rel="noopener" href="https://clouard.users.greyc.fr/Pantheon/experiments/rescaling/index-en.html">网页</a>。如果想要更高画质的算法，可以提供<code>kvImageHighQualityResampling</code>参数，来使用<code>Lanczos5</code>算法。或者可以使用之后要谈的相对底层一点的错切API，来自定义你的重采样过程。</p>
<p>vImage提供了自带的<code>vImageScale_ARGB8888</code>方法，这里就简单举个例子（之前重复代码的都略过）：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGSize</span> size; <span class="comment">// 目标大小</span></span><br><span class="line">output_buffer.width = MAX(size.width, <span class="number">0</span>);</span><br><span class="line">output_buffer.height = MAX(size.height, <span class="number">0</span>);</span><br><span class="line">output_buffer.rowBytes = vImageByteAlign(output_buffer.width * <span class="number">4</span>, <span class="number">64</span>);</span><br><span class="line">output_buffer.data = malloc(output_buffer.rowBytes * output_buffer.height);</span><br><span class="line"><span class="keyword">if</span> (!output_buffer.data) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 进行缩放，输出到output buffer中</span></span><br><span class="line">vImage_Error ret = vImageScale_ARGB8888(&amp;a_buffer, &amp;output_buffer, <span class="literal">NULL</span>, kvImageHighQualityResampling);</span><br></pre></td></tr></table></figure>

<h2 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h2><p>裁剪是指的将原始Bitmap，只裁出来指定矩形大小的部分，其余部分直接丢弃的过程。虽然vImage没有提供直接的API来处理这个流程（当然你是可以用vecLib的方法，直接对Bitmap进行矩阵操作，但是有点过于小题大做了）。但是实际上，这就是一个平移变换能够搞定的事情。我们只需要对输入目标的坐标的<code>CGRect</code>进行转换，将原始图像平移之后，再限制输出的Bitmap的大小，这样平移超出部分就会自动被裁掉。不需额外的处理，示例代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGRect</span> rect; <span class="comment">// 输入的目标rect</span></span><br><span class="line">output_buffer.width = MAX(<span class="built_in">CGRectGetWidth</span>(rect), <span class="number">0</span>); <span class="comment">// 输出宽度</span></span><br><span class="line">output_buffer.height = MAX(<span class="built_in">CGRectGetHeight</span>(rect), <span class="number">0</span>); <span class="comment">// 输出高度</span></span><br><span class="line">output_buffer.rowBytes = vImageByteAlign(output_buffer.width * <span class="number">4</span>, <span class="number">64</span>);</span><br><span class="line">output_buffer.data = malloc(output_buffer.rowBytes * output_buffer.height);</span><br><span class="line"><span class="keyword">if</span> (!output_buffer.data) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用平移来处理，X轴Y轴分别平移负向的minX，minY即可</span></span><br><span class="line"><span class="built_in">CGFloat</span> tx = <span class="built_in">CGRectGetMinX</span>(rect);</span><br><span class="line"><span class="built_in">CGFloat</span> ty = <span class="built_in">CGRectGetMinY</span>(rect);</span><br><span class="line"><span class="built_in">CGAffineTransform</span> transform = <span class="built_in">CGAffineTransformMakeTranslation</span>(-tx, -ty);</span><br><span class="line">vImage_CGAffineTransform cg_transform = *((vImage_CGAffineTransform *)&amp;transform);</span><br><span class="line">Pixel_8888 clear_color = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">vImage_Error ret = vImageAffineWarpCG_ARGB8888(&amp;a_buffer, &amp;output_buffer, <span class="literal">NULL</span>, &amp;cg_transform, clear_color, kvImageBackgroundColorFill);</span><br></pre></td></tr></table></figure>

<h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>镜像顾名思义，就是将图像沿着某个轴进行翻转，比如沿X轴就是水平镜像，同一个像素点，对应的X坐标不变，Y坐标变为高度减去本身的Y坐标即可。</p>
<p>vImage对应的API，是<code>vImageVerticalReflect_ARGB8888</code>和<code>vImageHorizontalReflect_ARGB8888</code>，使用起来也比较简单。直接上一个简单的示例：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BOOL</span> horizontal;</span><br><span class="line">__block vImage_Buffer a_buffer = &#123;&#125;, output_buffer = &#123;&#125;;</span><br><span class="line"><span class="comment">// 省略</span></span><br><span class="line">vImage_Error ret;</span><br><span class="line"><span class="keyword">if</span> (horizontal) &#123;</span><br><span class="line">    <span class="comment">// 水平镜像</span></span><br><span class="line">    ret = vImageHorizontalReflect_ARGB8888(&amp;a_buffer, &amp;output_buffer, kvImageHighQualityResampling);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 垂直镜像</span></span><br><span class="line">    ret = vImageVerticalReflect_ARGB8888(&amp;a_buffer, &amp;output_buffer, kvImageHighQualityResampling);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>旋转也是非常常见一个图像几何几何变化。具体坐标的变化就是对旋转的角度，求对应三角函数到X轴和Y轴的投影结果，比较直观。</p>
<p>vImage对旋转也提供了一个非常方便的API，角度是弧度值，按照顺时针方向进行。另外，由于输出的Buffer的大小会限制图像大小，而旋转后可能超出原图大小，我们需要对输出的大小也计算出对应的新的大小。示例代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGFloat</span> radians; <span class="comment">//旋转的弧度</span></span><br><span class="line"><span class="built_in">CGSize</span> size = <span class="built_in">CGSizeMake</span>(a_buffer.width, a_buffer.height);</span><br><span class="line"><span class="comment">// 这里直接借用CG的方法来计算旋转后的大小，方便</span></span><br><span class="line"><span class="built_in">CGAffineTransform</span> transform = <span class="built_in">CGAffineTransformMakeRotation</span>(radians);</span><br><span class="line">size = <span class="built_in">CGSizeApplyAffineTransform</span>(size, transform);    output_buffer.width = ABS(size.width);</span><br><span class="line">output_buffer.height = ABS(size.height);</span><br><span class="line">output_buffer.rowBytes = vImageByteAlign(output_buffer.width * <span class="number">4</span>, <span class="number">64</span>);</span><br><span class="line">output_buffer.data = malloc(output_buffer.rowBytes * output_buffer.height);</span><br><span class="line"><span class="keyword">if</span> (!output_buffer.data) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">Pixel_8888 clear_color = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">// 旋转操作，多余部分填充Clear Color</span></span><br><span class="line">vImage_Error ret = vImageRotate_ARGB8888(&amp;a_buffer, &amp;output_buffer, <span class="literal">NULL</span>, radians, clear_color, kvImageBackgroundColorFill | kvImageHighQualityResampling);</span><br></pre></td></tr></table></figure>

<h2 id="错切"><a href="#错切" class="headerlink" title="错切"></a>错切</h2><p><img src="https://raw.githubusercontent.com/dreampiggy/vImageProcessor/master/Example/Screenshot/Screenshot3.png" alt="错切"></p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Shear_mapping">错切</a>是一种特殊的线性变换，直观的介绍可以从Wikipedia上看，也可以参考之前的另一篇教程。主要的参数有一个m值，表示对应参考坐标的缩放倍数。</p>
<p>在vImage中，错切变换是相对底层的接口，实际上，线性变换是通过这三个接口（错切、旋转、镜像）来实现的。错切的接口，比如水平错切对应的是<code>vImageHorizontalShear_ARGB8888</code>，参数算是最多的一个，稍微详细介绍一下：</p>
<ul>
<li><code>srcOffsetToROI_X</code>: 错切定位点水平偏移量，具体指的就是左上角那个像素点，在经过旋转的映射后，水平偏移的距离，会影响最后图像（除去Buffer的宽度限制）的整体宽度</li>
<li><code>srcOffsetToROI_Y</code>: 错切定位点的垂直偏移量，类似水平值</li>
<li><code>xTranslate</code>: 错切完成后的水平平移距离</li>
<li><code>shearSlope</code>: 错切的弧度值，顺时针</li>
<li><code>filter</code>: 用来自定义重采样的方法，一般用自带的<code>vImageNewResamplingFilter</code>，或者也可以提供一个函数指针构造对应的重采样过程。会用到一个scale参数，表示这个重采样对应的缩放倍数，也就是错切的m值</li>
<li><code>backgroundColor</code>: 背景填充色</li>
</ul>
<p>对应的示例代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGVector</span> offset; <span class="comment">// 定位点偏移量</span></span><br><span class="line"><span class="built_in">CGFloat</span> translation; <span class="comment">// 水平平移量</span></span><br><span class="line"><span class="built_in">CGFloat</span> slope; <span class="comment">// 旋转弧度</span></span><br><span class="line"><span class="built_in">CGFloat</span> scale; <span class="comment">// 对应错切的m值</span></span><br><span class="line">output_buffer.width = MAX(a_buffer.width - offset.dx, <span class="number">0</span>); <span class="comment">//这里需要同时减去水平定位点的偏移</span></span><br><span class="line">output_buffer.height = MAX(a_buffer.height - offset.dy, <span class="number">0</span>); <span class="comment">// 同理</span></span><br><span class="line">output_buffer.rowBytes = vImageByteAlign(output_buffer.width * <span class="number">4</span>, <span class="number">64</span>);</span><br><span class="line">output_buffer.data = malloc(output_buffer.rowBytes * output_buffer.height);</span><br><span class="line"><span class="keyword">if</span> (!output_buffer.data) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">Pixel_8888 clear_color = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">// 这里示例就用默认的重采样方法</span></span><br><span class="line">ResamplingFilter resampling_filter = vImageNewResamplingFilter(scale, kvImageHighQualityResampling);</span><br><span class="line">vImage_Error ret;</span><br><span class="line"><span class="keyword">if</span> (horizontal) &#123;</span><br><span class="line">    <span class="comment">// 水平错切</span></span><br><span class="line">    ret = vImageHorizontalShear_ARGB8888(&amp;a_buffer, &amp;output_buffer, offset.dx, offset.dy, translation, slope, resampling_filter, clear_color, kvImageBackgroundColorFill);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 垂直错切</span></span><br><span class="line">    ret = vImageVerticalShear_ARGB8888(&amp;a_buffer, &amp;output_buffer, offset.dx, offset.dy, translation, slope, resampling_filter, clear_color, kvImageBackgroundColorFill);</span><br><span class="line">&#125;</span><br><span class="line">vImageDestroyResamplingFilter(resampling_filter);</span><br></pre></td></tr></table></figure>

<h2 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h2><p>最后再来说通用的线性变换吧，这个其实在之前的功能中已经用到过了，vImage有兼容Core Graphics的<code>CGAffineTransform</code>的结构体<code>vImage_CGAffineTransform</code>，两个结构体对应的内存布局是一样的，直接强制转换过去就可以了，不需要单独赋一遍。关于通用线性变换的内容就不再赘述了，有兴趣可以查看相关资料，或者之前的教程：<a href="http://dreampiggy.com/2016/09/27/core-graphicsfang-she-bian-huan/">Core Graphics仿射变换知识</a></p>
<p>示例代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGAffineTransform</span> transform; <span class="comment">// 输入的CG变换矩阵</span></span><br><span class="line">vImage_CGAffineTransform cg_transform = *((vImage_CGAffineTransform *)&amp;transform); <span class="comment">// 结构一样，直接强转</span></span><br><span class="line">Pixel_8888 clear_color = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">// 线性变换</span></span><br><span class="line">vImage_Error ret = vImageAffineWarpCG_ARGB8888(&amp;a_buffer, &amp;output_buffer, <span class="literal">NULL</span>, &amp;cg_transform, clear_color, kvImageBackgroundColorFill | kvImageHighQualityResampling);</span><br></pre></td></tr></table></figure>


<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>vImage是一个比较底层的图像Bitmap处理的库，在这里介绍了关于色彩转换、Alpha合成、几何变换等基本知识。相比于简单的Core Graphics的处理，能够提供更为复杂的参数控制，并且带来较高的性能。对于很多图像密集处理软件处理来说，用Core Graphics显的比较低效，因此可以考虑vImage。</p>
<p>但是vImage强大之处远不在这里，里面还包含了类似图像卷积，形态处理等，可以对复杂滤镜进行支持，类似于<a target="_blank" rel="noopener" href="https://github.com/BradLarson/GPUImage">GPUImage</a>。这些功能都需要数字图像处理相关知识，在这种教程系列就不会介绍了。</p>
<p>对于这篇教程的示例代码，其实我写了个非常简单的库，放到GitHub上了：<a target="_blank" rel="noopener" href="https://github.com/dreampiggy/vImageProcessor">vImageProcessor</a>，有兴趣的可以去参考一下，希望能够用于自己的图片处理相关框架中。</p>
<p>由于自己完全是业余兴趣，工作和图像处理基本不相关，并不打算深入学习数字图像处理的知识，因此这个教程可能就会暂时告一段落了。最后，之所以写这篇教程，是因为自己想要参考一下vImage的教程，却发现只会搜出来一堆互相抄袭的内容，而且大部分都是关于图像滤镜的，对于图像处理本身不会太多介绍。我希望这系列教程，能给同样对图像编解码、图像处理有一点兴趣的人，提供一个相对简单且清晰的入门概览吧。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/iOS/" rel="tag"># iOS</a>
              <a href="/tags/Image/" rel="tag"># Image</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2017/10/30/iOS%E5%B9%B3%E5%8F%B0%E5%9B%BE%E7%89%87%E7%BC%96%E8%A7%A3%E7%A0%81%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%88%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BC%96%E8%A7%A3%E7%A0%81%E7%AF%87%EF%BC%89/" rel="prev" title="iOS平台图片编解码入门教程（第三方编解码篇）">
      <i class="fa fa-chevron-left"></i> iOS平台图片编解码入门教程（第三方编解码篇）
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/11/26/CocoaPods%E7%9A%84%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%92%8CAsset%20Catalog%E4%BC%98%E5%8C%96/" rel="next" title="CocoaPods的资源管理和Asset Catalog优化">
      CocoaPods的资源管理和Asset Catalog优化 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text">基本介绍</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%89%B2%E5%BD%A9%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.</span> <span class="nav-text">色彩转换</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E6%84%8F%E8%89%B2%E5%BD%A9%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.1.</span> <span class="nav-text">任意色彩格式转换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Alpha%E5%90%88%E6%88%90"><span class="nav-number">3.</span> <span class="nav-text">Alpha合成</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Alpha-Blend-Color"><span class="nav-number">3.1.</span> <span class="nav-text">Alpha Blend Color</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Alpha-Blend-Image"><span class="nav-number">3.2.</span> <span class="nav-text">Alpha Blend Image</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2"><span class="nav-number">4.</span> <span class="nav-text">几何变换</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%A9%E6%94%BE"><span class="nav-number">4.1.</span> <span class="nav-text">缩放</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A3%81%E5%89%AA"><span class="nav-number">4.2.</span> <span class="nav-text">裁剪</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%95%9C%E5%83%8F"><span class="nav-number">4.3.</span> <span class="nav-text">镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%8B%E8%BD%AC"><span class="nav-number">4.4.</span> <span class="nav-text">旋转</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%99%E5%88%87"><span class="nav-number">4.5.</span> <span class="nav-text">错切</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2"><span class="nav-number">4.6.</span> <span class="nav-text">线性变换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="DreamPiggy"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">DreamPiggy</p>
  <div class="site-description" itemprop="description">DreamPiggy的个人博客，分享一些关于iOS开发，Web开发以及其它好玩东西的地方</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">60</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">50</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/dreampiggy" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dreampiggy" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/DreamingPiggy" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;DreamingPiggy" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://weibo.com/dreampiggy" title="Weibo → http:&#x2F;&#x2F;weibo.com&#x2F;dreampiggy" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/dreampiggy" title="Zhihu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;dreampiggy" rel="noopener" target="_blank"><i class="fab fa-zhihu fa-fw"></i>Zhihu</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://neverchanje.github.io/" title="https:&#x2F;&#x2F;neverchanje.github.io&#x2F;" rel="noopener" target="_blank">neverchanje</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://zltunes.com/" title="http:&#x2F;&#x2F;zltunes.com&#x2F;" rel="noopener" target="_blank">zltunes</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://huozhi.github.io/" title="http:&#x2F;&#x2F;huozhi.github.io&#x2F;" rel="noopener" target="_blank">huozhi</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DreamPiggy</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '783d0f6afbe6385e00fe',
      clientSecret: '1ce280f20fd69e57611792eb3b660ada8385af2c',
      repo        : 'dreampiggy.github.io',
      owner       : 'dreampiggy',
      admin       : ['dreampiggy'],
      id          : 'e9d6fd4a8fa2827905066f2f8783a979',
        language: window.navigator.language || window.navigator.userLanguage,
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>

[{"title":"2016年末总结和近期感想","url":"/2016/12/31/2016%E5%B9%B4%E6%9C%AB%E6%80%BB%E7%BB%93%E5%92%8C%E8%BF%91%E6%9C%9F%E6%84%9F%E6%83%B3/","content":"\n> 年后的最后一天，也是该总结一下这一年的成长了。\n\n# 从校园到实习\n\n软件专业的大三学年，如果你不考研留学的话，说起来都是会走实习加校招的流程。自己这年印象最深的，也就是整个下半年的实习，面试，以及现在的实习了。\n\n大三上的实习当时自己错过了机会，只进入了一个普通的互联网公司，但是也学到了更多校园中无法见到的东西（比如多移动App多Project管理，MapKit，React Native），开阔了一点眼界。真正的下半年好几个月都在忙着校招面试相关的东西，从中也总结了一些经验吧（虽然不知道对社招是否有帮助）。然而到现在，从南京来到了北京，提前过来头条这边实习。\n\n实习开始都是兴奋和好奇的，因为可以看到公司的各种设施，福利，还有认识各式各样的人。来这边也是专门拉了两个同公司的应届生一起来，也挺愉快的。公司离得近，组里的人也都比较厉害（至少都是我请教别人教育的情形），虽然上班累了些，但是感觉自己成长也是非常的大，很难想象假如不来实习，全靠自己摸索，明年直接毕业过来上班自己是什么样的水平。\n\n# 近期工作感想\n\n来到头条这边也刚刚好一个月了把。这期间最大的感触，就是自己的工作和产品将会面对的是上千万级别的日活用户，而且不同于之前的实习那样一人负责非常小的业务，看看需求，写写代码，测试简单过一遍，直接就git提上去了。在这里，整个工作流都是有专门有PM跟，并且开发都是自己checkout分支不断merge，节奏更是快了不少。提测流程也是更加的严格，因为现在你开发的产品不再是发展启蒙阶段的不完成品，一个需求如果不能覆盖好完整的边界情况，宁愿不要这个功能，也不能带着一点侥幸心理上线。在千万级别使用量的冲击下，任何情况都可能发生。因此一定要做好特殊情况的处理。\n\n同时，在产品达到一定规模，我也越发察觉到AB测试、开关、日志监控和报警功能的重要性了。移动App不同于Web前端，一旦发一个版出去，那么就得考虑对应的兼容性和留存率。一旦出现线上Bug，立即发现并且关闭对应的功能是非常重要的解决方式，之后可以再考虑使用热修复技术来对旧版本进行处理。来这里可以看到各种功能都考虑了埋点，日志，还有AB测的开关。在校园期间自己接触开发流程中少了很多关于这方面的意识，正需要借此多加注意。\n\n# 工作中的技术问题\n\n## AVFoundation的注意\n\n由于有需求要做录像和人脸识别相关的东西，因此自己才真正使用了AVFoundation这个Apple提供的媒体库。虽然你可以简单的在SF上搜到一堆答案，但是真实的开发有很多潜在的问题。尤其是这种涉及到硬件层面的API，稍不留神就会报Crash。\n\n比如最常见的问题，用来保持一个输入设备到输出设备的会话，会用到Session，而AVFoundation中的这个`AVCaptureSession`的很多方法，都是阻塞的。简单的启动录制流`- startRunning`方法也是阻塞线程的（这一点在文档中有说明，需要注意），要使用一个单独的concurrent queue来处理，并且还要记得dispatch到mainQueue上来供外部UIKit的使用，不然其实看起来表面上UI是正常的，但是整个UIResponser就会受到影响。其他的还有比如修改输入流，输出流的配置（比如视频流的方向，帧率之类）的配置时候，也得配合`- beginConfiguration`和`- commitConfiguration`，不然会出现线程冲突的问题。\n\n还有的坑点，不同于ImagePicker，AVFoundation的采集回调也需要你手动指定线程，比如`AVCaptureAudioDataOutputSampleBufferDelegate`可以用来持续的采集buffer来生成对于的Image，进而用于`OpenCV`或者自带的`CIDetercor`做人脸识别的持续追踪。但是在调试时候没有注意到回调在非主线程而进行了UI操作导致各种的问题，浪费了很多时间，看来自己理论上的知识和实际的经验还需要再磨练一些。\n\n## 手动处理单向数据流的坑\n\n因为之前一直在看一些React呀，Rx系列的东西，所以见到一个需求看到对应的页面状态不多，就想试试用这种单项绑定数据流来写。由于App对包大小比较敏感，也没有引入`ReactiveCocoa`，自己参考着React的Redux一般，放了一个单独的Store Model来作为状态的Store，同时定义了十几种状态。所有的View层（View和ViewController）的交互导致的状态变化，模型变化必须通过ViewModel的调用才能修改Store Model，而Model的数据校验也都丢到了ViewModel里面。这就形成了类似Redux那种View(View／ViewController) -> Action(ViewModel) -> Store(Model) -> View的单项数据流动。\n\n看起来一切都很美好，但是实际写起来就发现简单照搬的单向数据流的问题了。随着需求的变动，经常会有那种需要你这一个ViewController实例的某些操作后同步到其他ViewController的UI上（比如用户交互或者网络请求的响应改变了Store Model，在导航栈上前几个页面也需要刷新UI），按照最笨的写法那种在当前的ViewController绑定一个callback或者delegate回调肯定是不好的（虽然我之前也这么写过，参考了Android的Intent也是这样子做的）。但是参考的Redux的管理方式下，其实是不会特别考虑这种情况的，因为React的render方法会在你的props变动的时候触发，你最多可以判断一下是不是需要rerender就行了。然而在原生App中，你几乎总是避免rerender，只是改变某些UI的属性罢了。\n\n最开始我的解决策略是放到了`ViewWillAppear`中，强行Switch了当前的状态来传递Model到View层。但是这种情况下会导致把你的正常View逻辑也写的特别乱（得有各种判断）。更可怕的是当你的ViewController并不是一对一绑定给真正的页面，而是一个ViewController模版对应五六种类似页面布局的ContainerView时，你就可以发现代码中会有好几处不同的Switch。这并不是一个好的架构。现在的解决方案是通过ViewModel绑定了所有ViewController的弱引用，在ViewModel通用的状态处理逻辑中判断，并且直接调用ViewController的updateViews，继而走到真实的某个View的UI刷新方法中。但是这样做的缺点就是你的ViewModel逻辑会同时包括了第一次初始化和更新的东西，这就是比较让人麻烦的地方。也试过KVO来绑定了View，但是由于我的ViewController本身就是个通用模版，绑定的真实实例和销毁时机也得判断，所以Pass……\n\n现在想想，ReactiveCocoa这种双向数据绑定解决方案，确实是实现Reactive Programming所需要的。没有了数据绑定，整个开发流程的效率深知会降低到手动处理状态之下。绑定后开发者不需要再手动处理update的时机，只需要提前在view中定义一套映射，viewModel只需要处理Model的变化，也不需要管是否需要回调viewController的update情况了。\n\n# 明年的简单打算\n\n基本上，明年就是真正的毕业生和在职人员了。公司不会像学校那样随心所欲，估计到时候自由时间将会少了很多。技术方面，感觉自己在移动开发这条路上还是可以走下去的，只不自己重点想关注偏工程和中间层技术的领域，比如之前看的一些网络中间件，模型保护，日志监控之类。虽然之前发了一部分关于Core Animation的东西，但是发现UI这部分真的并不是特别感兴趣，自己的目标也就在能够完成基本的需求下和简单的绘图动画即可。\n\n还有的方面，新的一年要多接触接触领域圈子内和圈子外的人。老实说自己的交际能力还是非常欠缺的，无论是做移动的技术圈子，还是同学朋友的生活圈子，都需要更为关注。在学校能够只关心眼前事，但是到社会上是远远不够的。一个人的能力再强，处境再好，总比不上周围的朋友和同事的协力。\n\n就这样吧，2016将要过去，明年将是一个更新，也更加充满机遇的一年。","categories":["Life"],"tags":["工作"]},{"title":"20岁的生日，或许应有些感想","url":"/2016/03/29/20%E5%B2%81%E7%9A%84%E7%94%9F%E6%97%A5%EF%BC%8C%E6%88%96%E8%AE%B8%E5%BA%94%E6%9C%89%E4%BA%9B%E6%84%9F%E6%83%B3/","content":"\n首先，祝自己生日快乐，自己迎来了第20个春秋。\n\n20岁，意味着自己早已脱离了当年年少无知的懵懂，应该肩负起属于自己的责任，应当直面这纷杂世界的各式问题。在进入大学的一年里，感受最多的，便是人际关系的重要性、做事的担当性，并再一次认识到自己存在的关于个人性格方面的一些问题。\n\n我的性格第一次变化，是在初中的时候。小学的我比较单纯，认为学校同学就是一切，听老师的话（多么好的一个孩子呀……），个性也是羞涩而带点自卑。而到了初中，渐渐地开朗了起来，敢与老师争，能和同学扯。高中时期，或许更是如此吧，但是感觉经过高三（高考）的压榨之后，整个人开始多虑了起来，开始犹豫了起来，不再积极地去招呼他人，去帮助他人，遇到问题也总是自己处理。我现在也体会到了高考的一定负面影响。\n\n回到正题，大学一年过去了，我从一个初入校门的新生，如今也成为了他人口中的学长。大学第一年的开头，我是满怀着希望和热情，想改变自己，想证明自己。大一一年中，我加入了各种社团，并且也努力地学好课程（虽然成绩不是非常优异:-P）。大一上学期，各种活跃，与学长们关系也是挺不错的。\n\n下学期到了，我却渐渐冷却下来了。一方面是感到了学业压力的真实性，更重要的一方面，是自己对自己未来的一种迷茫。曾经的我，一直想着大学完继续读研，以保研为第一目标。但是之后看到许多学长的表现。周围的人，有的全力走ACM，有的人专注于接项目自己开发，而学校的课程安排又确实让我总觉得自己当年是选错了专业。（真的，有时候会这样想）。于是，整个人就有些迷茫了。\n\n这份迷茫也许还将伴随着我，毕竟，截止到现在，我仍然没有放弃去读研的念头。毕竟，我觉得自己并没有真正成熟到能够直接进入工作的地步，或许再等我一学期，我就会有了最终的决定了吧。\n\n也许，总体上说自己确实成长了一些，能够毫不胆怯地向陌生人搭话，能够积极地站在他人面前，能够主动参与活动而不是以前被动接受……但是，反思自己还是没有真正有一名作为成年人的自觉，责任意识不够，更少了一份与他人打交道，圆滑的能力（现在觉得，这份能力真的是非常重要，不是世故，而是真正社会上交流所需要的），在这后半学期之中，或许，我将慢慢地去向着更为成熟的自己去努力吧。\n\n好了，感想先到这里，给自己以目标，让自己前进，20岁，我应当开始了。\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/e/6a/4314fc89c9ec5554d88cb9526a533.jpg)","categories":["Life"],"tags":["感悟"]},{"title":"Autolayout小技巧","url":"/2016/03/30/Autolayout%E5%B0%8F%E6%8A%80%E5%B7%A7/","content":"\niOS开发UI一直是一个问题，当年用代码画UI一度成为流行趋势，相信代码能万能解决问题，而且十分简单。\n\n然而，现在由于iOS设备的不断迭代，市场上常见的iPhone设备就会有：\n\n1.  iPhone4/4S 960*640 (480*320 @2x)\n\n2.  iPhone5/5S 1136*640 (568*320 @2x)\n\n3.  iPhone6 1334\\*750(667\\*375 @2x)\n\n4.  iPhone6 Plus 1920\\*1080(736\\*414 @3x)->(2208*1242)\n\n加上iPad以后，还会有一个1024*768(@1x) 和 2048*1536(@2x) 原来想要做一个自适应的，同时支持iPhone和iPad的应用，就算用代码来画UI，也是十分简单的。而现在，在这总共3类，5种，7状态的iOS设备面前，就会有点力不从心了，更别说以后想要做WatchOS的开发就会遇到很多问题，而Autolayout的解决方法的提出大大简化了这一过程\n\n> Autolayout，就是通过一系列的约束条件来控制一个UIView在视图中的位置，同时还要配合Size Classes(兼容iOS8之后的设备)\n\n1、对于一个TableView，我们只需要设置它的Leading、Trailing、Top、Bottom临接到根View即可让它永远全屏显示，无论设备像素。而且，重要的一点，就是在Attribute Inspector中，要把这些距离设置为Standard（或者是0），这样才能在不同设备中获得推荐的显示效果（如果不是Standard或者0的话，就要小心了，这些就是所谓的魔法数字，很可能不同尺寸设备上显示效果会有所差别）\n\n2、对于有事想要使两个View沿着一条中线水平对齐在两侧，这个时候就需要一点点小技巧，比如说，你可以拿一个空的View放在中线上，设置Hidden，宽度为0，然后两边两个View跟这个空View对齐即可。同样的方法也很适合于想要调整两个View的比例，可以选中对应的约束条件，在multiplier中设置比例。\n\n3、有时候实在解决不了，就需要我们使用Size Classes来根据不同Size来设置了。默认的Size Classes是Any Any，对于iPhone来说，除了iPhone 6 Plus的横屏模式，其他情况下都是长宽紧凑的，所以很好设置，对iPhone 6 Plus如果想优化的话，就选择长正常宽紧凑的模式，然后单独设置。iPad由于都是长宽正常的，所以一般单独就做一个Size Classes就好。\n\n4、学会用Storyboard，传统的Xib固然很不错，但是Storyboard也可以作为很好的团队开发助力，不要把所有的视图放在一个Storyboard，可以一个Storyboard一两个视图，把逻辑相关的非常精简的视图放在一个Stoyboard中更能提供开发效率，而总是一个Xib一个Xib关联反而会很凌乱。","categories":["iOS"],"tags":["iOS"]},{"title":"CocoaPods的资源管理和Asset Catalog优化","url":"/2018/11/26/CocoaPods%E7%9A%84%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%92%8CAsset%20Catalog%E4%BC%98%E5%8C%96/","content":"\n> 这篇文章介绍了关于CocoaPods的资源管理行为，对于Pod库作者是必须了解的知识。同时介绍了CocoaPods使用Asset Catalog的注意事项。如果已经了解某方面知识，可以大致略过直接看结论。\n\n## Asset Catalog和App Thinning\n\nAsset Catalog，是Xcode提供的一项图片资源管理方式。每个Asset表示一个图片资源，但是可以对应一个或者多个实际PNG图，比如可以提供`@1x`, `@2x`, `@3x`多张尺寸的图以适配；在macOS上，还可以通过指定日间和夜间不同Appearances的两套图片。\n\n这种资源，在编译时会被压缩，然后在App运行时，可以通过API动态根据设备scale factor（Mac上日夜间设置）来选择对应的真实的图片渲染。\n\n[App Thinning](https://help.apple.com/xcode/mac/current/#/devbbdc5ce4f)，是苹果平台（iOS/tvOS/watchOS）上的一个用于优化App包下载资源大小的方案。在App包提交上传到App Store后，苹果后台服务器，会对不同的设备，根据设备的scale factor，重新把App包进行精简，这样不同设备从App Store下载需要的容量不同，3x设备不需要同时下载1x和2x的图。\n\n但是，这套机制直接基于Asset Catalog，换言之，只有在Asset Catalog中引入的图片，才可以利用这套App Thinning。直接拷贝到App Bundle中的散落图片，所有设备还是都会全部下载。因此如何尽量提升Asset Catalog利用率，是一个很大的包大小优化点。\n\n## CocoaPods的资源管理\n\nCocoaPods是一个构建工具，它完全基于Pods的spec文件规则，在Podfile引入后，生成对应构建Xcode Target。也就是它是一个声明式构建工具（区别于Makefile这种过程式的构建工具）。对于资源的管理，目前有两个方式进行声明并引入，即`resources`和`resource_bundles`，参考[podspec syntax](https://guides.cocoapods.org/syntax/podspec.html)\n\n虽然Podspec中包含所有待构建库的声明，但于CocoaPods也会根据Podfile的配置，动态调整最终的Xcode工程的配置，根据是否开启`use_framework!`，以下的资源声明最终的行为有所不同，这里分开介绍。\n\n### 不使用use_framework!\n\n当不使用use_framework!时，最终对Pod库，会创建单独的静态链接库`.a`的Target，然后CocoaPods会对主工程App Target增加自己写的脚本来帮助我们拷贝Pod的资源。\n\n+ `resources`字段\n\n对应参数是一个数组，里面可以使用类似`A/*.png`通配符匹配。所有匹配到的资源，如图片。\n\n在`pod install`完成后，CocoaPods会插入一个生成的脚本[CP] Copy Bundle Resource（注意，这并非Xcode本身构建过程），拷贝到编译完成后的App Main Bundle的根路径下。\n\n也就是说，如果匹配到了一个`A/1.png`和`A/2.plist`，这个`1.png`和`2.plist`，最终会出现在ipa包的展开根路径中。\n\n```\n| Info.plist\n| 1.png\n| 2.plist\n| News\n| xxx\n```\n\n优点：\n\n1. 最简单暴力，而且由于固定了资源的路径在根路径上，如果先前在主工程目录中使用的代码，不需要更改一行即可继续使用（原因是主工程的你拖一个图片文件夹，Xcode的构建过程默认就是把资源放到App Main Bundle的根路径上的）。\n\n缺点：\n\n1. 严重的命名冲突问题，由于通配符会拷贝所有文件到根路径，因此如果出现如下 `A/1.png, B/1.png`两个文件同时匹配（B是另一个库的文件夹），将会出现冲突，CocoaPods采取的方式是暴力合并，会有一个被替换掉。因此，这要求所有资源文件命名本身，加入特定的前缀以避免冲突。类似的不止是图片，所有资源如`bundle`, `js`, `css`都可能存在这个问题，难以排查。而且由于这种拷贝到根路径的机制，这个问题不可从根源避免。\n2. 无法享用任何Xcode的优化，Xcode对于所有内建的Copy Bundle Resource中添加的PNG/JPEG图片，会进行一次压缩减少大小（注意，这和App Thinning不一样）。而CocoaPods这种使用自己的Shell脚本暴力拷贝，源文件和Bundle的文件是完全一样的。\n\n+ `resource_bundles`字段\n \n对应参数是一个字典，里面的Key表示你所希望的一组资源的资源名，常见值是`库名+Resource`，Value是一个数组，里面和`resources`一样允许通配符匹配资源。\n\n当`pod install`完成后，CocoaPods会对所有的Pods中声明了`resource_bundles`资源，以Key为名称建立一个单独的Bundle Target，然后根据Value匹配的值，把这些图片资源全部加到这个Target的Xcode内建Copy Bundle Resource过程中。然后通过一个Shell脚本添加到App Main Bundle中。假设我们这样写 `'DemoLibResource' => [A/1.png, 'A/2.plist']`匹配到了一个`1.png`和`2.plist`，会是以这个Target建立一个Bundle父文件夹。然后这些Bundle父文件夹，拷贝到App Main Bundle根路径下，最后得到这样一个ipa结构。\n\n```\n| Info.plist\n| DemoLibResource.bundle\n|- 1.png\n|- 2.plist\n| News\n| xxx\n```\n\n优点：\n\n1. 解决了命名冲突问题，由于使用了一级的Key值，作为一个单独的父文件夹隔离，不同的Pods库不太可能出现命名冲突（遵守`库名+Resource`，则库之间不会不出现同样的Key值）。\n2. 能利用Xcode本身的优化过程，由于单独构建了一个Target，使用Xcode原生的Copy Bundle Resource过程，PNG图片等会自动享受压缩\n\n缺点：\n\n1. 由于最终资源产物增加了一级Resource Key的父文件夹，如果有先前依赖Main Bundle路径位置的加载代码，需要进行更新。典型的用法如`NSBundle.mainBundle pathForResource:ofType:`取本地Bundle中一个文件路径，这时候需要更新为`[NSBundle bundleWithPath:] pathForResource:ofType:`的代码调用。对于`UIImage imageNamed:`方法，它也支持Bundle，看情况需要更新。\n\n举例子说明，原来使用方式为:\n\n```objectivec\n// 直接访问路径\nNSString *plistPath = [NSBundle.mainBundle pathForResource:@\"test\" ofType:@\"plist\"];\n// 获取Bundle中的UIImage，只是示例，推荐使用Asset Catalog替代这种裸的图片引用\nUIImage *image = [UIImage imageNamed:@\"1\"];\n```\n\n现在需要更新为：\n\n```objectivec\n// 路径变化，这步骤可以封装库级别的工具方法，或者宏，Static对象，都行\n// 由于采取了Static Library而没有使用use_framework!，因此此时[NSBundle bundleForClass:]和mainBundle是相同的，原因是类其实在mainBundle的二进制中，而不是Framework中。但是为了代码统一，建议都使用bundleForClass:（后面讲）\n\n// NSString *bundlePath = [NSBundle.mainBundle.resourcePath stringByAppendingPathComponent:@\"DemoLibResource.bunbdle\"]; // 虽然也能Work，为了统一代码（开启use_framework!）用下面的更好\nNSString *bundlePath = [[NSBundle bundleForClass:DemoLib.class].resourcePath stringByAppendingPathComponent:@\"DemoLibResource.bunbdle\"];\nNSBundle *bundle = [NSBundle bundleWithPath:bundlePath];\n// 直接访问路径\nNSString *plistPath = [bundle pathForResource:@\"test\" ofType:@\"plist\"];\n// 获取Bundle中的UIImage，只是示例，推荐使用Asset Catalog替代这种裸的图片引用\nUIImage *image = [UIImage imageNamed:@\"1\" inBundle:bundle compatibleWithTraitCollection:nil];\n```\n\n总体来说，结合优缺点，大部分的组件库，对于通用资源的引用，应当避免使用`resources`，而转为使用`resource_bundles`声明。能够从源头上避免冲突。改动成本也不算大，封装个库内部的工具方法/宏替换下即可。\n\nTips：如果在使用`resource_bundles`的情况下，我还想避免Xcode的图片优化策略（如无损的图片等），这时候可以采取将图片放入一个自己建立的Bundle文件夹中，然后`resource_bundles`引入这个Bundle本身，注意路径需要再加一层。\n\n## 使用use_framework!\n\n当使用了use_framework!之后，CocoaPods会对每个Pod单独建立一个动态链接库的Target，每个Pod最后会直接以Framework集成到App中。而资源方面，由于Framework本身就能承载资源，所有的资源都会被拷贝到Framework文件夹中而不再使用单独的脚本处理。\n\n+ `resources`\n\n在使用`resources`声明时，同不使用use_framework!相比，改动的点在于这些Pod库资源的路径。此时，这些Pod库资源会被拷贝到Pod库自己的Fraemwork根路径下，而不在App Main Bundle的根路径下。\n\n```\n| Info.plist\n| Frameworks\n|- DemoLib.framework\n|-- 1.png\n|-- 2.plist\n| News\n| xxx\n```\n\n优点：\n\n1. 虽然在不使用use_framework!的情况下，这种声明会造成命名冲突。但是在使用use_framework!的情况下，由于资源本身被拷贝到Framework中，已经能最大程度减少冲突，因此这时候一般不需要考虑名称冲突问题\n\n缺点：\n\n1. 在use_framework!的情况下，能够保证代码一行不改，但是使用use_framework!后就不行了。原因在于此时Bundle资源路径已经发生变化，到Framework自身的文件夹中而不是App Main Bundle中，需要进行更新。这个更新的路径和`resource_bundles`不同，不需要额外拼接一层Key值的名称。直接使用bundleForClass即可，比较简单\n\n```objectivec\n// 使用bundleforClass替代mainBundle即可\nNSBundle *bundle = [NSBundle bundleForClass:DemoLib.class];\n// 直接访问路径\nNSString *plistPath = [bundle pathForResource:@\"test\" ofType:@\"plist\"];\n// 获取Bundle中的UIImage，只是示例，推荐使用Asset Catalog替代这种裸的图片引用\nUIImage *image = [UIImage imageNamed:@\"1\" inBundle:bundle compatibleWithTraitCollection:nil];\n```\n\n+ `resource_bundles`\n\n在使用`resource_bundles`声明时，同不使用use_framework!相比，改动的点在于对应这些Key生成的Bundle的位置。此时，这些生成的Bundle父文件夹，会放入Pod库自己的Framework的根路径下。而每个Pod库Framework本身，在App Main Bundle的`Frameworks`文件夹下。\n\n```\n| Info.plist\n| Frameworks\n|- DemoLib.framework\n|-- DemoLibResource.bundle\n|--- 1.png\n|--- 2.plist\n| News\n| xxx\n```\n\n优点：同上\n缺点：同上。但有点区别，在于\u0010Bundle的路径变化。此时，`NSBundle bundleForClass:`不再等价于mainBundle了，因此对应代码更新示例里面，一定不能用mainBundle而要用bundleForClass替代。传入的Class是哪一个Pod库的Class，就会取到对应Pod库Framework里面的Bundle文件夹。\n\n```objectivec\n// 再抄一遍，害怕忘记了，此时不能用mainBundle的resourcePath去拼接\nNSString *bundlePath = [[NSBundle bundleForClass:DemoLib.class].resourcePath stringByAppendingPathComponent:@\"DemoLibResource.bunbdle\"];\nNSBundle *bundle = [NSBundle bundleWithPath:bundlePath];\n```\n\n## CocoaPods与Asset Catalog图片资源\n\n前面花了大篇章说了关于CocoaPods处理通用的资源引用的方式，是为了业务库作者能有清晰认识到，在从主工程沉库代码后，需要怎么样更改来处理资源。\n\n现在回到正题说一下Pod库中的Assets Catalog需要怎么样处理以利用App Thinning。Assets Catalog的好处都有啥已经说过了，因此我们需要尽量保证大部分情况下优先使用Assets Catalog而非将图片拷贝至App Bunlde中（虽然Xcode会压缩优化，但是这种方式无论如何都无法利用App Thinning）。\n\nAssets Catalog本身的文件夹`xcassets`一定不会出现在最终的App包中，它在编译时会产生一个二进制产物`Assets.car`，而这个二进制目前只能由UIKit的方法，去读取产生一个UIImage内存对象，其他代码无法直接访问原始的图片文件路径和ImageData。同时，按照官方文档的说明，[UIImage imageNamed:inBundle:compatibleWithTraitCollection:](https://developer.apple.com/documentation/uikit/uiimage/1624154-imagenamed?language=objc) 实际上，会优先去查找指定Bundle（`UIImage imageNamed:`即为mainBundle）的路径下的`Assets.car`文件并展开，然后找不到再去寻找Bundle路径下同名的图片文件。所以，从API使用上来看，一个图片具体是在散落在Bundle根路径下，还是在被编译到Bundle路径下的`Assets.car`中，代码应该是一致的。\n\n值得说明的是，CocoaPods不会自动根据你在Spec中的声明，创建Asset Catalog，你必须通过Xcode手动创建，添加，然后在Spec中引入它。类似这样。\n\n```ruby\nspec.resources = ['A/DemoLib.xcassets']\n```\n\n有了这些知识，我们就结合前面的CocoaPods资源处理策略，以及UIKit的行为，再来回顾上述这些声明的行为，以及我们应该怎么样从代码上去使用。\n\n下面的例子统一都以上面这个示例举例子，假设这个Asset Catalog中含有`1.png`, `1@2x.png`, `1@3x.png`.\n\n### 不使用use_framework!\n\n+ `resources`\n\n不同于普通资源那种暴力拷贝的方式，CocoaPods这下没法暴力拷贝这个编译产物的`Assets.car`到根路径了，因为它会直接覆盖掉App本身的编译产物。所以，CocoaPods采取的方案，是合并Asset Catalog。首先会编译得到工程App的`Assets.car`，然后通过便利所有Pod的`resources`引入的`xcassets`，使用atool工具进行多个Asset Catalog合并，最后输出到App Main Bundle根路径下的`Asset.car`里。\n\n```\n| Info.plist\n| Assets.car (编译进去了1.png）\n| News\n| xxx\n```\n\n优点：\n\n1. 继承了普通资源的处理方式，由于采取了Asset Catalog合并，原来主工程代码不需要更改一行可继续使用。相当于库的Assets Catalog资源直接添加到主工程Assets Catalog中\n\n缺点：\n\n1. 一贯的命名冲突问题，由于Asset Catalog还会和主工程以及其他Pod库进行合并，一旦出现了重名的资源，最终编译产物`Assets.car`会根据合并顺序替换掉之前的。因此还是得每个Asset Catalog中资源名也得添加前缀\n\n+ `resource_bundles`\n\n类似对于普通资源的处理，如果使用`resource_bundles`，对于每个Key生成的Bundle父文件夹，会把生成的`Assets.car`拷贝到这个Bundle父文件夹中。如果当前Pod库引用了多个xcasset文件，对引用的这几个做合并。\n\n```\n| Info.plist\n| DemoLibResource.bundle\n|- Assets.car（含有1.png）\n| News\n| xxx\n```\n\n优点：同普通资源\n缺点：同普通资源。代码使用方面，由于之前提到的UIImage API，对于同路径下的`Assets.car`编译产物，和散落的普通图片名，代码使用方式是一致的，因此这里也没有额外的变化。\n\n### 使用use_framework!\n\n+ `resources`\n\n在使用use_framework!的情况下，对应编译产物`Assets.car`会被拷贝到Pod库Framework的根路径下，其他的行为类似。\n\n```\n| Info.plist\n| Frameworks\n|- DemoLib.framework\n|-- Assets.car\n| News\n| xxx\n```\n\n优点：同普通资源\n缺点：同普通资源，代码使用方面也同普通资源的情形\n\n+ `resource_bundles`\n\n在使用use_framework!的情况下，也会创建Key为名称的父Bundle文件夹，拷贝到Pod库Framework根路径下，然后对应编译产物`Assets.car`放到了这个自动生成Bundle文件夹下，其他行为类似。\n\n```\n| Info.plist\n| Frameworks\n|- DemoLib.framework\n|-- DemoLibResource.bundle\n|--- Assets.car\n| News\n| xxx\n```\n\n优点：同普通资源\n缺点：同普通资源，代码使用方面也同普通资源的情形\n\n## 最佳实践和总结\n\n可以看出，CocoaPods，对待普通资源和Asset Catalog都支持，唯一的行为不同的点，在于普通资源如果发生重名，不会进行合并而是直接替换。但是Asset Catalog如果出现多个引用，会进行合并。\n\n虽然表面看起来，我们分析了总共会有 **使用resource还是resource_bundle** * **是否使用use_framework!** * **普通资源还是Asset Catalog**，8种情形。但是实际上从世纪代码使用上，由于Asset Catalog和普通图片API可以统一，同时动态/静态的Bundle位置也可以统一处理，实际上只有两种Case：\n\n\n### 使用resource_bundle：推荐，避免命名冲突\n\n推荐做法，对于每个需要引入资源的库，以`库名+Resource`为Key（不强制，推荐），然后引入资源，Asset Catalog。代码必须更新，以使用对应的Bundle名来获取。参考上面的代码：\n\n```objectivec\nNSString *bundlePath = [[NSBundle bundleForClass:DemoLib.class].resourcePath stringByAppendingPathComponent:@\"DemoLibResource.bunbdle\"];\nNSBundle *bundle = [NSBundle bundleWithPath:bundlePath];\n```\n\n### 使用resource：不推荐，因为会导致命名冲突。\n\n除非你能保证分所有资源都已加入前缀，而且目前代码不好更改的情况下，可以保持继续使用主工程的直接访问mainBundle的代码；其他的任何情况，使用`NSBundle bundleForClass:`来获取Bundle，然后加载路径，或者使用`UIImage imageNamed:inBundle:compatibleWithTraitCollection`加载图片。\n\n```objectivec\nNSBundle *bundle = [NSBundle bundleForClass:DemoLib.class];\n```\n\n对于Pod库开发者，需要尽量使用`resource_bundle`来处理资源，同时，Pod自身代码可能需要更新，以使用正确的方式加载图片或者其他Bundle资源。并且，对于图片资源，如果无特殊用处，建议都建立Asset Catalog以利用App Thinning。\n\n","categories":["iOS"],"tags":["iOS","CocoaPods"]},{"title":"CocoaPods资源管理—Data Asset最低部署版本的坑","url":"/2021/07/16/CocoaPods%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E2%80%94Data-Asset%E6%9C%80%E4%BD%8E%E9%83%A8%E7%BD%B2%E7%89%88%E6%9C%AC%E7%9A%84%E5%9D%91/","content":"\n# 背景\n\n自己很早之前曾经写过一些CocoaPods管理Resource资源的文章：[CocoaPods的资源管理和Asset Catalog优化](https://bytedance.feishu.cn/wiki/wikcnJUiDWMmCbkSnfFvYpcMT0f) ，当时列举了对普通图片类型的管理方式和一些用法，也普及了一下UIImage获取Bundle去加载不在mainBundle图像的方式。\n\n但是苹果早在iOS 9，Xcode 7时代，苹果就已经推出了Data Asset的概念，并在随后的Xcode，尤其是Xcode 10中，为Data Asset提供了App Slicing的能力（即App Store提审包会根据选择的不同设备/内存/分辨率/GPU/CPU，最终下载到唯一匹配的一份文件），这个功能渐渐地开始被一些国内开发者使用。\n\n在NSHipster这里，有一篇专门的文章介绍：《[NSDataAsset](https://nshipster.cn/nsdataasset/)》\n\n不过，这篇文章主要的内容是，最近有同事踩到一个关于Data Asset和最低部署版本的坑，这里单独列举一下以防后人重复踩坑。\n\n# Data Asset初见\n\n标准的配置下，我们可以直接在Xcode里创建一个Asset Catalog，然后拖入想要的文件。注意我们可以在右侧针对不同的配置设置不同的文件内容。\n\n![1625559957403_29bd9b59c2bbaa1f363122a8276779b6](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2021-07-16/image/1625559957403_29bd9b59c2bbaa1f363122a8276779b6.png)\n\n最终一个Data Asset的输入大概的形式是这样子的：\n\n```\nImage.xcassets\n\n- A.dataset\n\n-- Contents.json\n\n-- 1.zip\n\n-- 2.webp\n```\n\n可以看到除了后缀名以外，其他的结构和普通的imageset保持一致。\n\n# Data Asset产物\n\n在执行Xcode标准的`Copy Bundle Resources`的Build Phase之后，可以看到我们的Data Asset会被编译为一个Assets.car文件，这个格式也是老熟人了。\n\n![1625559957281_7b787078bbae747abaf28cde1a513955](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2021-07-16/image/1625559957281_7b787078bbae747abaf28cde1a513955.png)\n\n# Data Asset获取代码\n\n类似于图像，由于Data Asset最终会编译到Car中，无法直接获取文件路径（Flutter/H5等跨平台库又需要使用Bridge方案来调用Native接口）\n\n在运行时，我们需要使用Fondation提供的专门类[NSDataAsset](https://developer.apple.com/documentation/uikit/nsdataasset?language=objc)相关接口，来获取真正的NSData，接口比较简单直观：\n\n```\n/** 如果是非Main Bundle，要获取Bundle\n\nNSString *bundlePath = [[NSBundle bundleForClass:self.class].resourcePath stringByAppendingPathComponent:@\"A.bundle\"];\n\nNSBundle *bundle = [NSBundle bundleWithPath:bundlePath];\n\n*/\n\nNSBundle *bundle = [NSBundle mainBundle];\n\nNSDataAsset *asset = [[NSDataAsset alloc] initWithName:@\"TestImageAnimated\" bundle:bundle];\n\nNSData *data = asset.data;\n```\n\n看起来比UIImage的相关接口简单理解多了，对吧。\n\n# 坑-最低部署版本影响行为\n\n然而最近有同事发现，他们的一个SDK，使用了Data Asset，在不同的宿主App中行为不一致。某个宿主中可以能访问到数据，另一个一直访问不到。前来咨询（？）了我，因此做了一番排查，发现了一个坑：\n\n**先说结论：Data Asset的编译单元，在最低部署版本iOS 9以下时，不会产出Asset.car而是直接拷贝了文件到原Bundle路径下；只有iOS 9及以上才会产出Asset.car**\n\n如图，这是SDK的资源。SDK使用了CocoaPods进行托管，Podspec里面使用了`resource_bundles`来提供对外的资源。这里的Data Asset里面内容是一个WebP文件。\n\n![1625559957352_30cb4a561799eec3da92fa1c607c101e](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2021-07-16/image/1625559957352_30cb4a561799eec3da92fa1c607c101e.png)\n\n\n```\ns.ios.deployment_target = \"8.0\"\n\ns.subspec 'Core' do |ss|\n\n  ss.resource_bundle     =  {'splashResourceCore' => ['TTAdSplashSDK/Assets/splashResource/CoreImage.xcassets', 'TTAdSplashSDK/Assets/splashResource/ShakeMusic.mp3']}\n\nend\n```\n\n看起来非常正常，但是实际上行为就是有所不同。于是简单开始从源头排查差异。\n\n## 宿主A\n\n我们搜索查看Xcode最终编译的命令。负责编译xcassets的命令是actool。我们可以看到，在`com.apple.actool.compilation-results`这里有打印所有的输出，是符合预期的。\n\n```\nCompileAssetCatalog /Users/bytedance/Library/Developer/Xcode/DerivedData/TTAdSplashSDK-bouxjwktwlrwfthejbcmzvcqddie/Build/Products/Debug-iphonesimulator/TTAdSplashSDK-Core-Interactive-Privacy/splashResourceCore.bundle /Users/bytedance/TTiOS/subs/tt_splash_sdk/TTAdSplashSDK/Assets/splashResource/CoreImage.xcassets (in target 'TTAdSplashSDK-Core-Interactive-Privacy-splashResourceCore' from project 'TTAdSplashSDK')\n\n    cd /Users/bytedance/TTiOS/subs/tt_splash_sdk/Example/Pods\n\n    /Applications/Xcode.app/Contents/Developer/usr/bin/actool --output-format human-readable-text --notices --warnings --export-dependency-info /Users/bytedance/Library/Developer/Xcode/DerivedData/TTAdSplashSDK-bouxjwktwlrwfthejbcmzvcqddie/Build/Intermediates.noindex/TTAdSplashSDK.build/Debug-iphonesimulator/TTAdSplashSDK-Core-Interactive-Privacy-splashResourceCore.build/assetcatalog_dependencies --output-partial-info-plist /Users/bytedance/Library/Developer/Xcode/DerivedData/TTAdSplashSDK-bouxjwktwlrwfthejbcmzvcqddie/Build/Intermediates.noindex/TTAdSplashSDK.build/Debug-iphonesimulator/TTAdSplashSDK-Core-Interactive-Privacy-splashResourceCore.build/assetcatalog_generated_info.plist --compress-pngs --enable-on-demand-resources NO --optimization space --filter-for-device-model iPhone13,2 --filter-for-device-os-version 14.5 --development-region en --target-device iphone --target-device ipad --minimum-deployment-target 10.0 --platform iphonesimulator --compile /Users/bytedance/Library/Developer/Xcode/DerivedData/TTAdSplashSDK-bouxjwktwlrwfthejbcmzvcqddie/Build/Products/Debug-iphonesimulator/TTAdSplashSDK-Core-Interactive-Privacy/splashResourceCore.bundle /Users/bytedance/TTiOS/subs/tt_splash_sdk/TTAdSplashSDK/Assets/splashResource/CoreImage.xcassets\n\n    \n\n/* com.apple.actool.compilation-results */\n\n/Users/bytedance/Library/Developer/Xcode/DerivedData/TTAdSplashSDK-bouxjwktwlrwfthejbcmzvcqddie/Build/Intermediates.noindex/TTAdSplashSDK.build/Debug-iphonesimulator/TTAdSplashSDK-Core-Interactive-Privacy-splashResourceCore.build/assetcatalog_generated_info.plist\n\n/Users/bytedance/Library/Developer/Xcode/DerivedData/TTAdSplashSDK-bouxjwktwlrwfthejbcmzvcqddie/Build/Products/Debug-iphonesimulator/TTAdSplashSDK-Core-Interactive-Privacy/splashResourceCore.bundle/Assets.car\n```\n\n检索产物Assets.car，也符合预期：\n\n![1625559957323_ceced1da15007185b48893a6eda48754](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2021-07-16/image/1625559957323_ceced1da15007185b48893a6eda48754.png)\n\n## 宿主B\n\n同样的，我们查看编译命令：\n\n```\nCompileAssetCatalog /Users/bytedance/Library/Developer/Xcode/DerivedData/TTAdSplashSDK-bouxjwktwlrwfthejbcmzvcqddie/Build/Products/Debug-iphonesimulator/TTAdSplashSDK-Core-Interactive-Privacy/splashResourceCore.bundle /Users/bytedance/TTiOS/subs/tt_splash_sdk/TTAdSplashSDK/Assets/splashResource/CoreImage.xcassets (in target 'TTAdSplashSDK-Core-Interactive-Privacy-splashResourceCore' from project 'TTAdSplashSDK')\n\n    cd /Users/bytedance/TTiOS/subs/tt_splash_sdk/Example/Pods\n\n    /Applications/Xcode.app/Contents/Developer/usr/bin/actool --output-format human-readable-text --notices --warnings --export-dependency-info /Users/bytedance/Library/Developer/Xcode/DerivedData/TTAdSplashSDK-bouxjwktwlrwfthejbcmzvcqddie/Build/Intermediates.noindex/TTAdSplashSDK.build/Debug-iphonesimulator/TTAdSplashSDK-Core-Interactive-Privacy-splashResourceCore.build/assetcatalog_dependencies --output-partial-info-plist /Users/bytedance/Library/Developer/Xcode/DerivedData/TTAdSplashSDK-bouxjwktwlrwfthejbcmzvcqddie/Build/Intermediates.noindex/TTAdSplashSDK.build/Debug-iphonesimulator/TTAdSplashSDK-Core-Interactive-Privacy-splashResourceCore.build/assetcatalog_generated_info.plist --compress-pngs --enable-on-demand-resources NO --optimization space --filter-for-device-model iPhone13,2 --filter-for-device-os-version 14.5 --development-region en --target-device iphone --target-device ipad --minimum-deployment-target 8.0 --platform iphonesimulator --compile /Users/bytedance/Library/Developer/Xcode/DerivedData/TTAdSplashSDK-bouxjwktwlrwfthejbcmzvcqddie/Build/Products/Debug-iphonesimulator/TTAdSplashSDK-Core-Interactive-Privacy/splashResourceCore.bundle /Users/bytedance/TTiOS/subs/tt_splash_sdk/TTAdSplashSDK/Assets/splashResource/CoreImage.xcassets\n\n\n\n/* com.apple.actool.compilation-results */\n\n/Users/bytedance/Library/Developer/Xcode/DerivedData/TTAdSplashSDK-bouxjwktwlrwfthejbcmzvcqddie/Build/Intermediates.noindex/TTAdSplashSDK.build/Debug-iphonesimulator/TTAdSplashSDK-Core-Interactive-Privacy-splashResourceCore.build/assetcatalog_generated_info.plist\n\n/Users/bytedance/Library/Developer/Xcode/DerivedData/TTAdSplashSDK-bouxjwktwlrwfthejbcmzvcqddie/Build/Products/Debug-iphonesimulator/TTAdSplashSDK-Core-Interactive-Privacy/splashResourceCore.bundle/Assets.car\n\n/Users/bytedance/Library/Developer/Xcode/DerivedData/TTAdSplashSDK-bouxjwktwlrwfthejbcmzvcqddie/Build/Products/Debug-iphonesimulator/TTAdSplashSDK-Core-Interactive-Privacy/splashResourceCore.bundle/ad_btn_hand.webp\n\n/Users/bytedance/Library/Developer/Xcode/DerivedData/TTAdSplashSDK-bouxjwktwlrwfthejbcmzvcqddie/Build/Products/Debug-iphonesimulator/TTAdSplashSDK-Core-Interactive-Privacy/splashResourceCore.bundle/ad_btn_triangle.webp\n```\n\n此时，在actool的编译结果中，我们发现，原本预期应该在Data Asset的`ad_btn_hand.webp`和`ad_btn_triangle.webp`两个文件，竟然直接拷贝到了.bundle的根路径，而不是Assets.car中！\n\n![1625559957272_fa17b69e9dd37090291bc0a6952baa38](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2021-07-16/image/1625559957272_fa17b69e9dd37090291bc0a6952baa38.png)\n\n对比两者的命令，只有`--minimum-deployment-target`这一项有差距，宿主A是iOS 10.0，宿主B是iOS 8.0。\n\n经过再次Demo验证，确定了是这个导致了行为的差异！\n\n## SDK调用代码\n\nSDK运行时需要获取这些代码，经过查看，这里的代码是假设按照.bundle根路径存在Data Asset的文件名的方式去取的，因此在宿主A中会出现异常：\n\n```\n// 伪代码\n\nNSString *bundlePath = [[NSBundle bundleForClass:TTAdSplashManager.class].resourcePath stringByAppendingPathComponent:@\"splashResourceCore.bundle\"];\n\nNSbundle* bundle = [NSBundle bundleWithPath:bundlePath];\n\n\n\nNSString *trianglePath = [bundle.resourcePath stringByAppendingPathComponent:@\"ad_btn_triangle.webp\"];\n\nNSData *triangleData = [NSData dataWithContentsOfFile:trianglePath];\n\nself.imageView.image = [UIImage imageWithData:triangleData];\n```\n\n## 进一步排查最低部署版本变化\n\n本质原因了解清楚后，进一步排查这个疑问：\n\n> 为什么宿主A和宿主B，对于一个SDK的Pod，最低部署版本不一致？\n\n因为SDK的Podspec的最低部署版本已经指明了iOS 8，按理说在哪个宿主集成都应该走的是路径的逻辑，而不应该受限于宿主iOS App自己的编译最低部署版本。\n\n查看宿主A，发现宿主A使用了CocoaPods的插件，在Pod Project Generate的时候，强制修改了所有Pod，伪代码如下：\n\n```\nall_targets.each do |target|\n\n  target.set_build_settings('IPHONEOS_DEPLOYMENT_TARGET') do |_, old|\n\n    old.to_f < 10.0 ? '10.0' : old\n\n  end\n\n  target.set_build_settings('ASSETCATALOG_COMPILER_OPTIMIZATION') do |_, old|\n\n    definitions = 'space'\n\n    definitions\n\n  end\n\nend\n```\n\n导致SDK的编译Assets.car时，`--minimum-deployment-target`传入了iOS 10.0，Data Asset编译到Assets.car里\n\n而宿主B，并没有这个逻辑，按照iOS 8.0传入，Data Asset散落在Bundle根路径。\n\n# 结论\n\n从这个坑可以看到，最低部署版本，这个编译配置，设置时需要谨慎。由于iOS App不会针对不同的部署版本，单独打一份独立的ipa包（类似PC等平台），所以很多工具链对针对最低部署版本，有着可能不同的兼容性行为，iOS系统快速迭代的节奏下尤其是这样。\n\n这里有两个改进方案：\n\n1.  对于宿主，除非你清楚知道改变最低部署版本的副作用，否则要慎重处理外部Pod的最低部署版本，建议在修改后进行一定的回归测试，或者针对白名单来进行修改。\n1.  对于SDK作者，如果没有用到Data Asset的特性（App Slicing），可以考虑直接不用Data Asset而直接放到Bundle中，省去踩坑的问题。如果需要利用Data Asset，并且你无法保证引入方宿主会对你的Pod做额外的修改，可以考虑这种兼容代码来判断：\n\n```\nNSString *bundlePath = [[NSBundle bundleForClass:self.class].resourcePath stringByAppendingPathComponent:@\"Image.bundle\"];\n\nNSBundle *bundle = [NSBundle bundleWithPath:bundlePath];\n\n// 如果编译时的最低部署版本iOS 9以上，Data Asset需要用NSDataAsset类获取，否则用直接取路径\n\nNSDataAsset *asset = [[NSDataAsset alloc] initWithName:@\"TestImageAnimated\" bundle:bundle]; // 此处是Asset名，不是文件名！\n\nNSData *data = asset.data;\n\nif (!data) {\n\n    // Fallback到路径\n\n    data = [NSData dataWithContentsOfFile:[bundlePath stringByAppendingPathComponent:\"TestImageAnimated.webp\"]]; // 此处是文件名，注意！\n\n}\n```","categories":["iOS"],"tags":["iOS","CocoaPods"]},{"title":"Core Animation 3D仿射变换知识","url":"/2016/11/01/Core-Animation-3D%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2%E7%9F%A5%E8%AF%86/","content":"\n# Core Animation 3D 仿射变换知识\n\n> 之前写的Core Graphics是2D平面上的坐标变换，而iOS开发中，为了实现复杂的动画效果，视图切换效果，会用到很多3D变换，这就是Core Animation提供的CATransform3D，其中大部分API都和2D情况类似，但这里需要详细解释一下透视投影这个概念，和m34这个值的真实来源，一些博客抄来抄去却没有点到点子上，让人看不下去……\n\n# 变换矩阵\n\n```objectivec\ntypedef struct CATransform3D {\n  CGFloat m11, m12, m13, m14;\n  CGFloat m21, m22, m23, m24;\n  CGFloat m31, m32, m33, m34;\n  CGFloat m41, m42, m43, m44;\n} CATransform3D;\n```\n\n这个结构体对应的是这样一个4x4的变换矩阵：\n\n$ \\begin{bmatrix} m11 & m12 & m13 & m14 \\\\\\ m21 & m22 & m23 & m24 \\\\\\ m31 & m32 & m33 & m34 \\\\\\ m41 & m42 & m43 & m44 \\end{bmatrix} $\n\n矩阵定义的顺序和结构体一致，先行后列（注意，那个《Core Animation Advanced Techniques》矩阵的图是错误的，行列画反了），则对应的矩阵乘法为\n\n$ \\begin{bmatrix} x & y & z & 1 \\end{bmatrix} \\times \\begin{bmatrix} m11 & m12 & m13 & m14 \\\\\\ m21 & m22 & m23 & m24 \\\\\\ m31 & m32 & m33 & m34 \\\\\\ m41 & m42 & m43 & m44 \\end{bmatrix} = \\\\\\ \\begin{bmatrix} m11x+m21y+m31z+m41 & m12x+m22y+m32z+m42 & m13x+m23y+m33z+m43 & m14+m24+m34+m44 \\end{bmatrix} $\n\n注意：\n\n* 这里定义的向量最后一位表示齐次向量元素，如果不为1，需要再化为齐次坐标（通常情况可以取m14,m24,m34,m44为0,0,0,1），对应真正的x,y,z坐标\n\n$ \\begin{bmatrix} \\frac{m11x+m21y+m31z+m41}{m14+m24+m34+m44} & \\frac{m12x+m22y+m32z+m42}{m14+m24+m34+m44} & \\frac{m13x+m23y+m33z+m43}{m14+m24+m34+m44} \\end{bmatrix} $\n\n* iOS设备上，是按照左手系的三维空间，即正面面对设备屏幕，坐标原点从屏幕左上方起，x轴指向右方，y轴指向下方，z轴为屏幕指向眼球。而macOS上是右手系，原点是屏幕左下角，x轴指向右方，y轴指向上方（相反），z轴同样为屏幕指向眼球，要注意\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/0/07/5c010c6b630ab7aa0892428016d7e.jpeg)\n\n# 平移\n\n类似二维空间的平移，变换矩阵第四行的m41,m42,m43对应的就是x、y、z的平移量，因此矩阵变换很简单，比如将[x,y]向量平移到[x+a,y+b,z+c]：\n\n平移矩阵：\n$ \\begin{bmatrix} x & y & z & 1 \\end{bmatrix} \\times \\begin{bmatrix} 1 & 0 & 0 & 0 \\\\\\ 0 & 1 & 0 & 0 \\\\\\ 0 & 0 & 1 & 0 \\\\\\ a & b & c & 1 \\end{bmatrix} = \\begin{bmatrix} x+a & y+b & z+c & 1 \\end{bmatrix} $\n\n对应构造API：\n\n```objectivec\nCATransform3D CATransform3DMakeTranslation(CGFloat tx, CGFloat ty, CGFloat tz);\n```\n\n# 缩放\n\n同二维空间的缩放，我们需要对向量坐标乘以系数，那么构造出来一个对角矩阵即可\n\n缩放矩阵：\n\n$ \\begin{bmatrix} x & y & z & 1 \\end{bmatrix} \\times \\begin{bmatrix} a & 0 & 0 & 0 \\\\\\ 0 & a & 0 & 0 \\\\\\ 0 & 0 & a & 0 \\\\\\ 0 & 0 & 0 & 1 \\end{bmatrix} = \\begin{bmatrix} ax & ay & az & 1 \\end{bmatrix} $\n\n对应的构造API：\n\n```objectivec\nCATransform3D CATransform3DMakeScale(CGFloat sx, CGFloat sy, CGFloat sz);\n```\n\n# 旋转\n\n参考二维的旋转，二维的旋转我们讨论的是某个layer，以它自身的anchorPoint为原点，通过顺时针逆时针的旋转。但是对于三维来说旋转就麻烦了，因为向量不会仅仅在XoY平面上。虽然实际上可以定义绕任意轴旋转，但是一般我们只研究绕三个坐标轴（x,y,z）的旋转。其中，对于绕z轴的旋转，可以看作等价于二维的旋转（XoY平面内），但绕x和绕y就超出了屏幕\n\n对于绕坐标轴，我们可以把对应旋转平面的投影看成二维的情况，因此前面推导过的旋转矩阵同样适用于三维绕轴情况，只需要针对不同坐标轴选定不同的坐标罢了，即通过把前一篇推导方程替换x，y，z变量得到：\n\n$ \\begin{cases} x^{'} = x \\cos \\theta - y \\sin \\theta \\\\\\ y^{'} = y \\cos \\theta + x \\sin \\theta \\\\\\ z^{'} = z \\end{cases} $\n\n绕x轴的旋转矩阵（固定x，从y旋转到z，即用y替换x，z替换y，x替换z）：\n\n$ \\begin{bmatrix} x & y & z & 1 \\end{bmatrix} \\times \\begin{bmatrix} 1 & 0 & 0 & 0 \\\\\\ 0 & \\cos \\theta & \\sin \\theta & 0 \\\\\\ 0 & - \\sin \\theta & \\cos \\theta & 0 \\\\\\ 0 & 0 & 0 & 1 \\end{bmatrix} = \\begin{bmatrix} x & y \\cos \\theta - z \\sin \\theta & z \\cos \\theta + y \\sin \\theta& 1 \\end{bmatrix} $\n\n绕y轴的旋转矩阵（固定y，从z旋转到x，即用z替换x，x替换y，y替换z）：\n\n$ \\begin{bmatrix} x & y & z & 1 \\end{bmatrix} \\times \\begin{bmatrix} \\cos \\theta & 0 & - \\sin \\theta & 0 \\\\\\ 0 & 1 & 0 & 0 \\\\\\ \\sin \\theta & 0 & \\cos \\theta & 0 \\\\\\ 0 & 0 & 0 & 1 \\end{bmatrix} = \\begin{bmatrix} x \\cos \\theta + z \\sin \\theta & y & z \\cos \\theta - x \\sin \\theta & 1 \\end{bmatrix} $\n\n对应API：\n\n```objectivec\nCATransform3D CATransform3DMakeRotation(CGFloat radians, CGFloat x, CGFloat y, CGFloat z);\n```\n\n注意：这个API中，radians是弧度不用说，x,y,z分别介于[-1,1]之间，表示一个任意的单位向量（[x,y,z]的长度是1，比如设置[1,0,0]就指的是绕x轴正方向旋转对应弧度值，前面解释过iOS和macOS的正/负弧度对应顺/逆时针了）\n\n# 错切\n\n类似二维的情况，比如对z轴依赖不变，x和y线性变换，那么对应的就是m12和m21，也是没有专门的API，用`CATransform3DIdentity `便携初始化结构体创建一个吧，设置对应的矩阵值即可\n\n错切矩阵：\n\n$ \\begin{bmatrix} x & y & z & 1 \\end{bmatrix} \\times \\begin{bmatrix} 1 & m21 & 0 & 0 \\\\\\ m12 & 1 & 0 & 0 \\\\\\ 0 & 0 & 1 & 0 \\\\\\ 0 & 0 & 0 & 1 \\end{bmatrix} = \\begin{bmatrix} x+m12y & m21x+y & z & 1 \\end{bmatrix} $\n\n手动构造API：\n\n```objectivec\n//The identity transform: [1 0 0 0; 0 1 0 0; 0 0 1 0; 0 0 0 1]\nCATransform3DIdentity transform = CATransform3DIdentity;\ntransform.m12 = 1.0;\ntransform.m21 = 1.0;\n```\n\n# 透视投影\n\n实际中你如果直接使用旋转，会注意到旋转前后，结果看起来竟然和普通的缩放一模一样，这是为什么呢？原因其实很简单，假如绕y轴旋转，空间中的图层虽然旋转了，但是显示到XoY平面（也就是iPhone的屏幕上）的时候，会把3D的物体进行正投影，这样子看上去就像是左右压缩一样\n\n而学过绘画的都知道人的视野并不是平行的，而是有一个透视图的概念，眼睛前有实际平行的两条线段发出（相当于z轴方向的向量），人眼看起来会相交于一点上（焦点，Focal point），这才产生了3D感\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/7/a9/a7ed0efe4aebcddaef0d090c631b4.jpeg)\n\n而对于变换矩阵，如果要实现透视投影，应该怎么办？这里就用到了前面介绍过但一直忽略的值`m34`\n\n## 原理和推导：\n为什么单单修改一个`m34`的值，就能达到这种透视3D的效果呢？我简单看了很多类似的博客都没有正面回答这个问题，其实这是变换矩阵的透视投影结论，可以通过简单的数学推导得到\n\nCore Animation已经定义了焦点的x,y坐标，就是这个图层的anchorPoint（锚点），同时取z=0的XoY平面作为图像平面（也就是iPhone的屏幕平面），那么假如我希望投影中心到图像平面的距离是d，可以假设焦点坐标为(0,0,d)，现在对`m34`的值进行赋值为w，初始向量坐标为(x,y,z)，开始推导：\n\n矩阵乘法：\n\n$ \\begin{bmatrix} x & y & z & 1 \\end{bmatrix} \\times \\begin{bmatrix} 1 & 0 & 0 & 0 \\\\\\ 0 & 1 & 0 & 0 \\\\\\ 0 & 0 & 1 & w \\\\\\ 0 & 0 & 0 & 1 \\end{bmatrix} = \\begin{bmatrix} x & y & z & zw+1 \\end{bmatrix} $\n\n此时得到的向量不为齐次，需要进行齐次化，得到真正的坐标：\n\n$ \\begin{bmatrix} x^{'} & y^{'} & z^{'} \\end{bmatrix} = \\begin{bmatrix} \\frac{x}{zw+1} & \\frac{y}{zw+1} & \\frac{z}{zw+1} \\end{bmatrix} $\n\n最后对XoY平面进行投影，则最终看到的二维向量应该为$ (\\frac{x}{zw+1}, \\frac{y}{zw+1}) $\n\n现在考虑x轴的情况（y轴同理），我们知道真实三维空间的x坐标是x，\n现在得到透视投影下的x坐标是x/(zw+1)\n\n为了得到d和w的关系，这里引用一幅图，绿色的点为原始点，红色的点为投影到XoY平面上的点，我们这里推导不需要管具体的值，只是为了更清晰地发现规律：\n\n![7525866072_efebf5cd22.jpg](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/1/8e/421990115e6623fdd5a5bec14d03a.jpg)\n\n$ \\because 由图，依据相似三角形原理 \\\\\\ \\therefore \\left| \\frac{x}{zw+1}: x \\right| = d : (\\left|z\\right|+d) \\\\\\ 去绝对值号，且d\\neq0,x\\neq0，得 \\\\\\ \\frac{1}{zw+1} = \\frac{1}{1-\\frac{z}{d}} \\\\\\ \\therefore w = - \\frac{1}{d} $\n\n这样就得到重要的结论：`w=-(1/d)`，即，假定焦点（就是人眼）距离原点距离为d，则`m34`应当填写`-(1/d)`\n\n默认初始变换矩阵的`m34`都是0，也就是说认为焦点无限远，因此看起来没有任何3D感。同时，我们也知道，假如我们取d越大，则看起来越没有投射和3D感；取d越小，则3D感和失真感越强烈，一般推荐的d值在500~1000之间，也就是说`m34`填写-1/500即可\n\n设置变换矩阵的`m34`：\n\n```objectivec\nCATransform3D transform = CATransform3DIdentity;\n//apply perspective\ntransform.m34 = - 1.0 / 500.0;\n//rotate by 45 degrees along the Y axis\ntransform = CATransform3DRotate(transform, M_PI_4, 0, 1, 0);\n//apply to layer\nself.layerView.layer.transform = transform;\n```\n\n![5.13.jpeg](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/9/12/fa3e96d6a571f355e18899eca3296.jpeg)\n\n# 总结\n\nCore Animation提供的CATransform3D主要的几个变换都在这里介绍了，尤其是透视投影，一定要理解原理，知道为什么需要修改`m34`来控制透视焦点。\n\n当然，实际上CATransform3D主要用来作各种3D动画效果，比如你可以自定义一个View的转场效果，搞个3D相册，甚至可以在不需要接触OpenGL的情况下写个小游戏（比如魔方啊之类），对于iOS进阶非常有帮助。最近有点忙没太关注，感觉自己还是需要学习一个。\n\n\n# 参考资料\n[iOS Core Animation Techniques](https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques/blob/master/5-%E5%8F%98%E6%8D%A2/%E5%8F%98%E6%8D%A2.md)\n\n[iOS的三维透视投影](http://geeklu.com/2012/07/ios-3d-perspective/)","categories":["iOS"],"tags":["iOS","CoreAnimation"]},{"title":"Core Graphics仿射变换知识","url":"/2016/09/27/Core-Graphics%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2%E7%9F%A5%E8%AF%86/","content":"\n> 这是补充记录关于CG的几何变换的一些知识，涉及到简单的矩阵变换\n\n# 变换矩阵\n\n在Core Graphics进行图层缩放、旋转、平移的时候，本质的操作就是使用`CGAffineTransform`这个3x2矩阵对象，与我们的`CGPoint`这个1x2的矩阵（其实就是对应就是[x,y]这个向量）进行矩阵相乘操作，得到的新矩阵就是变换后的新向量。一般通过CALayer得到的图层都是矢量，因此可以把整个图层进行相应的缩放、旋转、平移。\n\n```objectivec\ntypedef struct CGAffineTransform { \n  CGFloat a; \n  CGFloat b; \n  CGFloat c; \n  CGFloat d; \n  CGFloat tx; \n  CGFloat ty; \n} CGAffineTransform;\n```\n\n这个结构体对应的矩阵如下（看不到LaTeX公式的请看[Apple Developer Document](https://developer.apple.com/reference/coregraphics/1455865-cgaffinetransformmake)）：\n\n$ \\begin{bmatrix} a & b & 0 \\\\\\ c & d & 0 \\\\\\ t\\_{x} & t\\_{y} & 1 \\end{bmatrix} $\n\nApple采用了用[1]补齐1x3的向量，和用[0,0,1]的转置补齐的3x3的变换矩阵相乘来做仿射变换。虽然可能觉理论上可以直接用2x3变换矩阵和3x1的向量([x,y,1]的转置)运算，得到一个2x1的向量，省3个`CGFloat`的空间。但是由于这种变换操作叠加次数特别多，与其每次得到的向量结果再补齐[1]，还不如一次性就用一个1x3和3x3运算，用空间换取时间，这也许是QuartzCore的实现者的考虑吧。\n\n$ \\begin{bmatrix} x & y & 1 \\end{bmatrix} \\times \\begin{bmatrix} a & b & 0 \\\\\\ c & d & 0 \\\\\\ t\\_{x} & t\\_{y} & 1 \\end{bmatrix} = \\begin{bmatrix} ax+cy+t\\_{x} & bx+dy+t\\_{y} & 1 \\end{bmatrix} $\n\n\n注意：iOS上坐标原点从屏幕左上方起，x轴指向右方，y轴指向下方。macOS的原点在屏幕左下方，x轴指向右方，y轴指向上方，要注意区别\n\n# 平移\n\n变换矩阵第三行的t\\_x和t\\_y对应的就是x、y的平移量，因此矩阵变换很简单，比如将[x,y]向量平移到[x+a,y+b]：\n\n平移矩阵：\n$ \\begin{bmatrix} x & y & 1 \\end{bmatrix} \\times \\begin{bmatrix} 1 & 0 & 0 \\\\\\ 0 & 1 & 0 \\\\\\ a & b & 1 \\end{bmatrix} = \\begin{bmatrix} x+a & y+b & 1 \\end{bmatrix} $\n\n对应API：\n\n```objectivec\nCGAffineTransform CGAffineTransformMakeTranslation(CGFloat tx, CGFloat ty);\n```\n\n# 缩放\n缩放的本质，就是对向量[x,y]通过同时乘以相同的系数a，得到[ax,ay]，那么矩阵很简单，只需要一个对角矩阵，系数都为a就行\n\n缩放矩阵：\n\n$\\begin{bmatrix} x & y & 1 \\end{bmatrix} \\times \\begin{bmatrix} a & 0 & 0 \\\\\\ 0 & a & 0 \\\\\\ 0 & 0 & 1 \\end{bmatrix} = \\begin{bmatrix} ax & by & 1 \\end{bmatrix} $\n\n这个可以使用CA的API来简单构造（也可以直接自己初始化）：\n\n```objectivec\nCGAffineTransform CGAffineTransformMakeScale(CGFloat sx, CGFloat sy);\n```\n\n# 旋转\n旋转的变换矩阵初看上去好像难以理解（各种cos、sin），其实就是一个简单的解方程的出来的结果，注意这里需要的是弧度，而且iOS上旋转的正弧度代表顺时针（macOS上就是正弧度是顺时针），需要注意\n\n旋转矩阵：\n\n$ \\begin{bmatrix} x & y & 1 \\end{bmatrix} \\times \\begin{bmatrix} \\cos \\theta & \\sin \\theta & 0 \\\\\\ - \\sin \\theta & \\cos \\theta & 0 \\\\\\ 0 & 0 & 1 \\end{bmatrix} = \\begin{bmatrix} x \\cos \\theta - y \\sin \\theta & x \\sin \\theta + y \\cos \\theta & 1 \\end{bmatrix} $\n\n推导过程：\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/4/ef/04946d0b15517c28f52f8aaf7a850.png)\n\n$ P = (x,y) = (r\\cos A , r\\sin A) \\\\\\ P^{'} = (r \\cos B, r \\sin B) = (r\\cos(A + \\theta), r\\sin(A + \\theta)) \\\\\\ r\\cos(A + \\theta) = r\\cos A \\cos \\theta - r\\sin A \\sin \\theta = x \\cos \\theta - y \\sin \\theta \\\\\\ r\\sin(A + \\theta) = r\\sin A \\cos \\theta + r\\cos A \\sin \\theta = y \\cos \\theta + x \\sin \\theta \\\\\\ \\therefore M = \\begin{bmatrix} \\cos \\theta & \\sin \\theta & 0 \\\\\\ - \\sin \\theta & \\cos \\theta & 0 \\\\\\ 0 & 0 & 1 \\end{bmatrix} $\n\n对应API：\n\n```objectivec\nCGAffineTransform CGAffineTransformMakeRotation(CGFloat angle);\n```\n\n弧度可以用自带的定义，比如`M_PI_4`这些，也可以手动转换，比如用弧度、角度转换的宏：\n\n```objectivec\n#define RADIANS_TO_DEGREES(x) ((x)/M_PI*180.0) \n#define DEGREES_TO_RADIANS(x) ((x)/180.0*M_PI)\n```\n\n# 错切\n\n错切，就是一种特殊的线性变换（不平移），指的是某一个坐标轴依赖不变，另一个轴线性变换，参考Wiki上的图片：\n![](https://upload.wikimedia.org/wikipedia/commons/0/08/Eigen.jpg)\n\n错切矩阵：\n\n$ \\begin{bmatrix} x & y & 1 \\end{bmatrix} \\times \\begin{bmatrix} 1 & 0 & 0 \\\\\\ m & 1 & 0 \\\\\\ 0 & 0 & 1 \\end{bmatrix} = \\begin{bmatrix} x+my & y & 1 \\end{bmatrix} $\n\n这种变换没有提供专用的API，我们自己可以用`CGAffineTransformIdentity`创建一个矩阵，然后赋值矩阵中c或者b的值就行\n\n# 叠加\n既然了解了这些图层操作的矩阵变换，我们也可以自己定义矩阵，比如非线性变换(得到的向量不平行）、也可以把几个连续的变换串起来，这时候就要注意矩阵的运算顺序，比如先缩放50%，再旋转`M_PI_4`，再平移到[x+100,y]，那么等价于沿着45度平移50的距离（对应结果坐标就成了[x\\*sqrt(2)/4, y\\*sqrt(2)/4]）\n\n对应API：\n\n```objectivec\nCGAffineTransform CGAffineTransformConcat(CGAffineTransform t1, CGAffineTransform t2); // 最通用\nCGAffineTransform CGAffineTransformScale(CGAffineTransform t, CGFloat sx, CGFloat sy);\n// 缩放\nCGAffineTransform CGAffineTransformMakeRotation(CGFloat angle); //旋转\nCGAffineTransform CGAffineTransformTranslate(CGAffineTransform t, CGFloat tx, CGFloat ty); // 平移\n```\n\n# 参考资料\n[iOS Core Animation Advanced Techniques](https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques/blob/master/5-%E5%8F%98%E6%8D%A2/%E5%8F%98%E6%8D%A2.md)","categories":["iOS"],"tags":["iOS","Objective-C","CoreGraphics"]},{"title":"FRP对比—ReactiveCocoa、RxSwift、Bacon以及背后的Functional","url":"/2016/11/17/FRP%E7%AE%80%E4%BB%8B%E2%80%94ReactiveCocoa%E3%80%81RxSwift%E3%80%81Bacon%E4%BB%A5%E5%8F%8A%E8%83%8C%E5%90%8E%E7%9A%84Functional/","content":"\n# ReactiveCocoa和RxSwift\n\niOS的开发上，Objective-C可以说既是一个巨大的成功，也是一个巨大的限制。Cocoa Touch提供的原生API本身就是目标当年的事件驱动和消息派发的GUI编程模型，并且专门为Objective-C这门类smalltalk的消息式OO语言设计的，更为尴尬的是iOS上没有OS X上自带的[Data Binding](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CocoaBindings/CocoaBindings.html)。种种原因，导致Target-Acion，KVO，Notification，Apple式MVC架构才会一直成为iOS开发的主流。然而，做过开发的都知道，这套架构在大型App，尤其复杂是网络请求和人机交互特别多的情况下，非常容易让整个App架构变得难以维护。\n\nApple式的MVC，又称为Massive View Controller，会让你整个业务代码和UI绑定代码充斥同一个文件中，并且导致很多人经常会在View中，直接#include一个Modeld的头文件，然后起一个`configureInfo:\n`的方法，直接在里面把Model的数据拿来绑定到View的属性上。不信？试试搜一遍你所有的View，把Model的头文件删掉，看看能否编译通过。\n\n```swift\nvar userCell = tableView.dequeueReusableCellWithIdentifier(\"identifier\") as UserCell\nuserCell.configureWithUser(user)\n```\n\nMVP架构或许是你的救星，不过实际上，MVP只是一个工程化的解决问题，把Massive View Controller变成Massive View Presenter，带来相对明确的架构分层的副作用就是近乎两倍的代码量。而在这种情况下，MVVM的架构就是一个非常大的突破，和MVP一样把View/ViewController扔到一起，但是引入单独的ViewModel，通过View到ViewModel的单向绑定，ViewModel对Model的订阅，既避免了MVC造成的代码混乱，又减少了MVP的造成的重复代码。而实践上，提到MVVM，就得 提到[ReactiveCocoa](https://github.com/ReactiveCocoa/ReactiveCocoa)或者[RxSwift](https://github.com/ReactiveX/RxSwift)，这两者都是FRP的GUI框架实现。\n\n## ReactiveCocoa\n\n> 为了统一术语，ReactiveCocoa中的概念这里都描述成Rx中类似的概念，本质上都是一样的东西\n\nReactiveCocoa把事件流的接口，定义为`RACStream`。而实际上，通常的事件流实现都是`RACSignal`对象，这个Signal是一个冷事件流（也可以叫做push-driven），即有订阅者订阅后，才会`开始从头依次发送事件`。而对应的冷事件流接口叫做`RACMulticastConnection`，即没有订阅者也会发送事件流。热事件可以通过`publish`和`multicast`转换到热事件流，这对于很多请求，比如WebSocket这种不需要重入的事件流来说很有用。\n\n另外，为了支持Objective-C语言上对泛函性的缺乏，提供了另一个事件流的实现`RACSequence`对象，用来处理集合类型的事件流。\n\n一旦订阅之后，事件流就可以解包，拿到不同状态下的数据，Objective-C的接口就是和Rx类似的三种：\n`void (^next)(id) `：拿到事件本身，事件流本身继续流动\n`void (^error)(NSError *)`：处理错误事件，error和completed后事件流均结束，两种状态必局其一\n`void (^completed)()`：事件流正常结束的处理\n\n```objectivec\n[[self.usernameTextField.rac_textSignal\nfilter:^BOOL(id value){\n   NSString*text = value;\n   return text.length > 3;\n}]\nsubscribeNext:^(id x){\n   NSLog(@\"%@\", x);\n  }];\n```\n\n这里，`rac_textSignal`就是一个事件源，而后面的filter，是一个操作符，对事件流的事件变换到真正订阅者关心的数据，最后的`subscribeNext`是一个便捷方法，订阅并生命next状态的处理方式。整个流程模拟的是一个TextFiled的用户输入事件流的走向，用户的所有输入，一旦超过3个文本，就会流动并且打印出来，注意冷事件流是**整个流从头开始的**。\n\n```\nhel\nhell\nhello\n```\n\n就如上一篇简介中提到的那样，我们可以不断添加新的操作符，来灵活处理我们的关心的事件流。虽然Objective-C本身没有任何泛函性的接口，但是ReactiveCocoa封装的`RACSequence`本身提供了相当丰富的操作符，包括常见的`map`,`flatmap`,`filter`,`combine`,`switch`等，比如你可以把用户名和密码框的检验事件应用`combineLastest`来确保二者永远同时满足才允许登陆。\n\n```objectivec\nRACSignal *signUpActiveSignal =\n  [RACSignal combineLatest:@[validUsernameSignal, validPasswordSignal]\n                    reduce:^id(NSNumber *usernameValid, NSNumber *passwordValid) {\n                      return @([usernameValid boolValue] && [passwordValid boolValue]);\n                    }];\n```\n\n为了和非Reactive代码和谐相处，ReactiveCocoa提供了一个`RACSubject`类型，是用来处理有副作用的流的，即这个流是可变的。你可以手动创造一个新的流，并不断调用`sendNext:`来手动发送事件给其他订阅者，这就类似了传统的消息事件绑定机制。这个对于一些条件下，比如类似连续加载页面的信号，视图跳转等等有一定的作用，不过对于网络请求等，应当使用`RACSignal`。\n\n```objectivec\n[[_button rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) {  \n    [self.loggerSubject sendNext:@\"pop\"];  \n    [self.navigationController popViewControllerAnimated:YES];  \n      \n}];  \n```\n\n如前面所说，ReactiveCocoa是一个方便打造MVVM架构的框架，提供的`RAC宏`可以方便的进行单向绑定，把事件结果同你的UI对象属性绑定起来，避免了繁琐的代码处理，达到Reactive Programming\n\n```objectivec\nRAC(self.passwordTextField, backgroundColor) =\n  [validPasswordSignal\n    map:^id(NSNumber *passwordValid) {\n      return [passwordValid boolValue] ? [UIColor clearColor] : [UIColor yellowColor];\n    }];\n```\n\n![](https://koenig-media.raywenderlich.com/uploads/2014/01/CombinePipeline.png)\n\n\n简单来看，ReactiveCocoa真不愧是Cocoa，所有的设计围绕Cocoa的设计模式，提供了方便的宏，并且弱化了泛函概念，提供了很多副作用处理的方式，不像Rx那样纯粹。然而随着Objective-C语言的慢慢淡化，整个项目之后也转为依赖ReactiveSwift的实现。在当前iOS开发的情况下，如果使用Objective-C语言，那么这就是不二的FRP之选。但是如果使用Swift，最好使用正统的RxSwift。\n\n## RxSwift\n\n![](https://pic3.zhimg.com/v2-4b572f2ac5bc28905f043c7999c83c2a_r.jpg)\n\n[ReactiveX](http://reactivex.io/)，也就是Rx，是一个大的语言无关的FRP架构设计，只要你了解了一个语言下的用法，那么就可以达到`learn once, write everywhere`（跑……）\n\n在Rx中，事件流定义为一个`Observable`，而订阅者对应的是`Disposable`接口（RxJava里面对应的就是`Subscriber`），事件流可以通过subscribe来订阅，也是对应了三个状态`onNext`，`onError`，`onCompleted`。\n\n这里，就以RxSwift为准，介绍一下简单的区别。首先，得益于Swift的语法，ReactiveCocoa的Data Binding也变得更简单了，不需要宏包裹和提前声明，看起来更为清晰\n\n```swift\nlet subscription = primeTextField.rx.text           // Observable<String>\n\t.map { WolframAlphaIsPrime(Int($0) ?? 0) }      // Observable<Observable<Prime>>\n\t.concat()                                       // Observable<Prime>\n\t.filter { $0.isPrime }                          // Observable<Prime>\n\t.map { \"number \\($0.n) is prime\" }              // Observable<String>\n\t.bindTo(resultLabel.rx.text)                    // bind to label text\n```\n\n另外，Rx中，不同于ReactiveCocoa，事件流本身都是`Observable`，至于是冷还是热，是通过`publish`和`connect`操作得到的，不同于ReactiveCocoa中的`RACSignal`和`RACMulticastConnection`这种分开的设计，导致必须用对应的操作符，在Rx中，所有的操作符都是一致的表现，这点是一个非常大的改进。\n\n同时，Rx的操作符也是最丰富的，什么`lift`，`switch`这种常用的，在ReactiveCocoa中就得自己组合一套。当然，Rx的自定义操作符也很多简单，你只需要一个`T -> Observable<T>`类型的函数来定义\n\n```swift\nextension ObservableType {\n    func replaceWith<R>(value: R) -> Observable<R> {\n        return map { _ in value }\n    }\n}\n```\n\n整体上看，Rx是如今比较有名，并且成套的FRP解决方案，并且迁移到不同平台上的学习成本非常低。ReactiveCocoa本身如今已经分离为Swift版和Objective-C版，并且后者不再继续维护，因此对于混合Objective-C和Swift，或者纯Swift项目，RxSwift是一个构建MVVM和FRP架构的不二选择。\n\n# Promise\n为什么这里要提到Promise呢，因为Reactive Programming需要处理的很多，就是对异步请求和频繁事件响应的处理。而Promise是一个比较流行的JavaScript平台异步解决方案。在和FRP的配合上面，可以通过不断的then组合成需要的Promise事件，并且Promise的超集，也就是Future，本身就有搭配不同的Future操作符来达到类似于Rx的组合效果。\n\n不过，Promise的目的，在于对异步请求流程的控制，而本身并没有对事件流的管理。原始的Promise虽然有着类似Rx的事件流类似特点：`不可变性`、`可组合性`，但是关键区别在于Promise自身是单次流动，数据流只会从then开始走到结束或者catch掉，无法多次重新流动；不支持流程中断取消；需要配合其他框架层面的东西，来达到完整事件流和GUI数据绑定，这里就得提到[Bacon](https://github.com/baconjs/bacon.js/)\n\n# Bacon\n\n![](https://baconjs.github.io/logo.png)\n\nBacon是JavaScript上的一个FRP框架，借鉴于知名的[EventStream](https://github.com/dominictarr/event-stream)所实现的事件流，Bacon在这之上完成了FRP所需要的一切：事件流，变换，数据绑定，比起正统的RxJS来说，提供了更适合Web前端应用的的`EventStream`和`Property`，不需要被RxJS的Hot/Cold Observerable烦扰。并且原生支持了所有惰性求值，在benchmark上比起RxJS有着不错的性能优势。\n\n+ 示例——计数器\n\n```javascript\nlet plus = $(\"#plus\").asEventStream(\"click\").map(1)\nlet minus = $(\"#minus\").asEventStream(\"click\").map(-1)\nlet both = plus.merge(minus)\n\t.scan(0, add) // add +1 or -1 base on click eventstream\n\t.onValue(sum => $(\"#sum\").text(sum))\n\t.onError(e => console.log(e))\n\t.onEnd(() => alert('total: ' + $(\"#sum\").text));\n```\n\n除了专门提供的EventStream和Propery的两种Observable，并且提供了更好的事件源支持，你可以从原生的DOM事件来触发事件源，可以从Promise来触发（这是一个大的优势），甚至从callback或者自定义的binder都可以。在RxJS的基础上有了比较大的提升。不过具体工程上讲两者都是Rx实现的FRP，取舍还要看自己的特定选择（幸好我不做前端）\n\n# Functional\n\n> 由于自己也不是Haskell Guy，仅仅接触过一点点JS、Closure和Swift这些有泛函编程思想的语言 ，如果想具体了解函数式编程中，关于`Functor`、`Applicative`以及`Monad`的知识，推荐花上10分钟看一下简单的图文教程：分别有[原文(推荐)](http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html)、[Swift版](http://www.mokacoding.com/blog/functor-applicative-monads-in-pictures/)和[JS版](https://medium.com/@tzehsiang/javascript-functor-applicative-monads-in-pictures-b567c6415221#.5upsphilw)\n\n\n![](http://adit.io/imgs/functors/bind_def.png)\n\n下面这些内容，默认为已经掌握了上述简单理解，如果看不太懂可以回过头重新看一下对应的Functional知识\n\n## ReactiveX\n\nRx的`Observable`的本质就是一个`Event Monad`，即上下文（就是图文教程中包裹的盒子）为Event的一个Monad，这里的Event定义，可以对应语言的struct或者enum，包括了`next`、`error`和`complete`三个上下文即可。这里截取的是Swift语言的实现，`map`方法实现拆装箱（类似Optional，即Haskell的Maybe）\n\n```swift\npublic enum Event<Element> {\n    /// Next element is produced.\n    case next(Element)\n\n    /// Sequence terminated with an error.\n    case error(Swift.Error)\n\n    /// Sequence completed successfully.\n    case completed\n}\n\nextension Event {\n    /// Maps sequence elements using transform. If error happens during the transform .error\n    /// will be returned as value\n    public func map<Result>(_ transform: (Element) throws -> Result) -> Event<Result> {\n        do {\n            switch self {\n            case let .next(element):\n                return .next(try transform(element))\n            case let .error(error):\n                return .error(error)\n            case .completed:\n                return .completed\n            }\n        }\n        catch let e {\n            return .error(e)\n        }\n    }\n}\n```\n\n\n而Rx的`subscribe`方法就是一个解包，也就是`Monad<Event>.map()`，接收一个`(Event) -> void`的参数。或者使用更一般直观的三个参数`onNext: (Element) -> Void`、`onError: (Error) -> Void`、`onCompleted: (Void) -> Void`方法（在其他语言实践上，RxJS就是三个function参数，而RxJava为了支持Java7可以使用匿名内部类）\n\n理论：\n\n```haskell\nMonad Event <$> subscribe\n```\n\n示例：\n\n```swift\nlet subscription = Observable<Int>.interval(0.3)\n\t.subscribe { event in\n\t\tprint(event) // unwraped event\n\t}\n\nlet cancel = searchWikipedia(\"me\")\n\t.subscribe(onNext: { results in\n\t\tprint(results)\n\t}, onError: { error in\n\t\tprint(error)\n\t})\n\n```\n\n\nRx的Operator是`Functor`，也就是说`(Event) -> Event`，因此可以通过Monad不断`bind`你想要的组合子，直到最终符合UI控件需要的数据\n\n理论：\n\n```haskell\nMonad Event >>= map >>= concat >>= filter >>= map <$> subscribe\n```\n\n示例：\n\n```swift\nlet subscription = primeTextField.rx.text           // Observable<String>\n\t.map { WolframAlphaIsPrime(Int($0) ?? 0) }      // Observable<Observable<Prime>>\n\t.concat()                                       // Observable<Prime>\n\t.filter { $0.isPrime }                          // Observable<Prime>\n\t.map { $0.intValue }                            // Observable<Int>\n```\n\n\n## Promise / Future\nPromise本质上也是一个`Monad`，包裹的上下文就是`resolve`和`reject`。\n你可能反驳说`Promise.then(f)`中的`f`，可以是`value => value`，而并不是一个被Promise包裹的类型啊。但是实际上，由于JavaScript类型的动态性，Promise.then中直接返回value类型是个语法糖罢了，实际上会处理为`value => Promise.resolve(value)`\n\n```javascript\nPromise.resolve(1)\n.then(v => v+1) //便捷写法罢了，返回的是resolved状态的Promise对象\n.then(v => Promise.resolve(v+1)) //完整写法\n.then(v => Promise.reject('error ' + v)) //想要返回rejected状态，无便捷方法\n.catch(e => console.log(e)) // error 3\n```\n\n原理：\n\n```haskell\nMonad Promise >>= then >>= then >>= catch >>= then\n```\n\n示例：\n\n```javascript\nPromise.resolve(1)\n  .then(v => {\n    return v + 1; // 1\n  }.then(v =>  {\n    throw new Error('error'); //reject\n  }.catch(e => {\n    console.log(e); // error\n    return Promise.resolve(0);\n  }.then(v => {\n    console.log('end', v); // end 0\n  }\n```\n\n# 总结\nFRP本身发展时间并不长，主要是因为当年的GUI程序的复杂度和需求变化成都，和现如今相比有着明显的差距。传统的事件驱动在构件原型和简单交互的App确实非常简单，但随着架构的发展和业务增多，到了连MVP都无法承担的地步，MVVM的提出和相应的FRP框架就是一个救命稻草。\n\n虽然现如今来说，FRP的主要问题在于入门门槛相对高一点，不过在我看来，这就和当年Web走向Angular和React一样，都是需要一段时间过渡的。在Android平台上，RxJava已经获得了相当大的成功和推广，ReactiveCocoa可能在国内并不如RxJava那样出名，但估计在日后，FRP＋MVVM＋Reactive Native＋Redux这种混合App架构将会得到更大推广和发展，如果Apple或者Google再加一把推手，到那时候才可以说Reactive Programming的时代真正到来了吧。\n\n#参考资料\n\n+ [RxObjc](https://github.com/ReactiveCocoa/ReactiveObjC)\n+ [RxSwift](https://github.com/ReactiveCocoa/ReactiveSwift)\n+ [ReactiveX](http://reactivex.io/)\n+ [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)\n+ [Bacon](https://github.com/baconjs/bacon.js/)\n+ [Monad](http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html)\n+ [NSHipster](http://nshipster.cn/reactivecocoa/)\n+ [ReactiveCocoa Tutorial](https://www.raywenderlich.com/62699/reactivecocoa-tutorial-pt1)\n+ [ReactiveCocoa Monad](http://blog.leichunfeng.com/blog/2015/11/08/functor-applicative-and-monad/)","categories":["iOS"],"tags":["iOS","Functional","Swift","JavaScript"]},{"title":"FRP简介—论GUI程序架构发展","url":"/2016/11/16/FRP%E7%AE%80%E4%BB%8B%E2%80%94%E8%AE%BAGUI%E7%A8%8B%E5%BA%8F%E6%9E%B6%E6%9E%84%E5%8F%91%E5%B1%95/","content":"\n> 熟悉做端GUI程序（客户端，Web前端）的同学一定会知道，做UI最大的问题就是模型和视图对象的绑定，视图对象的状态管理，以及事件消息的处理。\n\n# 背景\n\n传统的GUI编程的一大核心，就是使用了事件驱动编程模型。UI对象的布局、状态等，通过外部的消息事件（点击，触摸，网络请求响应等等）来触发。这是由于GUI程序的人机交互的天生性质决定的（当然，这里的GUI不包括游戏，游戏一般采用立即的帧驱动而非事件）。对于GUI编程的架构方面，从发现到现在，不外乎这几种：\n\n# 传统的事件监听，消息派发机制：\n\n![](http://www.codeproject.com/KB/java/677591/EventModel.jpg)\n\n这是最常见，也是最贴近GUI程序底层实现的模型。一般来说，GUI程序的框架入口就是一个大的while(true)循环，通过在循环内不断向窗口管理器请求消息（比如点击事件等用户输入），通过把底层的消息回调函数回调或者IPC机制，封装成一个个对开发者友好的事件对象来派发出来。\n\n因此，传统的这种模型，在GUI开发的时候，通过把UI对象绑定指定的事件监听器，在监听器的代码中手动改变状态，来达到人机交互。当然，这一点还不够，因为我们没法手动来触发多个UI对象的关联关系，也很难处理非输入类型事件，比如网络请求，文件读写。因此就需要引入消息的机制，通过派发消息，UI对象可以选择是否处理该消息，或者重新派发消息给其他UI对象，对于网络请求等，既可以用高层的消息处理，也可以手动通过回调函数来处理。这样整套机制就是传统的GUI程序的核心机制。\n\n传统的GUI事件驱动模型，一直伴随着历史的发展，诞生了无数的解决方案和GUI框架，从早期的暴力的函数指针来绑定事件回调，到如今各种面向对象的消息-事件机制。基本你在各种GUI框架中都能找到。不过，遗憾的事，一般的Event都是单个消息或者事件对象，你可以再派发给其他UI对象来处理，但整个流程不是非常响应变化的，假如需要新的消息处理，就得在各处的监听器上手动修改代码，这一点也不Reactive\n\n举例：\n\n+ [iOS Target-Action](https://developer.apple.com/library/content/documentation/General/Conceptual/CocoaEncyclopedia/Target-Action/Target-Action.html)\n+ [Android Event](https://developer.android.com/guide/topics/ui/ui-events.html)\n+ [Web EventListener](https://developer.mozilla.org/en-US/docs/Web/API/EventListener)\n+ [Qt Singal Slot](http://doc.qt.io/qt-4.8/signalsandslots.html)\n+ [WPF Events](https://msdn.microsoft.com/en-us/library/ms753115.aspx)\n\n# 数据绑定和状态管理\n\n![](http://i.stack.imgur.com/KZFfe.png)\n\n随着GUI程序的发展，尤其是Web前端领域的发展，传统的事件消息机制也越来越难以方便应对大型GUI应用。随着你的GUI程序交互越来越多样，网络请求越来越多，不同UI对象之间关联越来复杂，一个事件过来，也许你需要修改十多个相关UI对象的属性和布局；同时网络请求的回调，你又得分发封装成多种消息发送出去。最终，你写的UI逻辑代码，将达到：`消息对应事件数 * 事件绑定的UI对象数 * UI对象需要修改的属性数`这样一种地步。这就对GUI开发带来了一个非常大的挑战。\n\n因此，这就带来一个GUI开发的新模式。我们可以重新思考一下，假如我们把消息源，通过一定的策略，直接同UI的属性绑定起来，这就是数据绑定。可以通过建立一套框架封装消息和事件，并自动化事件到UI对象属性这一流程。同时，为了正确修改UI对象的属性，传统的事件消息机制一般会在事件监听器上计算UI对象的当前状态，并手动修改需要修改的属性。因此，数据绑定的时候也需要引入状态管理。在这套框架中，UI对象本身不需要存储状态，需要有一层来处理不同状态对应的UI对象绑定方式，整个Data Flow从数据模型出发，触发状态改变，然后同步到UI对象对应状态下的绑定方式，最终改变UI对象的属性。\n\n当然，从上面的说法也能看出，最简单的实现，至少要达到事件->UI对象的单向绑定，同时也可以存在事件<\\->对象的双向绑定。数据绑定常见于使用类XML布局的GUI框架，因为纯XML无法存储状态。比如Vue.js的XML模版，React的JSX，Android的XML布局，WPF的XAML等等。而对于iOS应用而言，除了搭配Storyboard来简化状态，代码布局中一般采用MVVM架构，将View和ViewController这个与View紧耦合的模块放在一起当做View层，其中ViewController专门负责ViewModel的数据绑定到UI对象上，把所有View产生的事件派发回ViewModel（比如按钮的点击，Target为ViewModel），本身不负责任何业务逻辑。而ViewModel就是真正业务逻辑的地方，负责管理View的状态、触发的事件来更新Model，Model更新得到的数据和状态变化则代理给View。不过实践上一般都直接采用ReactiveCocoa了（当然，它数据绑定只是小部分，真正重要地方在FRP上）\n\n举例：\n\n+ [React.js](https://facebook.github.io/react/)\n+ [React Native](https://facebook.github.io/react-native/)\n+ [Redux](https://github.com/reactjs/redux)\n+ [Vue.js](https://vuejs.org/)\n+ [ReactiveCocoa](https://github.com/ReactiveCocoa/ReactiveCocoa)\n+ [Android Data Binding](https://developer.android.com/topic/libraries/data-binding/index.html)\n+ [WPF](https://msdn.microsoft.com/en-us/library/ms752347.aspx)\n\n# FRP——Functional Reactive Programming\n![](https://camo.githubusercontent.com/995c301de2f566db10748042a5a67cc5d9ac45d9/687474703a2f2f692e696d6775722e636f6d2f484d47574e4f352e706e67)\n\n数据绑定看起来很直观很美好，但是状态管理却不是。随着UI对象的增加，GUI应用的状态就会再次面临`组件状态数=关联的组件状态数求积`这样一个累乘关系。而且更糟糕的是，因为状态这种东西，不同于具体的UI对象属性，要改变只能重新触发，所以当状态流从数据源开始向下传递的时候，假如某些UI对象想要修改并继续传递，就只能再触发新的状态，这更加重了状态管理的压力。\n\n这时候，函数式编程的思想又发挥了功力。不同于传统事件消息机制的繁琐和复杂，也不需要面对复杂状态时管理，FRP的思想，在于把不定期的事件触发，当做一个事件流，让不同的订阅者来订阅，并绑定事件流的数据到UI对象的属性上。\n\n借由函数式编程的思想，事件流本身是不可修改的，但订阅者可以通过组合无副作用的函数来得到一个属于自己定制的新的事件流，不同订阅者可以重用其他订阅者已经组合过的事件流。事件流的流动方向就是时间轴方向，而订阅者可以组合得到新的事件流的副本，某时刻原事件的状态，该订阅者就能得到该时刻事件对应变化后的状态，用来绑定UI对象。\n\n比如你需要做一个点击监测的功能，需要给一个文本框显示在250ms间隔内连续点击两次以上的次数。如果换做传统事件消息机制，那么就得写两个函数，一个捕获事件，一个计时器，还需要一个全局状态量记录当前这250ms点击的次数。换做数据绑定的方式稍微简化了一点，一个绑定处理函数，但是得引入两个额外状态：当前轮次数增加状态，和切换下一轮的状态。而换做FRP，就如上图所示，把点击事件流，直接通过运算符组合到真正的数据流，绑定到UI对象的即可。\n\nFRP的核心，在于事件流可多次触发，以及各种操作符用来作事件流变换，最终交到订阅者手上的，就是真正UI对象想要的数据流，这样我就可以把这个数据流绑定到UI对象上，达到整个Data Flow的完整性。\n\n举例：\n\n+ [ReactiveX](http://reactivex.io/)\n+ [ReactiveCocoa](https://github.com/ReactiveCocoa/ReactiveCocoa)\n+ [EventStream](https://github.com/dominictarr/event-stream)\n\n# SO?\n传统的事件驱动将永远是GUI框架的基础，因为最贴近实现层，而且可扩展性强。但是实际开发中，事件消息驱动将导致你的事件监听器遍布各处，也会强行把View层和Model层绑定在一起，并且不利于修改。而数据绑定和FRP的架构能够将GUI程序的UI对象，和数据相对分离开，View不需要管什么事件，只需要自己关系的，为了渲染的属性数据即可。\n\n在现在看来，FRP是在数据绑定的基础上，避免了过重的状态管理，并且能够大大简化代码量，想对容易达到MVVM架构，对于大型应用构建是一个不错的选择。之后的会简单介绍几个FRP框架和比较，同时可以科普一下FRP背后的Functional简单原理。期待今后的MVVM和FRP，在移动和Web平台能够得到更大的推广，解放广大人民生产力。","categories":["Code"],"tags":["Functional"]},{"title":"Java之暴力实现Parser Generator（序言）","url":"/2016/03/30/Java%E4%B9%8B%E6%9A%B4%E5%8A%9B%E5%AE%9E%E7%8E%B0Parser-Generator%EF%BC%88%E5%BA%8F%E8%A8%80%EF%BC%89/","content":"\n> 编译原理已经学了很多了吧？还有所迷茫？那么今天跟着我一起学习如何暴力写一个Parser Generator\n\n# Why Java：\n\n因为Java有着丰富的对开发人员傻瓜式友好的内置数据结构，什么Map，Set，Stack，求交集求并集也就一句a.contains(b);a.addAll(b)的事情，并且不需要担心资源泄漏(?)的问题，对于我们的暴力实现非常有帮助。而且相比C++我也更为熟悉..\n\n# What is parser generator\n\n这里就指的是支持用户输入CFG（[Context-free grammar][1]），然后生成出一个Java代码，这个代码可以编译以后得到一个Parser用来Parse符合输入CFG定义的文法，类似于[Yacc][2]\n\n迷糊了？举个例子，就是假如用户定义了这样一组CFG，用来匹配一个对于正整数的加法和乘法\n\n$ S \\rightarrow TB \\\\ B \\rightarrow TB \\mid \\epsilon \\\\ T \\rightarrow FT^\\* \\\\ T^\\* \\rightarrow \\* FT^\\* \\\\ F \\rightarrow (S) \\mid 0 \\mid \\dots \\mid 9 $\n\n当然，数学符号肯定很好写，实际中输入大概是这样子的(\\e表示epsilon)：\n\n```text\nS  -> T B\nB -> + T B | \\e\nT  -> F T{*}\nT{*} -> * F T{*} | \\e\nF  -> (S) | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9\n```\n\n这样的话，这个CFG输给我们的Parser Generator(我们叫做a.java)，运行后得到的代码，再次编译以后(我们叫做b.java)就可以用来匹配输入，对于3 + 5 * 7，我们能给出True的匹配。结果可能是这样子的\n\n```text\nLL(1) Parser start\n\nCurrernt top: S input: 3\nCurrernt top: T input: 3\nCurrernt top: F input: 3\nCurrernt top: 3 input: 3\nCurrernt top: T{*} input: +\nCurrernt top: B input: +\nCurrernt top: + input: +\nCurrernt top: T input: 5\nCurrernt top: F input: 5\nCurrernt top: 5 input: 5\nCurrernt top: T{*} input: *\nCurrernt top: * input: *\nCurrernt top: F input: 7\nCurrernt top: 7 input: 7\nCurrernt top: T{*} input: #\nCurrernt top: B input: #\n\nParse result: true\n```\n\n当然，这个匹配用的是表驱动的，而且后续会生成AST（[Abstract syntax tree][3]）\n\n# What algorithm\n\n当然，核心在于学习编译，所以我们会分别使用[LR(1)][4]和[LL(1)][5]生成我们的Parser，里面会用到用到LR(1)的三种集合，LL(1)的Closure等知识……\n\n# How about efficiency\n\n看到我说的暴力……你就知道这是妥协了。虽然我们会考虑效率，但只考虑大O，不会在意具体new了多少个对象，是否重复，算法实现也尽量以清晰易懂，直接可以看作伪代码，而不会过多优化，所以，这主要是一个教学，没有过多的实际意义……\n\n# Talk is cheap\n\n自己大概写了个非常简陋的版本……现在只能确保LR(1)文法能够Parse，LL(1)正在努力过测试 GitHub repo: <https://github.com/lizhuoli1126/e-lexer> （不要在意名字……开始想做的是lex却发现走到了类似yacc的路上去了……）\n\n# So what's next\n\n第一篇，我们只大概介绍一下框架，以及一个简单的Input Buffer的实现，还有我们定义的CFG的语法，状态机图，所以大家放轻松，让我们稍后再见\n\n [1]: https://en.wikipedia.org/wiki/Context-free_grammar\n [2]: https://en.wikipedia.org/wiki/Yacc\n [3]: https://en.wikipedia.org/wiki/Abstract_syntax_tree\n [4]: https://en.wikipedia.org/wiki/LR_parser\n [5]: https://en.wikipedia.org/wiki/LL_parser","categories":["Java"],"tags":["Java","编译原理"]},{"title":"Objective-C ARC下block表现和关键字影响","url":"/2016/06/17/Objective-C-ARC%E4%B8%8Bblock%E8%A1%A8%E7%8E%B0%E5%92%8C%E5%85%B3%E9%94%AE%E5%AD%97%E5%BD%B1%E5%93%8D/","content":"\n> Objective-C中的block是一种特别的结构，block与普通的instance不同的地方，不止更在于它的语法，更在于它的不同表现以及内存分配。\n\n虽然block对于Objective-C来说已经早不新鲜了，但现如今很多博文讲述的block行为是基于MRC的，这与ARC下的表现是不同的。现代Objective-C也应该渐渐淘汰MRC和GC（其实GC已经淘汰了，在`macOS Sierra已经无法使用，iOS从来不支持`）本文所提及情况均限于ARC\n\n\n# ARC下不同类型的block表现\n\n很多博文都提到过，block通过llvm编译后，会生成对应的三种Class的实例变量，分别是：`NSStackBlock`、`NSGlobalBlock`、`NSMallocBlock`，分配区域分别位于进程的栈，TEXT段，堆。ARC下为了简化block的内存管理，以及性能优化，llvm会对不同情形下的block进行不同的类型变化，\n\n```objectivec\nint a = 1;\nNSString *string = @\"\";\n\nNSLog(@\"%@\", NSStringFromClass([^(){} class]));\n\nNSLog(@\"%@\", NSStringFromClass([^(){\n\tint b = a;\n} class]));\n\nvoid (^block1)(void) = ^{\n\tint b = 2;\n};\nNSLog(@\"%@\", NSStringFromClass([block1 class]));\n\nvoid (^block2)(void) = ^{\n\tNSString *b = string;\n};\nNSLog(@\"%@\", NSStringFromClass([block2 class]));\n```\n\n猜猜输出是什么？\n\n```\n__NSGlobalBlock__\n__NSStackBlock__\n__NSGlobalBlock__\n__NSMallocBlock__\n```\n\n从这里也可以总结出规律：\n\n1. 如果block不捕获任何外部变量（包括了`Primitives`（基本类型）），既没有对外部任何对象retain，也没有copy基本类型，那么这个block不存在任何内存泄漏的风险，也不需要引用计数，所以类型为`__NSGlobalBlock__`\n2. 如果block捕获了外部变量（包括基本类型），但并没有被任何对象所引用（retian），而是直接被用于直接执行或者发送消息，那么它不会有任何引用计数问题，类型为`__NSStackBlock__`。由于位于栈区，这个block在函数返回后将被销毁，不过请放心，在ARC下，因为没有被任何对象引用，所以它始终是安全的（一旦之后被引用，立即会由Runtime负责通过`Block_copy()`转换为`__NSMallocBlock__`）\n3. 通常情况下，如果block捕获了外部变量，且只要有对象持有（注意，无论引用是`__strong` 还是`__weak`还是`__copy`，参考[llvm-blocks](http://clang.llvm.org/docs/AutomaticReferenceCounting.html#blocks)），都会通过Runtime的`Block_copy()`和`Block_release()`，由编译器自动地将原本在栈的block拷贝到堆上，因此会像普通对象一样，交由ARC自动管理引用计数\n\n\n# __block的影响\n\n`__block`的关键字的作用大家都知道，默认情况下block是无法修改外部实例变量的（能读，也就是捕获），而经过__block修饰的实例变量可以通过block外修改。\n但是的表现是否单纯可以概括为\"捕获了一份实例变量到堆上，并修改了原来的引用\"呢？\n\n看看这个：\n\n```objectivec\n__block NSMutableArray *array1 = [[NSMutableArray alloc] initWithCapacity:10];\nNSLog(@\"object addr: %p, pointer addr: %p\", array1, &array1);\nvoid (^block1)(void) = ^{\n\tNSLog(@\"object addr: %p, pointer addr: %p\", array1, &array1);\n};\nblock1();\nNSLog(@\"object addr: %p, pointer addr: %p\", array1, &array1);\n\n__block NSMutableArray *array2 = [[NSMutableArray alloc] initWithCapacity:10];\nNSLog(@\"object addr: %p, pointer addr: %p\", array2, &array2);\nvoid (^block2)(void) = ^{\n\tNSLog(@\"object addr: %p, pointer addr: %p\", array2, &array2);\n};\nblock2();\nNSLog(@\"object addr: %p, pointer addr: %p\", array2, &array2);\n```\n\n输出结果：\n\n```\nobject addr: 0x7ffe8a60d800, pointer addr: 0x7fff5548c988\nobject addr: 0x7ffe8a60d800, pointer addr: 0x7ffe8a501db0\nobject addr: 0x7ffe8a60d800, pointer addr: 0x7fff5548c988\n\nobject addr: 0x7ffe8a401bf0, pointer addr: 0x7fff5548c950\nobject addr: 0x7ffe8a401bf0, pointer addr: 0x7ffe8a401e98\nobject addr: 0x7ffe8a401bf0, pointer addr: 0x7ffe8a401e98\n```\n\n从中可以看出，由于Objective-C所有的实例变量都分配在堆上，而对于ARC下的block，如果不加`__block`关键字，那么在捕获后，外部的引用（Objective-C的指针，其实就是一个对象的引用，类似于Java）不会受到任何影响（只是对引用进行了拷贝）。而如果使用`__block`的话，那么会将原来的引用修改（注意到地址值的变化）。\n\n当然，实际上的`__block`捕获的实例变量，会额外追加一些字段，用于Runtime进行内存管理和处理引用（参考[block- marked-variables](http://clang.llvm.org/docs/Block-ABI-Apple.html#layout-of-block-marked-variables)）\n\n```c\nstruct _block_byref_foo {\n    void *isa; //isa指针\n    struct Block_byref *forwarding; // block_byref结构体指针\n    int flags;   //引用计数数,retianCount\n    int size;   //分配大小\n    typeof(marked_variable) marked_variable;  //实例变量的引用\n};\n```\n\n因此可以知道，`__block`是好，但每个捕获变量都会多出至少20字节……虽然llvm的优化能力很好，盲目的标记`__block`也并不是一件好事（还会增加Runtime的开销和少量内存开销）\n\n\n# 其他\n\n顺便一说，最近在补iOS开发基础知识，发现这个[《招聘一个靠谱的iOS》答案-38题](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#38-在block内如何修改block外部变量)的说法是有问题的，不存在什么\"block的变量copy到堆区\"，只要你的block被引用，那么这个block一定在堆区，而且并不是所谓的\"加入__block后才copy\"，，真正变化的，只是那个引用的地址变了罢了。大家希望看到后不要被误导……\n\n\nPS：\n1. 如果想了解更多Runtime实现block的方式和具体block的内存分布，可以参考[llvm-block](http://clang.llvm.org/docs/Block-ABI-Apple.html)\n2. 如果你真的需要MRC，可以参考这篇文章，附带一个小题目测试一下你的掌握情况[MRC-block-quiz](http://blog.parse.com/learn/engineering/objective-c-blocks-quiz/)","categories":["iOS"],"tags":["iOS","Objective-C"]},{"title":"Objective-C代码库的实现隐藏","url":"/2017/06/04/Objective-C%E4%BB%A3%E7%A0%81%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0%E9%9A%90%E8%97%8F/","content":"\n> 虽然Swift现在是开发iOS推荐入手的最佳语言，但是对于代码库而言，最大的一个问题是Swift ABI仍然没有定下（今年发布的的Swift 4.0，依然放弃ABI稳定性，而注重于Swift源代码3.x->4.0的兼容性）。所以这就意味着Swift 3.x编译的二进制库，在Swift 4.0将无法链接，只能重新代码编译。看来这又将是Objective-C这门古老的语法，能够作为一些framework首选开发语言的一年。\n\n对于一个代码库来说，有时候我们为了隐藏一些实现的细节，或者内部处理流程，需要编译到二进制进行分发，并提供Public Header来供其他开发者调用。\n\n因此，开发代码库的时候，需要明确哪些API是对外公开的，可以由其他开发者调用。那些是库内部之间互相调用的，不应该由外部使用者调用。而Objective-C不像C++提供了private关键字来限制直接访问成员变量和成员方法。因此，就需要尽量避免私有属性和私有方法的定义出现在头文件中。只要不引入私有的头文件，那就无法直接访问这些属性和方法。\n\n# 隐藏内部属性\n私有属性，可以分成两种，一种是希望放到类内部而纯粹不想暴露给任何人的，可以叫做内部属性。一种是希望暴露到Private Header中，只限于引入该头文件的地方进行访问。\n\n内部属性的声明非常简单，我们可以直接使用类扩展声明属性，而编译器会自动生成getter和setter，不需要任何额外工作。\n\n```objectivec\n// Person.m\n@interface Person ()\n\n@property (nonatomic, strong) NSObject *internalObject;\n\n@end\n```\n\n## 改变属性修饰符\n对于很多情况，我们需要对外暴露属性是readonly的，以防止使用者手动修改，但是内部流程的时候也需要这个属性，并且希望是readwrite的，这个在类扩展中直接可以重新声明已有的属性，并修改属性修饰符。\n\n```objectivec\n// Person.h\n@interface Person\n\n@property (nonatomic, strong, readonly) NSNumber *number;\n\n@end\n// Person.m\n@interface Person ()\n\n@property (nonatomic, strong, readwrite) NSNumber *number;\n\n@end\n```\n\n注意，由于类扩展是可以在任何地方声明的（不限于.m实现文件），我们也可以把属性修饰符的修改，放到Private Header（可以用`+Private`后缀，也可以参考UIKit等框架起名为`UIKitInternal.h`）中，这样引入了Private Header的地方可以readwrite，没有引入的地方是readonly。\n\n```objectivec\n// Person+Private.h\n@interface Person ()\n\n@property (nonatomic, strong, readwrite) NSNumber *number;\n\n@end\n```\n\n# 隐藏私有属性\n但是很多时候，我们希望一些属性是私有的，即类实现处和引入了Private Header的地方才可以访问。这种时候就需要采取别的方式了。常见的方法是通过类扩展（主要针对类的实现文件可见）或者使用关联对象（主要针对类的实现文件不可见，如其他第三方库的类）两种方式。\n\n## 类扩展（Class Extension）\n### 通常情形\n类扩展，不同于Category，最大的优势在于可以直接添加实例变量ivar到类的本身实现中，而Category是无法添加实例变量的。而在类扩展中声明的属性，也可以自动在编译期合成，同普通类声明属性的方式相同，不了解的参见：[CustomizingExistingClasses](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/CustomizingExistingClasses/CustomizingExistingClasses.html)。因此，实际上类扩展非常适合隐藏私有属性。\n\n```objectivec\n// Person+Private.h\n@interface Person ()\n\n@property (nonatomic, strong) NSString *privateID;\n\n@end\n```\n\n\n### 自定义存取方法\n\n对于通常case来说，这是非常好的解决方法（不用任何额外代码）。但是有一个问题，如果你想**自定义这个属性的存取方法**（比如，实例变量的惰性初始化），那就会遇到问题。因为属性合成的ivar，是只在类本身实现中创建的，在Category中无法创建，而且类的实现只能实现一次（在原始的`Person.m`中实现）。试想一下这样子的情况，就会出现编译错误：\n\n```objectivec\n// Person+Private.m\n@implementation Person (Private)\n\n- (NSString *)privateID\n{\n    if (!_privateID) { //Compile Error: undeclared identifier:_privateID\n        _privateID = @\"foo\";\n    }\n    \n    return _privateID;\n}\n```\n\n**第一种解决方案：**\n\n最简单的方式，就是直接把自定义的存取方法写在类本身实现文件中，然后在Category中暴露头文件，并用`@dynamic`来标记这个属性（否则由于Category看不到编译器自动生成的getter和setter会报warning）。自定义存取方式就和普通的写法一模一样。这相当于是一种把内部属性暴露出来的方法。不过容易导致耦合（因为其实我们的私有属性目标是用于和外部类交互的，不希望放到Private Category以外）。\n\n```objectivec\n//Person.m\n\n@interface Person ()\n\n@property (nonatomic, strong) NSString *privateID;\n\n@end\n\n@implementation Person\n\n- (NSString *)privateID\n{\n    if (!_privateID) {\n        _privateID = @\"foo\";\n    }\n    \n    return _privateID;\n}\n\n@end\n\n//Person+Private.h\n@interface Person (Private)\n\n@property (nonatomic, strong) NSString *privateID;\n\n@end\n\n//Person+Private.m\n@implementation Person (Private)\n@dynamic privateID;\n\n@end\n```\n\n**第二种解决方案：**\n\n当然，聪明的你自然会想到，既然Category没法定义ivar，那直接在类扩展中声明一个ivar不就行了。于是你可以这样写，但是这会出现一个编译警告：\n\n```objectivec\n// Person+Private.h\n@interface Person () {\n    NSString *_privateID;\n}\n\n@property (nonatomic, strong) NSString *privateID;\n\n@end\n\n// Person+Private.m\n@implementation Person (Private)\n\n// Compile Warning: category override method from class\n- (NSString *)privateID\n{\n    if (!_privateID) {\n        _privateID = @\"foo\";\n    }\n    \n    return _privateID;\n}\n```\n\n由于在类扩展中已经定义了属性，那么这个类在编译期间会自动合成存取方法，而在Private Category中覆盖就会覆盖本身合成的方法（虽然我们确实需要这样），但由于可以在多处定义Category，并且方法覆盖的顺序不定，无法保证你的存取方法就是真实想要的，所以这是编译警告。对于这种需要自定义存取方法的私有属性的case，应该在类扩展中定义ivar，在Private Category中定义属性并实现。注意由于在类扩展定义了ivar，不会自动生成getter+setter，**需要自行同时定义setter和getter**，注意对不同属性修饰符，比如`copy`的话setter需要用`[-copy]`，`weak`的话ivar要标注`__weak`等。\n\n```objectivec\n// Person+Private.h\n@interface Person () {\n    NSString *_privateID;\n}\n\n@end\n\n@interface Person (Private)\n\n@property (nonatomic, strong) NSString *privateID;\n\n@end\n\n// Person+Private.m\n@implementation Person (Private)\n\n- (NSString *)privateID\n{\n    if (!_privateID) {\n        _privateID = @\"foo\";\n    }\n    \n    return _privateID;\n}\n\n- (void)setPrivateID:(NSString *)privateID\n{\n    _privateID = privateID;\n}\n```\n\n## 分类（Category）和关联对象\n由于Objective-C的属性，其实就是ivar+getter方法+setter方法，我们可以在使用的地方通过Runtime来获取ivar。但是这种方式实际上来说是用的人非常少。第一个是复杂，第二个是不好使用一个通用的宏进行转换（因为ivar需要计算offset，根据不同类型的type encoding还不同……），而且对于这种需求来说优点大材小用了。因此我们一般都是使用关联对象（不了解的参见：[Associated Object](http://nshipster.com/associated-objects/)）\n\n使用了关联对象后，为了方便不必要繁琐地书写`objc_getAssociatedObject`、`objc_setAssociatedObject`，我们可以定义一些宏来方便使用。由于属性是包括了语义和引用计数相关内容的，因此针对不同的属性修饰符，需要采用不同的宏来保证属性的语义。\n\n属性修饰符的语义，可以参考clang官网的说明：[Objective-C Automatic Reference Counting](http://clang.llvm.org/docs/AutomaticReferenceCounting.html#property-declarations)，如下：\n\n> `assign` implies `__unsafe_unretained` ownership.  \n> `copy` implies `__strong` ownership, as well as the usual behavior of copy semantics on the setter.  \n> `retain` implies `__strong` ownership.  \n> `strong` implies `__strong` ownership.  \n> `unsafe_unretained` implies `__unsafe_unretained` ownership.  \n> `weak` implies `__weak` ownership.\n\n由于属性修饰符只会影响setter，而不是getter，我们可以定义一个通用宏。对应的setter就需要单独根据情况编写。\n\n```objectivec\n#import <objc/runtime.h>\n#define __GET_PROPERTY(property) objc_getAssociatedObject(self, @selector(property));\n```\n\n### strong(retain)\n\n`strong`或者`retain`，就是所有对象的默认属性存取行为，隐含着对对象进行retain而使引用计数+1。这个可直接通过关联对象的行为设置。\n\n宏：\n\n```objectivec\n#define __SET_STRONG(property) objc_setAssociatedObject(self, @selector(property), property, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n```\n\n示例：\n\n```objectivec\n@property (nonatomic, strong) NSNumber *number;\n\n- (NSNumber *)number\n{\n    return __GET_PROPERTY(number);\n}\n\n- (void)setNumber:(NSNumber *)number\n{\n    __SET_STRONG(number)\n}\n```\n\n\n### copy\n`copy`属性修饰，表示在调用setter的时候，首先需要对对象进行`copy`操作，然后再表示`strong`，在Objective-C中其实就是发送了`copyWithZone:`消息。这个可直接通过关联对象的行为设置。\n\n宏：\n\n```objectivec\n#define __SET_COPY(property) objc_setAssociatedObject(self, @selector(property), property, OBJC_ASSOCIATION_COPY_NONATOMIC);\n```\n\n示例：\n\n```objectivec\n@property (nonatomic, copy) NSString *name;\n\n- (NSString *)name\n{\n    return __GET_PROPERTY(name);\n}\n\n- (void)setName:(NSString *)name\n{\n    __SET_COPY(name);\n}\n```\n\n### unsafe_unretained\n`unsafe_unretained`和`assign`的语义是相同的，前者是ARC下加入的，而后者从MRC开始存在。一般来说，对于原始类型（`int`、`double`、`BOOL`、`NSInteger`)这些，由于本身就是copy by value，而且不存在对象和引用计数管理，因此属性声明用`assign`（很少见写`unsafe_unretained`，虽然允许）。\n\n而对于对象而言，一般如果想表示不改变任何引用计数的弱引用，现在都用的是`weak`，因为`unsafe_unretained`不会像`weak`那样，在对象引用计数降到0被销毁后，自动置nil，而会保持指向的地址，因此可能随时都成为野指针而不安全。但是由于历史代码缘故，还有很少的代码库在用，姑且暂时保留。\n\n这里我们定义一个宏，仅用于表示对象的`unsafe_unretained`和`assign`。这个可直接通过关联对象的行为设置。而对于原始类型的属性，参见下面的`assign`\n\n宏：\n\n```objectivec\n#define __SET_UNSAFE_UNRETAINED(property) objc_setAssociatedObject(self, @selector(property), property, OBJC_ASSOCIATION_ASSIGN);\n```\n\n示例：\n\n```objectivec\n@property (nonatomic, unsafe_unretained) NSObject *unsafeObject;\n\n- (NSObject *)unsafeObject\n{\n    return __GET_PROPERTY(unsafeObject);\n}\n\n- (void)setUnsafeObject:(NSObject *)unsafeObject\n{\n    __SET_UNSAFE_UNRETAINED(unsafeObject);\n}\n```\n\n### assign\n区别于上面针对对象的`unsafe_unretained `和`assign`语义，这里的`assign`特指对原始类型的属性修饰符。由于Runtime的Associated Object一定是一个Object，因此我们需要把原始类型进行装箱，封装为一个Object，在getter中拆箱，拿到真实的原始数据。这个过程由于我们一定是一个Object箱子，只装一个真实的原始数据，因此没有必要进行copy（箱子是唯一的，但是内容的原始数据来源是copy by value）。可以用`strong`来修饰。\n\n对于不同的原始类型，装箱的方式不同，一般来说，对于数值类型（int、double、NSInteger），可以使用NSNumber来装箱。对于其他类型，比如结构体，可以使用NSValue来进行装箱（比如CGRect，NSRange, Pointer）。对于不同的装箱来说方式不同，因此不好在宏里面进行处理，直接接收一个装好箱的value就可以了。\n\n宏：\n\n```objectivec\n#define __SET_ASSIGN(property, value) objc_setAssociatedObject(self, @selector(property), value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n```\n\n由于装箱方式不同，拆箱方式肯定不同。不过只要拿到箱子之后，自己根据类型来进行相应拆箱即可。\n\n示例：\n\n```objectivec\n@property (nonatomic, assign) int age;\n@property (nonatomic, assign) CGRect frame;\n\n- (int)age\n{\n    NSNumber *value = __GET_PROPERTY(age);\n    return value.intValue;\n}\n\n- (void)setAge:(int)age\n{\n    __SET_ASSIGN(age, @(age));\n}\n\n- (CGRect)frame\n{\n    NSValue *value = __GET_PROPERTY(frame);\n    return value.CGRectValue;\n}\n\n- (void)setFrame:(CGRect)frame\n{\n    NSValue *value = [NSValue valueWithCGRect:frame];\n    __SET_ASSIGN(frame, value);\n}\n```\n\n### weak\n`weak`属性指的是一个弱引用，不改变对象的引用计数，同时和`assign`和`unsafe_unretained`的最大区别，在于有着自动置nil的安全性质。一旦weak对象被销毁，该引用不会成为一个野指针，而会被立即置为nil，保证了安全。对于如今的现代Objective-C，能表示弱引用全部使用weak，应当避免使用`assign`和`unsafe_unretained`表示一个弱引用（就算考虑上性能问题，weak立即置nil采用了一个全局的weak表，由Runtime管理，开销和手动release基本一致，不太可能成为性能问题）。\n\n由于`weak`的特殊性（全局weak表），关联对象本身就没有提供weak的语义行为，但是我们可以来模拟一个等价的行为。\n\n**第一种解决方案：**\n我们使用一个WeakContainer，只包含一个weak的属性，来存放真实的weak引用对象。这样，通过关联对象把整个WeakContainer关联到Category的属性上，然后存取使用的时候进行装箱和拆箱，解决方案即可。不过唯一的缺点是由于需要引入一个WeakContainer类，无法做到Header Only。\n\n```objectivec\n@interface WeakObjectContainer : NSObject\n\n@property (nonatomic, weak) id object;\n\n+ (instancetype)containerWithObject:(id)object;\n\n@end\n\n@implementation WeakObjectContainer\n\n+ (instancetype)containerWithObject:(id)object\n{\n    WeakObjectContainer *container = [[WeakObjectContainer alloc] init];\n    container.object = object;\n    return container;\n}\n\n@end\n```\n\n宏：\n\n```objectivec\n#import \"WeakObjectContainer.h\"\n#define __SET_WEAK(property) objc_setAssociatedObject(self, @selector(property), [WeakObjectContainer containerWithObject:property], OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n#define __GET_WEAK(property) [objc_getAssociatedObject(self, @selector(property)) object];\n```\n\n\n**第二种解决方案：**\n\n为了做到Header only，我们需要借助一个匿名的block，首先定义一个weak引用指向属性值，然后block捕获它。这样子，只要把block关联到对象上，那么在getter的时候，通过直接执行block返回这个weak对象，就可以拿到真正的弱引用（实现时，block要用copy，而且要判空）。\n\n宏：\n\n```objectivec\n#define __SET_WEAK(property) id __weak __weak_object = property; \\\n  id (^__weak_block)() = ^{ return __weak_object; }; \\\n  objc_setAssociatedObject(self, @selector(property), __weak_block, OBJC_ASSOCIATION_COPY);\n\n#define __GET_WEAK(property) objc_getAssociatedObject(self, @selector(property)) ? ((id (^)())objc_getAssociatedObject(self, @selector(property)))() : nil;\n```\n\n示例：\n\n```objectivec\n@property (nonatomic, weak) id delegate;\n\n- (id)delegate\n{\n    return __GET_WEAK(delegate);\n}\n\n- (void)setDelegate:(id)delegate\n{\n    __SET_WEAK(delegate);\n}\n```\n\n### 自定义存取方法\n自定义存取方法一般类的属性写法类似。比如说想要惰性初始化（即只有在第一次调用getter的时候，才会初始化属性）这里就不用`_name`来操作ivar，而是通过setter（当然也能用`__SET_* `宏来直接操作关联对象）就可以了。\n\n示例：\n\n```objectivec\n- (NSString *)name\n{\n    NSString *name = __GET_PROPERTY(name);\n    if (!name) {\n        name = @\"foo\";\n        [self setName:name];\n    }\n    return name;\n}\n\n- (void)setName:(NSString *)name\n{\n    __SET_COPY(name);\n}\n```\n\n# 隐藏内部方法\n\n## 类扩展实现类的内部方法\nObjective-C没有真正意义上的私有方法，毕竟是C语言的超集嘛。但是Objective-C提供了一个类扩展语法，允许定义方法的接口。因此，只要我们在.m实现文件中定义了一些内部方法，就可以对外隐藏（当然，class-dump selector这些是可以直接调用的）\n\n```objectivec\n// Person.m\n\n@interface Person ()\n\n- (void)internalMethod;\n\n@end\n\n@implementation Person\n\n- (void)internalMethod\n{\n    //...\n}\n\n@end\n```\n\n# 隐藏私有方法\n\n## 分类实现类的私有方法\n\n但一些情况下，我们需要很多库内部使用的类的私有方法（私有方法和内部方法虽然都不对外可见，但是其实目标不一样，私有方法一般是一些可以直接设置实例的状态，内部数据的危险方法，用于库内部的一些类之间，互相调用来使用。而内部方法一般放一些复杂流程处理，工具方法，是为了简化代码逻辑而使用的）这些方法需要和公开头文件的方法分开，保持对外隐藏。这时候就得用到Category。\n\n我们可以把想要隐藏的私有方法，全部放到一个Private Category里面，库内部其他需要操作的地方，引用这个头文件即可。\n\n```objectivec\n// Person+Private.h\n\n@interface Person (Private)\n\n- (void)privateMethod;\n\n@end\n\n// Person+Private.m\n@implementation Person (Private)\n\n- (void)privateMethod\n{\n    //...\n}\n\n@end\n```\n\n## 暴露公开类的内部方法\n对于公开类，我们有可能在实现中定义很多内部的方法，这些方法可能依赖一些上下文，或者是只在类扩展里面定义的属性（而不是在我们的Private分类里面）。当我们在库的其他地方，也想使用这些内部方法时，但是方法定义不在Private Header中（虽然实际上在类内部已经实现了）。我们需要一种方式来暴露类的内部方法。\n\n```objectivec\n//Person.m\n\n- (void)publicMethod\n{\n    //...\n    [self internalMethod];\n}\n//我们想暴露这个方法给其他引用了Private Header的地方使用\n- (void)internalMethod\n{\n    //...\n}\n```\n\n**第一种解决方案（错误示范）：**\n\n使用一个Private Category，在头文件中暴露这个方法。但是由于是类本身而不是Category的方法，编译器会报找不到`internalMethod`的实现的warning（虽然它确实在本身的类中实现了）。我们是可以警告编译器，忽略warning，因为你知道实际上这个方法已经有了实现，只不过头文件没有暴露罢了。但是这种方法忽略警告，会忽略所有Private Category的方法检查，假如Person+Private.h中定义的方法真的没有在Person+Private.m中实现，也不会有任何警告，所以非常不推荐。\n\n```objectivec\n//Person+Private.h\n\n@interface Person (Private)\n\n- (void)internalMethod; //在类本身实现中的内部方法，想要暴露出去\n- (void)privateMethod;\n\n@end\n\n//Person+Private.m\n\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wincomplete-implementation\"\n@implementation Person (Private)\n//...\n@end\n#pragma clang diagnostic pop\n```\n\n**第二种解决方案：**\n\n使用类拓展（而不是Private Category）来暴露一个内部方法，实际上这才是最佳的方式，因为类扩展并不局限于任何地方，而且可以在任何.h或者.m中进行声明。实际上，类扩展只有@interface而不能有@implementation，是方法的接口而不是实现，不会出现方法重定义或者覆盖的问题。这样，我们在类扩展中加入实际类的内部方法即可。\n\n```objectivec\n//Person+Private.h\n\n@interface Person ()\n\n- (void)internalMethod;\n\n@end\n\n@interface Person (Private)\n\n- (void)privateMethod;\n\n@end\n\n//Person+Private.m\n@implementation Person (Private)\n//...\n@end\n```\n\n因为类扩展在编译器检查时，是需要对类本身实现的方法进行检查的，因此假如Person类本身没有实现internalMethod，编译器会报warning，这也保证了正确性。\n\n\n# 总结\n\nObjective-C毕竟已经几十年的语言了，语法层面上对抽象隐藏支持的就不好，不像Swift提供了四种访问控制关键字：`public`、`internal`、`fileprivate`、`private`，而且支持Module，再也不用担心命名和重定义问题了。不过Swift的现状，在Swift 4.0 ABI还不能稳定的情况下，代码库分发就只能使用源代码，这点对于很多开发者还有企业的影响确实比较大。不过了解Objective-C的实现也不是什么坏事，毕竟谁不定总会有需要写的的时候。希望这些代码库的接口与实现隐藏的方法，能够帮到一些平时没有接触过代码库开发的人吧。\n\n# 资料\n1. [完整Category属性宏](https://gist.github.com/dreampiggy/2f2da443874b329a2f5d12f546a7a0cf)","categories":["iOS"],"tags":["iOS","Objective-C"]},{"title":"Promise大法好","url":"/2016/03/30/Promise%E5%A4%A7%E6%B3%95%E5%A5%BD/","content":"\n# Promise简介\n\nPromise是一种解决异步回调问题而发展的编程语言特性，在各种语法中都有支持，比如在JavaScript（ECMAScript 6）／Java（8）／Node.js（0.12）都有原生的支持，而没有原生支持的语言更可以通过第三方框架来简单引入（比如大名鼎鼎的[Q][1]）\n\n## 为什么说异步回调不是好的解决方案\n\n1\\.Callback Hell\n\n```javascript\nloadScript(\"a.js\",function(){\n    loadScript(\"b.js\",function(){\n        loadScript(\"c.js\",function(){\n            loadScript(\"d.js\",function(){\n                loadScript(\"e.js\",function(){\n                    console.log(\"Fuck to load async files\")\n                }\n            })\n        })\n    })\n})\n```\n\n2\\.依赖习惯编码\n\n```javascript\nfunction asyncFunc(callback){\n    doSomething(function(err, result){\n        if(err){\n            callback(err, null);\n        }\n        callback(null, result);\n    })\n}\n\nasyncFunc(function(err,result){\n    if(err){\n        console.error(err);\n    }\n    console.log(result);\n})\n\nanotherAsyncFunc(function(result,err){\n    if(result){\n        console.log(\"Fuck why the first is result\");\n    }\n})\n```\n\n还有种种，比如控制流难以书写（多个不同异步任务的条件判断和进度控制），try/catch无法捕获回调异常…………种种原因逼迫人们选择更好的解决方案\n\n## Promise的核心\n\n> 此处以Node.js（v0.12）为例，部分术语可能不同编程语言实现时不同，在JavaScript中，Promise是一个内置对象\n\n~~友情提示：以下东西仅为装逼，可跳过~~\n\n1.  三种状态：  \n    `fullfied`：被`resolve`后的状态  \n    `rejected`：被`reject`后的状态  \n    `pending`：初始状态\n\n2.  两个调用：  \n    `then(onFulfilled, onRejected)`：在被`resolve`后执行`onFulfilled`函数,而被`rejected`后执行`onRejected`函数。并且实际上每次调用Promise的`then`都会返回一个`新的`Promise对象  \n    `catch(onRejected)`：`then(undefined, onRejected)`的语法糖，被`rejected`后执行`onRejected`函数\n\n3.  状态转变：  \n    `resolve(value)`：语法糖，返回一个立即被`fullfied`且转变为`fullfied`状态的Promise对象，等价于：\n    \n```javascript\nnew Promise(function(resolve){\n    resolve(value);\n});\n```\n\n\n`reject(value)`：语法糖，返回一个立即被`resolve`且转变为`rejected`的Promise对象，等价于：\n\n```javascript\nnew Promise(function(resolve){\n    resolve(value);\n});\n```\n    \n\n1.  控制流：  \n    `Promise.all([promise1, promise2, ...])`：当`全部`Promise对象被`resolve`时调用`then(onFulfilled(value))`（value为数组的值）；或者任何一个Promise对象被`reject`时调用`catch(onRejected)`  \n    `Promise.race([promise1, promise2, ...])`：当`任何`Promise对象被`resolve`或者`reject`时调用`then(onFulfilled(value))`或者`catch(onRejected)`\n\n## Promise的简单用法\n\n1\\.Easy Mode\n\n```javascript\nfunction asyncFunction() {\n    if (1 === 1){\n        return Promise.resolve(\"OK\");\n    }\n    else{\n        return Promise.reject(new Error(\"Wrong\"));\n    }\n}\n\nasyncFunction().then(function(val){\n    console.log(val);\n}).catch(function(err){\n    console.error(err);\n})\n\n/*\nOK\n*/\n```\n\n2\\.Normal Mode\n\n```javascript\nasyncFunction().then(function(val){\n    console.log(val);\n    return \"First\";\n}).then(function(val){\n    console.log(val);\n    return \"Second\";\n}).then(function(val){\n    throw new Error(\"Fuck\");\n    console.log(val);\n}).catch(function(err){\n    console.error(err);\n})\n\nconsole.log(\"Start!\");\n\n/*\nStart\nOK\nFirst\n[Error: Fuck]\n*/\n```\n\n3\\.Hard Mode\n\n```javascript\nfunction anotherAsyncFunction(){\n    if (2 != 2){\n        return Promise.resolve(\"OK\");\n    }\n    else{\n        return Promise.reject(new Error(\"Wrong\"));\n    }\n}\n\nPromise.all([asyncFunction(),anotherAsyncFunction()]).then(function(val){\n    console.log(\"All:\" + val);\n}).catch(function(err){\n    console.error(\"All:\" + err);\n});\n\nPromise.race([asyncFunction(),anotherAsyncFunction()]).then(function(val){\n    console.log(\"Race:\" + val);\n}).catch(function(err){\n    console.error(\"Race:\" + err);\n});\n\n/*\nRace:OK\nAll:Error: Wrong\n*/\n```\n\n# 后话\n\n拥抱Promise，告别Callback，你我值得拥有。连古老的OO圣教——Java大法都拥抱Lambda和Promise，你还在等什么？\n\n```java\npublic F.Promise<JsonNode> post(String formData){\n   WSRequest request = client.url(url);\n   F.Promise<WSResponse> responsePromise = request\n           .setContentType(\"application/x-www-form-urlencoded\")\n           .post(formData);\n   F.Promise<JsonNode> jsonNodePromise = responsePromise.map(value -> {\n       return value.asJson();\n   });\n\n   responsePromise.onFailure(error -> {\n       Logger.error(error);\n   });\n\n   return jsonNodePromise;\n}\n```\n\n[1]: https://github.com/kriskowal/q","categories":["JavaScript"],"tags":["JavaScript","异步"]},{"title":"Random Binary Search Tree －Treap","url":"/2016/03/30/Random-Binary-Search-Tree-%EF%BC%8DTreap/","content":"\n## BST插入顺序与平衡性\n\n众所周知，二查搜索树(BST)的搜索、插入、删除的复杂度等于树高，所以平衡度越高，越接近$ O(nlogn) $，越有序越退化为$ O(n) $\n\n![线性BST](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/3/9f/4b2394fd756bcf2edcee109bb18ef.png)\n![随机BST](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/e/a2/3419e63d7126ece4996634b3f7dad.png)\n\n+ 对于左侧的BST来说，只有唯一的构造序列：$ <1,2,\\dots,14> $\n+ 但对于右侧的BST，可以存在21964800种不同序列\n\n也就是说，随即插入序列到二叉树所形成的平衡度，将大于部分有序插入所形成的二叉树\n\n形式化证明可以得到（具体证明过程，参见[Open Data Structures][3]：\n\n对每个$ x \\in{0,\\ldots,{n}-1} $, x所需要的搜索长度（即深度）是 $ H\\_{x+1} + H\\_{n-x} - O(1) $\n\n对每个$ x \\in(-1,n) $，x所需要的搜索长度是$ H\\_{\\lceil x \\rceil} H\\_{n-\\lceil x \\rceil} $\n\n## Treap - Random BST实现\n\n> [Treap-wikipedia][4]\n\nTreap，顾名思义，就是`Tree`和`Head`的结合体，除了要满足BST的要求外，还需要满足堆的要求，即\n\n1.  `BST`: 对每个结点，左子女的值 < 根的值 < 右子女的值\n2.  `Heap`: 对除了跟结点的每个结点，双亲结点的优先级要小于该结点的优先级\n\n所以Treap的每个结点除了包括BST结点的值value外，还需要包括一个唯一的优先级p\n\n比如这样就是一个典型的Treap，每个结点表示为(value,p) ![Treap][5]\n\n并且可以证明，由Heap的约束，最小优先级将成为根结点，而BST又保证了小于根的值将在左子树上，大于根的值在右子树\n\n由于Heap的约束，我们可以认为Treap是按照优先级排序插入BST的，比如上述Treap可以由以下序列构造\n\n$ (3,1), (1,6), (0,9), (5,11), (4,14), (9,17), (7,22), (6,42), (8,49), (2,99) $\n\n## 旋转\n\n为了确保`Heap原则`，那么就需要对树进行旋转，在旋转中同时还要确保`BST原则`，比如这样的例子：\n\n![BST旋转][6]\n\n对w.value < u.value，旋转将交换w和u的父子关系，同时将把原来的B放在新的儿子上。比如右旋，可以看作左旋和右旋是一个对称的操作\n\n```cpp\nvoid rotateRight(Node *u) {\n    Node* w = u->left;\n    w->parent = u->parent;  //parent -> w\n    if (w->parent != NULL) {\n        if (w->parent->left == u) { //u is left or right\n            w->parent->left = w;\n        } else {\n            w->parent->right = w;\n        }\n    }\n    u->left = w->right; //u.left = B\n    if (u->left != NULL) {\n        u->left->parent = u;    // B.parent = u\n    }\n    u->parent = w;  // w.right = u\n    w->right = u;\n    if (u == root) {   //if u is root\n        root = w;\n        root->parent = NULL;\n    }\n}\n```\n\n## 添加/删除\n\n*   添加\n\n比如，对上述的Treap，加入一个值1.5，生成的优先级为4，即插入结点为(1.5,4)。首先使用BST的Add，插入在(2,99)的左子女上。为了满足`Heap规则`，依次进行以下旋转：\n\n99 > 4 =>右旋;  \n6 > 4 => 左旋;  \n1 < 4 => 停止;\n\n![Treap插入][7]\n\n由前面的引理，可以知道，旋转的次数为$ 2ln(n) + O(1) $，复杂度为$ O(logn) $\n\n*   删除\n\n核心基本为添加的逆操作，对上述的Treap，删除一个结果(9)，那么将删除结点(9,17)。首先使用BST的Find，找到value为9的结点，然后将以(9,17)开始，向下不断旋转，直到最终为叶结点，然后把这个叶子剪去(Cut down)。\n\n旋转原则：\n1. left = NULL & right = NULL ，不动\n2. left = NULL，左旋(right = NULL则右旋) `注:原文这里描述写反了`\n3. left.p < right.p，右旋(right.p < left.p则左旋)\n\n依次进行以下旋转：\n\nright = NULL => 右旋;  \nright = NULL => 右旋;  \n叶结点 => 停止;\n\n![Treap删除][8]\n\n和添加相反，复杂度为$ O(logn) $\n\n## 复杂度\n\n`构造`: $ O(logn) $ `查找`: $ O(logn) $ `添加`: $ O(logn) $ `删除`: $ O(logn) $\n\n虽说都是$ O(logn) $，但是对比另一种高级数据结构[Skip List(跳表)][9]，查找复杂度在常数上有不同：\n\n`Skip List`: $ elnn + O(1) \\approx 1.884log(n) + O(1) $ `Treap`: $ 2ln(n) + O(1) \\approx 1.386log(n) + O(1) $\n\n## 代码\n\n> 完整版C++实现，这里面的随机优先级，直接使用了value当种子srand()然后rand()获取随机数……（先进行BST的Add，确保value不会重复），实际中可以采用其他随机数方式获得更好的期望复杂度 （吐槽……开始没注意这是Java版伪代码，以后一定用Java或者JavaScript写……指针地狱）\n\n代码链接：[Treap][10]\n\n\n [3]: http://opendatastructures.org/ods-java/7_1_Random_Binary_Search_Tr.html#fig:rbst-records\n [4]: https://en.wikipedia.org/wiki/Treap\n [5]: http://opendatastructures.org/versions/edition-0.1e/ods-java/img1086.png\n [6]: http://opendatastructures.org/versions/edition-0.1e/ods-java/img1102.png\n [7]: http://opendatastructures.org/versions/edition-0.1e/ods-java/img1108.png\n [8]: http://opendatastructures.org/versions/edition-0.1e/ods-java/img1114.png\n [9]: https://en.wikipedia.org/wiki/Skip_list\n [10]: http://www.dreampiggy.com/source/413-2/","categories":["Code"],"tags":["C++","数据结构"]},{"title":"React-Native -- 下一代UI编程思维","url":"/2016/03/30/React-Native-%E4%B8%8B%E4%B8%80%E4%BB%A3UI%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4/","content":"\n# React-Native VS Cocoa Touch -- 下一代UI编程思维\n\n## React 与状态\n\n`React.js`自从Facebook一推出，就受到Web前端工程师的强烈推崇。虽说曾经火过一时的`Angular.js`颠覆了前端的工程，但是`React`更多颠覆的，是下一代UI编程的思维。\n\n传统UI编程，基本很多地方都需要将数据来源，绑定到对应的UI对象，比如用户点击了一个操作，更改了名称，那么你需要更新执行一个回调函数来处理点击操作，并且把新的数据更新原有的UI对象的属性，比如大概就是这样的东西\n\n```swift\nfunc onClick(sender) {\n    var data = getData(sender);\n    self.button.title = data.name;\n    self.button.color = data.color;\n}\n```\n\n这样虽然说直观，但是有很大的问题。试想，假如有很多种的回调函数，每个回调函数监听不同的操作，比如`onMounseDown`,`onMouseUp`,`onKeyDown`,`onScroll`……甚至根据不同的sender，我们会有不同的操作，我们就必须得手写很多机械的\n\n```swift\nself.xx = data.xx\nself.xy = data.xy\n```swift\n    \n\n这类的代码，这就给日后维护和扩展带来了灾难，假如我要换一个UI组件，又得一个个检查是否赋值成功；假如我要把这个UI组件在新的UIView里面重用，我又得改动所有的赋值代码，对于大型项目这种UI对象成百上千，UI属性上万，这样是非常可怕的。\n\n而`React`，就将所有的赋值，数据绑定，抽象成为一个个状态，不同的事件监听，就是不同的状态而已，而这些状态之间相互独立，不会受到某些全局变量更改而造成UI混乱的情况，更好的是，开发者不需要考虑到底这个属性什么时候赋值，是在数据更新之前还是之后，需不需要定时刷新这种无意义的苦力活上。\n\n## React-Native VS Cocoa Touch\n\n> 完整代码：[Tutorial][1]\n\n看看`React-Native`的sample，需求就是实现一个电影列表显示的View。类似这样：\n\n![iOS][2] ![Android][3]\n\n这段代码中，只有View和ViewModel（Model就是临时的JSON），React用状态把UI属性和数据绑定起来，从而避免了事件监听手动判断时机来赋值\n\n```jsx\nvar AwesomeProject = React.createClass({\n  //初始状态，不渲染\n  getInitialState: function() {\n    return {\n      dataSource: new ListView.DataSource({\n        rowHasChanged: (row1, row2) => row1 !== row2,\n      }),\n      loaded: false,\n    };\n  },\n\n  //模型层变动导致状态改变，渲染\n\n  fetchData: function() {\n    fetch(REQUEST_URL)\n      .then((response) => response.json())\n      .then((responseData) => {\n        this.setState({\n          dataSource: this.state.dataSource.cloneWithRows(responseData.movies),\n          loaded: true,\n        });\n      })\n      .done();\n  },\n\n  //渲染层，绑定状态和UI属性\n\n  render: function() {\n    return (\n      <ListView //这里是JSX语法，在JS里面返回标签\n        dataSource={this.state.dataSource}\n        renderRow={this.renderMovie}\n        style={styles.listView}\n      />\n    );\n  }\n }\n```\n\n> 完整代码：[iOS Demo][4]\n\n相比来说，原生Cocoa Touch的实现，就要丑陋的多了，尤其是渲染部分绑定UI对象的属性和数据来源，假如你有多处数据来源，多种UI属性，你就得写很多判断来保证你的UI对象的属性符合预期的赋值顺序。\n\n```swift\n//初始化UI对象，调用模型去获取数据\noverride func viewDidLoad() {\n   super.viewDidLoad()\n   fetchData()\n}\n\n//获取数据，需要手动维护状态，比如开启indicator(旋转等待条)，数据获取成功后渲染\nfunc fetchData() {\n   indicator.startAnimating()\n   request(.GET, API_URL, parameters: [\"apikey\": API_KEY, \"page_limit\": PAGE_SIZE])\n       .responseJSON{ _, _, data, _ in\n           self.render(JSON(data!))\n   }\n}\n\n//渲染UI对象，需要手动维护状态，比如关闭indicator(旋转等待条)\nfunc render(result:JSON) {\n   indicator.stopAnimating()\n   movieJSON = result\n   self.tableView.reloadData()\n}\n\n//这都算好的了，TableView会自动回调你的代码，返回这个TableView里面的Cell个数\nfunc tableView(tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n   var movieNum = movieJSON[\"movies\"].arrayValue.count\n   return movieNum\n}\n\n//可怕的地方，需要手动赋值给UI对象的属性\nfunc tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell {\n   let cell = self.tableView.dequeueReusableCellWithIdentifier(\"movieIdentifier\", forIndexPath: indexPath)\n        as! MovieTableViewCell\n\n   let row = indexPath.row\n\n   //手动维护状态，JSON解析再赋值给对应的UI对象，这里省略了UI对象的代码和样式\n   //（一般可以通过Interface Builder做或者专门一个类写UI代码）\n   cell.movieTitle.text = movieJSON[\"movies\"][row][\"title\"].stringValue\n   cell.movieYear.text = movieJSON[\"movies\"][row][\"year\"].stringValue\n   var movieImageUrl = movieJSON[\"movies\"][row][\"posters\"][\"thumbnail\"].stringValue\n\n   //最可怕是渲染中还需要新的数据，再回调模型，就很难维护了\n   if cell.movieImage.image == nil {\n       request(.GET, movieImageUrl).response{ _, _, data, _ in\n           let movieImage = UIImage(data: data as! NSData)\n           cell.movieImage.image = movieImage\n       }\n   }\n\n   return cell\n}\n```swift \n\n# React 与函数式\n\n`React`更多的，就是一种类似函数式的想法，把UI对象属性，数据来源，当作一个Monad包裹起来，传统意义上的不同数据来源进行UI属性赋值，相当于这个Monad经过不同的函数作用，达到状态的切换，好处就是大大减少了开发者手动维护UI属性的工作，而且可以达到更高的开发效率。而且再也不怕扩展了，因为这时候可以把多个组件分配给不同的人，每个人完全不需要管别人内部的变量名是什么，UI属性是什么，只要把自己的状态管理好，Model层接口统一，剩下的合并即可。\n\n# React 与效率\n\n既然提到了状态，因为`React`采取`VirtualDOM`来diff需要进行状态更新的UI对象，每次确保了只更新属性发生改变的部分。实现也很高效，使用了一个普通的二叉树`vtree`。每个结点`vnode`就是对应的Tag，比如<Image>之类，结点还存储了一个struct用来保存这些Tag的属性（比如Image的size）\n\n其中的diff算法可以一看……代码地址在：[GitHub-vtree][5]\n\n```javascript\n//主要逻辑，就是对b树进行reorder，找出a树与b树的同结点不同属性的diff\n//剩下可以无痛patch的部分只需要下面的for循环就可以处理\nvar aChildren = a.children\nvar orderedSet = reorder(aChildren, b.children)\nvar bChildren = orderedSet.children\n\nvar len = aLen > bLen ? aLen : bLen\n\nfor (var i = 0; i < len; i++) {\n   var leftNode = aChildren[i]\n   var rightNode = bChildren[i]\n   index += 1\n\n   if (!leftNode) {\n       if (rightNode) {\n           //这里处理的多余的结点，直接加到b树上即可\n           apply = appendPatch(apply,\n               new VPatch(VPatch.INSERT, null, rightNode))\n       }\n   } else {\n       walk(leftNode, rightNode, patch, index)\n   }\n}\n```\n\n这是核心reorder代码，目标找到是同一结点不同属性的diff，多出来的不需要管\n\n```javascript\n//遍历a树，如果b树中结点集合含有a的key，标记下b树中这些key，更新旧的标记\nfor (var i = 0 ; i < aChildren.length; i++) {\n   var aItem = aChildren[i]\n   var itemIndex\n\n   if (aItem.key) {\n       if (bKeys.hasOwnProperty(aItem.key)) {\n           // Match up the old keys\n           itemIndex = bKeys[aItem.key]\n           newChildren.push(bChildren[itemIndex])\n\n       } else {\n           // Remove old keyed items\n           itemIndex = i - deletedItems++\n           newChildren.push(null)\n       }\n   }\n   //......\n    }\n\n\n//遍历b树，添加上面标记的所有key到一个集合，暂时未排序\nfor (var j = 0; j < bChildren.length; j++) {\n   var newItem = bChildren[j]\n   if (newItem.key) {\n       if (!aKeys.hasOwnProperty(newItem.key)) {\n           newChildren.push(newItem)\n       }\n       //......\n }\n\n//对上述集合，真实的b树删除多余结点，直到上述集合为空为止，复杂度O(n)\nvar simulate = newChildren.slice()\n\nfor (var k = 0; k < bChildren.length;) {\nvar wantedItem = bChildren[k]\nsimulateItem = simulate[simulateIndex]\n\n//最后删除剩下虚拟的结点\nwhile(simulateIndex < simulate.length) {\n   simulateItem = simulate[simulateIndex]\n   removes.push(remove(simulate, simulateIndex, simulateItem && simulateItem.key))\n}\n```\n\n整体的复杂度，达到了O(M+N)，已经是理论下界了。比起手动管理状态来说，效率可以说是直接持平，甚至对部分滥用事件监听的写法效率会更高。\n\n# 总结\n\n虽然我并不喜欢UI编程，但是自从图形化出现之后，UI已经成为了继数据结构、算法外，面向终端用户的应用又一个大工程。\n\n从最早的指令式跳转赋值UI，函数指针响应处理，到中期的面向对象，消息发送回调事件，手动管理属性，在到如今的React以状态和VirualDOM来绑定数据和组件。\n\nUI编程其实也是在不断进化的，也许今后会有更好的开发方式让我们这群不会写UI的人也能够轻松写起来UI。\n\n [1]: https://facebook.github.io/react-native/docs/tutorial.html#content\n [2]: https://facebook.github.io/react-native/img/TutorialFinal.png\n [3]: https://facebook.github.io/react-native/img/TutorialFinal2.png\n [4]: https://github.com/lizhuoli1126/iOS-Demo-Project\n [5]: https://github.com/Matt-Esch/virtual-dom/blob/master/vtree/diff.js","categories":["iOS"],"tags":["Swift","JavaScript","ReactJS"]},{"title":"React Native之Redux架构入门","url":"/2016/10/26/React-Native%E4%B9%8BRedux%E6%9E%B6%E6%9E%84%E5%85%A5%E9%97%A8/","content":"\n> 如今也是入了移动iOS开发的坑，最近不仅学习了Core Animation的部分知识，还接触到React Native，这一Facebook出品的React for Native Platform框架，其中React本身入门是相对简单的，而Redux入门就相对困难了，因此在这里总结一下，最后有自己写的Slides可以参考\n\n# 背景\n\n> 为什么需要Redux\n\n1. RN的state（可变，子组件不可见）和props（不可变，子组件可见）的设计，在面对大型项目时候，容易因为不经意修改state造成状态混乱，组件渲染错误\n2. RN使用了Virtual DOM，不需要Target绑定->Action修改UI属性，只要当状态变化，render新状态下的组件，数据单向传递，而MVC的设计模式存在双向数据流\n3. RN不易进行测试，Redux提供了非常方便的mock测试方式\n\n# 准备\n\n```bash\n安装Redux：\n\tnpm install --save redux\n安装React Native和Redux绑定库：\n\tnpm install --save react-redux\n安装Redux Thunk异步Action中间件：\n\tnpm install --save redux-thunk\n```\n\n# Redux 原则\n\n1. 单一数据源\t\n\t**描述：** 整个应用的 state 被储存在一个对象树中，对象树存在于唯一的 store 中\t\n\t**说明：** Redux把所有state集中管理，避免了各处临时的状态造成的不可控\n2. State 是只读的\t\n\t**描述：** 惟一改变 state 的方法就是触发 action\t\n\t**说明：** action 是一个含有 type 属性的普通JS对象，type 属性可以用具体的string常量，来表示事件\n3. 使用纯函数来执行修改\t\n\t**描述：** 编写 reducers 来描述对应action如何修改 state\t\n\t**说明：** reducer函数是纯函数，无副作用，定义为reducer(state, action) => newState，一般可以用 switch(action.type) 来判断不同的action，同时return一个新的state\n\t\n# Redux 数据流\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/6/ac/b29d443e4577ad15dd62c800c5fc4.png)\n\n\n1. Component触发一个Action Creator（用来dispatch某个具体的Action的函数），dispatch到Store中\t\n2. Reducer进行判断，通过(state, action) => newState得到新的状态，写回到Store中\t\n3. Store绑定到Component，把state赋回Component的props，然后Component就可以render了，整个流程也比较清晰\t\n\n# Action\n\nAction是一个普通JS对象，至少包括一个`type`属性代表事件，其他属性可以用来传递数据。实践上对一个流程定义一个函数，流程可以包括网络请求，最后返回Action，这个函数叫Action Creator\n\nType:\n\n```js\nconst ADD_TODO = 'ADD_TODO';\n```\n\nAction：\n\n```js\nlet action = { type: ADD_TODO, text: 'Build my first Redux app' }\n```\n\nAction Creator：\n\n```js\nfunction addTodo(input) {\n\treturn { type: ADD_TODO, text: input }\n}\n```\n\n举例：\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/a/b8/1e6f0b3d3f531817fb9bf7aed7ad3.png)\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/2/5c/d3050cfb96161668957d6b51fe00a.png)\n\n# Reducer\n\nReducer是一个函数，根据Store中的前一次的state，和Store中被dispatch过来的Action，返回一个新的state并写入Store，即： `(state, action) => newState`\n\nReducer：\n\n```js\nfunction toDoReducer(state, action) {\n\tswitch(action.type) {\n\t\tcase ADD_TODO:\n\t\t\treturn {text: action.text,completed: false}\n\t\tdefault:\n\t\t\treturn state;\n\t}\n}\n```\n\n注意：\n\n1. 返回的是新state，如果需要保留部分旧state值，使用…state（ES7的对象展开语法，对对象会浅拷贝对应属性，这里等价于Object.assign({}, state, newState)），对应合并state的话只会合并一层，而子属性会被覆盖掉，对复杂state需要手动合并\n2. 为了遵循Reducer的纯函数性，不应该直接修改state的值，然后return state，除非使用Immutable.js（见后）\n3. 实际中，应当把不同模块的代码，构造不同的Reducer，最后再合并（因为纯函数性，无副作用）\n\n```js\nimport { combineReducers } from 'redux’;\nimport todos from './todos’;\nimport counter from './counter’;\nexport default combineReducers({ todos, counter })\n``` \n\n举例：\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/4/2d/bbcfa2df98958ec1a4c027b7a883e.png)\n\n# Store\n\nStore存储了一个Provider的`所有的state`，同时接收dispatch过来Action。Redux提供的每个Provider根组件有唯一对应的Store。实践中可以拆分多个业务模块到多个Provider组件，每个Provider组件利用Redux架构，绑定自己的Store，模块内的业务流程写到对应的Action Creator中\n\n\nStore：\n\n```js\nimport { createStore } from 'redux';\nimport reducer from './reducers/BusListReducer';\n\nconst store = createStore(reducer);\n```\n\n1. Store的读写，可以调用getState()来获取当前state，用dispatch()来分发Action改变state\n2. Store创建的时候，除了需要绑定Reducer，还可以应用中间件，比如日志中间件，React Thunk中间件（针对异步Action Creator）\t\n\n```js\nconst logger = store => next => action => {\n\tconsole.log('dispatching', action);\n\tlet result = next(action);\n\tconsole.log('next state', store.getState());\n\treturn result;\n}\n\nlet createStoreWithMiddleware = applyMiddleware([logger, thunk])(createStore);\n```\n\n举例：\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/e/c6/3c631d1a7bd31016e1fdf45e63428.png)\n\n# Component绑定\n\n整个控制流，就差最后Store中的state绑定到组件了，我们通过Redux提供的`connect()`，绑定需要的state以及Action Creator到你的组件的props上，这样组件就可以通过props来调用Action Creator，或者根据不同props来render()不同的组件\n\n\n```js\nfunction mapStateToProps(state) {\n  return {\n    name: state.name\n    age: state.age\n  }\n}\n\nfunction mapDispatchToProps(dispatch) {\n  return {\n    actions: bindActionCreators(actions, dispatch)\n  }\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(BusList);\n```\n\n1. 注意connect返回的就是绑定后的React Component，用的时候记得export default\n\n举例：\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/9/19/10bde796c214db134bb166bbac540.png)\n\n# State合并和Immutable.js\n\n> 为什么State合并很困难\n\n1. Reducer中，通过...state对象扩展符，再合并action的state，这种合并是一层合并，不会合并子属性而会直接覆盖掉，意味着对于复杂的state，如果想要修改子层级的属性，就得手动创建一个新的对象，并合并部分state的属性，而不是用…state直接扩展\n2. Reducer为了保持纯函数性，应当禁止对state直接修改部分属性，但直接…state的拷贝在大量项目state树庞大的情形下会有一定的效率影响\n3. 在1，2两条的情形下，如何在不修改原始state的前提上，又能返回一个原state属性部分变化后的newState就成了一个问题\n\n```js\nlet a = { b: { c: 4 } };\n\n// 等价写法\n// let g = Object.assign({}, a, {\n// \tb: { d: 5 }\n// });\nlet g = {\n\t...a,\n\tb: { d: 5 }\n}\n\nconsole.log(g); // { b: { d: 5 } }\n```\n\n> Immutable.js解决了什么\n\n1. Immutable.js的实现复杂不可变对象的高效copy和部分修改，内部通过Persistent Data Structure（持久化数据结构），即一个不可变的对象树。在使用旧数据创建新数据时，通过部分结构共享，如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享\n2. 这样既避免了DeepCopy造成的性能开销，又能达到所有返回的数据仍然是不可变的，符合了reducer(state,action) => newState的纯函数性\n\n> 具体如何实践配合Redux\n\n1. 对state中`部分复杂的属性`，可以使用Immutable的数据单独包裹，在组件render()处单独解包所有Immutable对象\n2. 如果state本身就含有各种复杂属性，可以直接`把state本身包裹`，用Immutable.Map表示state本身，然后通过Immutable的API操作修改部分属性，返回一个新的Immutable对象作为newState，在组件的mapStateToProps()方法中，把Immutable对象包裹的state解包为JavaScript的对象\n3. 对于其他组件，可以在`shouldComponentUpdate()`方法中，通过Immutable的比较，来避免无用的re-render\n\n举例：ListView简单应用（避免re-render)\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/e/8c/42c765d2eea6cb90e2eef9dfae949.png)\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/b/71/a6d9a50d4ff1c8eebbd462279c073.png)\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/7/db/e8fcbe8a12f6d2796e64a37e5c4ae.png)\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/9/7f/7b039ac17e7828a2fe4f3d033ad73.png)\n\n# 更多思考\n\n1. Action的定义规范？（对于不需要rerender的所有Action定义一个单独type？）\nReducer中state复杂多级结构，如何规范合并得到newState？（Immutable.js必要性）\n2. 大型组件的render方法解耦合方式（switch？）\n3. 移动端是否有服务端渲染的必要？（dispatch过去的Action如果需要复杂计算，把整个store交给服务端来计算）\n4. 网络请求使用fetch API封装是否足够？\n5. Native Module的JS端引入（callback？还是Promise + async await）\n6. Mock测试的具体实践？（Action，Reducer，Component三个方面）\n\n# Slides\n\n+ [React Native进阶-Redux架构和状态管理.pptx](https://raw.githubusercontent.com/dreampiggy/iOS-Resume/master/React%20Native%E8%BF%9B%E9%98%B6-Redux%E6%9E%B6%E6%9E%84%E5%92%8C%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.pptx)\n\n\n# 参考资料\n1. [React Native官方文档](http://facebook.github.io/react-native/docs)\n2. [Redux官方文档](http://redux.js.org)\n3. [Redux官方文档（中文）](http://cn.redux.js.org)\n4. [Immutable.js解析](https://github.com/camsong/blog/issues/3)\n5. [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)\n6. [Object Spread Syntax（对象展开符）](http://redux.js.org/docs/recipes/UsingObjectSpreadOperator.html)\n7. [React Native Redux架构参考](http://www.jianshu.com/p/14933fd9c312)","categories":["iOS"],"tags":["iOS","React Native","Redux"]},{"title":"Retroactive Data Structure","url":"/2016/03/30/Retroactive-Data-Structure/","content":"\n> MIT Open Course\n\n[MIT-retroactive-data-structure][1]\n\n# Time line\n\nInsert(time, ops); Delete(time, ops); Query(time, query);\n\nHow to insert ops into two times? -> BST || linked list\n\nHow to deal with side effect? -> save all the ops except `delete`\n\n`Partial Retroactive`\n\nQuery always done at present => time = $ \\infty $\n\n`Full Retroactive`\n\nQuery can done at whatever time\n\n# What about formal defination of partial & full\n\n$ query(t,A \\cup B) \\equiv f(query(t,A),query(t,B)) , f \\ is \\ O(1)$\n\n# Implementation\n\n`segment tree` : BST on time\n\n![title][2]\n\n`Commutative updates` => 可交换updates\n\n$ x.y = y.x $\n\n`Invertible updates` => 可逆updates\n\n$ x.x^{-1} = \\emptyset $\n\nDelete(time, ops) === Insert(now, ops^{-1})\n\n# Practice\n\nDynamic hashing\n\nPriority queue\n\n*   query will cost $ O(lgn) $\n*   store in BBST (balanced binary search tree)\n*   leaves : insert => store by time not value\n\nGeneral Transformation\n\n*   rollback: change r time in the past will cost $ O(r) $\n\n*   lower bound: $ \\Omega(r) $\n\n# More complicated - Non-oblivious Retroactive\n\nwhich means after one insert or delete ,you can get `the query that change`\n\n# Just a little bit code\n\n`retroactive queue`: [GitHub-Functional.js][3]\n\n\nReference: [Retroactive Data Structures - ERIK D. DEMAINE, JOHN IACONO, STEFAN LANGERMAN][4]\n\n [1]: http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-851-advanced-data-structures-spring-2012/lecture-videos/session-2-retroactive-data-structures/\n [2]: https://upload.wikimedia.org/wikipedia/commons/e/e5/Segment_tree_instance.gif\n [3]: https://github.com/lizhuoli1126/Functional.js#retroactivedata-structure\n [4]: http://erikdemaine.org/papers/Retroactive\\_TALG/paper.pdf","categories":["Code"],"tags":["数据结构"]},{"title":"Swift 调试性能的优化方案","url":"/2022/05/07/Swift-%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/","content":"\n# 声明\n\n此篇文章在字节跳动的技术公众号已经刊登：[《字节跳动DanceCC工具链系列之Swift调试性能的优化方案》](https://mp.weixin.qq.com/s/MTt3Igy7fu7hU0ooE8vZog)\n\n原作者是我自己（李卓立 @dreampiggy）而非抄袭，这里在个人博客同时转发一下，去掉了招聘相关文案。不过依旧欢迎大家有兴趣的有志之士加入。\n\n# **背景**\n\n通常来说，大型Swift项目常含有大量混编（Objc/C/C++甚至是Rust）代码，含有超过100个以上的Swift Module，并可能同时包含二进制部分和源码部分。而这种大型项目在目前的Xcode 13体验下非常不好，经常存在类似“断点陷入后变量面板卡顿转菊花”、“显示变量失效”等问题。而且一直存在于多个历史Xcode版本。\n\n图1：Xcode变量区显示卡顿转菊花，测试使用Xcode 13.3和下文提到的复现Demo\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-05-07/16519143337884.png)\n\n这部分Apple Team迟迟不优化的原因在于，Apple公司的内部项目和外部项目开发模式的巨大差异。Apple内部产品，如系统应用，系统库，会直接内嵌到iOS固件中，并直接受益于dyld shared cache（参考[WWDC 2017-App Startup Time: Past, Present, and Future](https://developer.apple.com/videos/play/wwdc2017/413/)[1]）来提升加载速度。这意味着他们通常会将一个App，拆分为一个薄的主二进制，搭载以相当多的动态链接库（Dynamic Framework），以及插件（PlugIn）的模式来进行开发。\n\n举个例子，我们以iOS的消息App（MobileSMS.app）为例子，使用iOS 15.4模拟器测试。可以看到其主二进制大小仅有844KB（x86_64架构）。通过`otool -L`查询链接，可以看到总计动态链接了22个动态链接库，其中有9个是非公开的，大都是支撑消息App的功能库，这些库占据了大量存储。\n\n图2：消息App的动态链接库列表\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-05-07/16519143337952.png)\n\n而iOS平台的第三方开发者的工程，为了追求更快的冷启动时长，由于没有了dyld shared cache的优化（dyld 3提出的启动闭包只能优化非冷启动），很多项目会使用尽量少的动态链接库。加之开源社区的CocoaPods，Carthage，SwiftPM等包管理器的盛行导致的Swift Module爆炸增长，预二进制的Framework/XCFramework包装格式的滥用，加之闭源三方公司的SDK的集成，最终形成了一个无论是体积还是符号量都非常巨大的主二进制，以及相当长的Search Paths。\n\n以公司内飞书应用的内测版为例子，在使用Debug，Onone模式编译，不剥离（Strip）任何符号情况下，可以看到其主二进制大小为1.1GB，动态链接库数量为105，但是仅包含Apple的系统库和Swift标准库。业务代码以静态链接库集成。\n\n图3：公司飞书应用的动态链接库列表\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-05-07/16519143338006.png)\n\n上述这两种不同的工程结构，带来了非常显著的调试体验的差异，并且Apple公司近年来的Xcode Team和Debugger Team优化，并没有完全考虑部分第三方开发者常使用的，厚主二进制下的工程结构。\n\nPS：理论上可以通过业务的工程结构的改造，在本地开发模式下，使用一个动态链接库包裹基础静态链接库的方式，减少主二进制大小（也会减少后续提到的DWARF搜索的耗时），但是大型项目推进工程结构的改造会是一个非常漫长的过程。\n\n图4：一种减少主二进制大小的工程结构设计\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-05-07/16519143338059.jpg)\n\n# 解决方案：自定义LLDB工具链\n\n经过调研，我们发现业界常见做法，无外乎这几种思路：\n\n1.  工程改造：缩减Swift Module/Search Path数量：可行，但是收益较低，且不可能无限制缩减\n2.  通过LLDB一些开关：可行，但是内部测试下依旧达不到理想的调试状态\n\n我们致力于在字节跳动的移动端提供基础能力支持，因此提出了一套解决方案，不依赖业务工程结构的改造，而是从LLDB工具链上入手，提供定向的调试性能优化。\n\n调研期间也确认到，借助自定义LLDB工具链，集成到Xcode IDE是完全可行的，包括iPhone模拟器、真机以及Mac应用。\n\n图5：自定义LLDB工具链的文件结构，系列后续文章会单独讲解，这里不展开\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-05-07/16519143338079.png)\n\n而LLVM/LLDB本身的工具链代码，在Apple的开源范畴之内（仓库地址：https://github.com/apple/llvm-project） 通过严格追踪跟进上游的发布历史，分支模型，能够尽可能地保证工具链的代码和功能的一致性。\n\n# 实际收益\n\n经过后文提到的一系列优化手段，以公司内大型项目飞书测试，编译器采取Swift 5.6，Xcode选择13.3为例，对比调试性能：\n\n| 项目   | Xcode 13.3 | 自定义LLDB |\n| ---- | ---------- | ------- |\n| v耗时  | 2分钟        | 40秒     |\n| po耗时 | 1分钟        | 5秒      |\n| p耗时  | 20秒        | 5秒      |\n\n图6：切换自定义LLDB工具链\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-05-07/16519143338123.png)\n\n图7：调试优化演示，使用Xcode 13.3自定义LLDB，运行文中提到的耗时Demo（原po耗时约1分钟）：\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-05-07/16519143338166.gif)\n\n# 简述po/p/v的工作流程\n\n在介绍我们自定义LLDB工具链的优化之前，首先来简述一下LLDB的核心调试场景的工作流程，方便后续理解优化的技术点。\n\n我们一期的目的是主要优化核心的调试场景，包括最常见的“断点陷入到Xcode左侧变量区展示完毕”（v），“点击Show Description”（po），“勾选Show Types”（p）。这些对应LLDB原生的下面三个交互命令。\n\n图8：LLDB的交互命令\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-05-07/16519143338184.png)\n\nApple在[WWDC 2019-LLDB: Beyond \"po\"](https://developer.apple.com/videos/play/wwdc2019/429/)[2]中，进行了较为详细的介绍，这里我们进一步详细解释其部分工作流程，为后文的具体优化技术点提供参考。建议可以搭配视频一并学习。\n\n## po [expr]\n\npo是命令`expression --object-description -- [expr]`的alias\n\n图9：po的流程\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-05-07/16519143338242.png)\n\n1.  使用Swift编译器编译`result = expr`得到IR\n\n```\n// 精简版，实际较为复杂，源代码搜@LLDBDebuggerFunction关键字\nfunc __lldb_expr() {\n  __lldb_result = expr\n}\n```\n\n2.  执行IR代码\n\n    1.  在支持JIT的平台上使用JIT，不支持则使用LLVM的IRInterpreter\n3.  获取执行结果\n4.  使用Swift编译器编译`result.description`\n\n    1.  实际上LLDB调用的是Swift标准库的私有方法：[_DebuggerSupport.stringForPrintObject](https://github.com/apple/swift/blob/release/5.6/stdlib/public/core/DebuggerSupport.swift#L242)[3]\n5.  执行IR代码\n6.  获取执行结果字符串\n7.  对得到的字符串进行格式化输出\n\n## p [expr]\n\np是命令`expression -- [expr]`的alias\n\n图10：p的流程\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-05-07/16519143338287.png)\n\n1.  使用Swift编译器编译`result = expr`得到IR\n2.  执行IR代码\n3.  获取执行结果\n4.  对`result`进行Dynamic Type Resolve\n\n    1.  利用Swift编译器提供的remoteAST，拥有源码的AST之后，会根据内存布局直接读取对象细节\n    1.  也会利用Swift Reflection，即Mirror来进行读取，和remoteAST二选一\n5.  对得到的对象细节进行格式化输出\n\n对比下来可以看到，po和p的最大不同点，在于表达式执行的结果，如何获取变量的描述这一点上。po会直接利用运行时的object description（支持[CustomDebugStringConvertible](https://developer.apple.com/documentation/swift/customdebugstringconvertible)[4]协议）拿到的字符串直接展示，并不真正了解对象细节。\n\n图11：获取Object Description的实现细节（SwiftLanguageRuntime.cpp）\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-05-07/16519143338331.png)\n\n而p使用了Swift Runtime（Objc的话就是ISA，Method List那些，资料很多不赘述），拿到了对象细节（支持[CustomReflectable](https://developer.apple.com/documentation/swift/customreflectable)[5]协议），进行按层遍历打印。不过值得注意的是，Swift Runtime依赖remoteAST（需要源码AST，即swiftmodule）或者Reflection（可能被Strip掉，并不一定有），意味着它强绑定了，编译时的Swift版本和调试时的LLDB的版本（牢记这一点）。并不像Objc那样有一个成熟稳定运行时，不依赖编译器也能动态得知任意的对象细节。\n\n图12：Swift Dynamic Type Resolve的实现（SwiftLanguageRuntimeDynamicTypeResolution.cpp）\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-05-07/16519143338391.png)\n\n## v [expr]\n\nv是命令`frame variable [expr]`的alias\n\n图13：v的流程\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-05-07/16519143338450.png)\n\n1.  获取程序运行状态（寄存器/内存等）\n2.  递归开始\n3.  解释`expr`的每一层访问（->或者.），得知当前变量的内存布局\n4.  对当前变量进行Dynamic Type Resolve\n5.  递归结束\n6.  对得到的对象细节格式化输出\n\nv的特点在于全程没有注入任何代码到程序中，也就是它是理论无副作用的。它的expr只支持访问对象的表达式（->/.等），不支持函数调用，并不是真正的C++/C/OC/Swift语法。\n\n# 优化v\n\n下述所有说明基于发稿日的Swift 5.6（优化思路也适配Swift 5.5）说明优化方案，后续不排除Apple或者LLVM上游进行其他优化替代，具有一定时效性。\n\n## (暂时)关闭swift-typeref-system\n\n- 关闭方式\n\n```\nsettings set symbols.use-swift-typeref-typesystem false\n```\n\n- 开关说明\n\n> Prefer Swift Remote Mirrors over Remote AST\n\n这里的remoteAST和Swift Mirror的概念，上文介绍过，不同方案会影响Swift的Dynamic Type Resolve的性能。\n\n经过实测，关闭之后，内部项目的复杂场景下，断点陷入耗时从原本的2分20秒，缩减为1分钟。这部分开关，目前已经通过Xcode自定义的[LLDBInit](https://lldb.llvm.org/man/lldb.html#configuration-files)[6]文件，在多个项目中设置。\n\n注：和Apple同事沟通后，swift-typeref-typesystem是团队20年提出的新方案，目前有一些已知的性能问题，但是对Swift变量和类型展示有更好的兼容性。关闭以后会导致诸如，typealias的变量在p/v时展示会有差异，比如`TimeInterval`（alias为`__C.Double`）等。待Apple后续优化之后，建议恢复开启状态。\n\n## 修复静态链接库错误地使用dlopen(Fixed in Swift 5.7)\n\n简述问题：LLDB在`SwiftASTContext::LoadOneModule`时假设所有framework包装格式都是动态链接库，忽略了静态链接库的可能性。\n\n在调试测试工程中，我们追踪日志发现，LLDB会尝试使用dlopen去加载静态链接库（Static Framework），这是很不符合预期的一点，因为对一个静态链接库进行dlopen是必定失败的，如日志所示（使用下文提到的复现Demo）：\n\n```\nSwiftASTContextForExpressions::LoadOneModule() -- Couldn't import module AAStub: Failed to load linked library AAStub of module AAStub - errors:\nLooking for \"@rpath/AAStub.framework/AAStub\", error: dlopen failed for unknown reasons.\nFailed to find framework for \"AAStub\" looking along paths:\n// ...\n```\n\n查看代码阅读发现，这里触发的时机是，LLDB在执行Swift变量Dynamic Type Resolve之前，因为需要激活remoteAST，需要加载源码对应的swiftmodule到内存中。\n\nswiftmodule是编译器序列化的包含了AST的[LLVM Bitcode](https://llvm.org/docs/BitCodeFormat.html)[7]。除了AST之外，还有很多Metadata，如编译器版本，编译时刻的参数，Search Paths等（通过编译器参数`-serialize-debugging-options`记录）。另外，对Swift代码中出现的import语句，也会记录一条加载模块依赖。而主二进制在编译时会记录所有子模块的递归依赖。\n\nLLDB在进行加载模块依赖时，会根据编译器得到的Search Paths，拼接上当前的Module Name，然后遍历进行dlopen。涉及较高的时间开销：N个Module，M个Search Path，复杂度O(NxM)（内部项目为400x1000数量级）。而在执行前。并未检测当前被加载的路径是否真正是一个动态链接库，最终产生了这个错误的开销。\n\n- 修复方案\n\n我们的修复方案一期是进行了一次File Signature判定，只对动态链接库进行dlopen，在内部工程测试（约总计1000个Framework Search Path，400个Module）情况下，一举可以减少大约1分钟的额外开销。\n\n- 复现Demo\n\n仓库地址：https://github.com/PRESIDENT810/slowDebugTest\n\n这个Demo构造了100个Swift Static Framework，每个Module有100个编译单元，以此模拟复杂场景。\n\n后文的一些测试数据优化，会反复提及这个Demo对比。\n\n注：和Apple的同事沟通后，发现可以在上层进行来源区分：只有通过`expression import UIKit`这种用户交互输入的Module会进行dlopen检查，以支持调试期间注入外部动态库；其他情况统一不执行，因为这些模块的符号必然已经在当前被调试进程的内存中了。\n\nApple修复的PR：https://github.com/apple/llvm-project/pull/4077 预计在Swift 5.7上车\n\n# 优化po/p\n\n## (暂时)关闭swift-dwarfimporter\n\n- 关闭方式\n\n```\nsettings set symbols.use-swift-dwarfimporter false\n```\n\n- 开关说明\n\n```\nReconstruct Clang module dependencies from DWARF when debugging Swift code\n```\n\n这个开关的作用是，在开启情况下，Swift编译器遇到clang type（如C/C++/Objc）导入到Swift时，允许通过一个自定义代理实现，来从DWARF中读取类型信息，而不是借助编译器使用[clang precompiled module](https://clang.llvm.org/docs/Modules.html#id20)[8]，即pcm，以及ClangImporter导入桥接类型。\n\n切换以后可能部分clang type的类型解析并不会很精确（比如Apple系统库的那种overlay framework，用原生Swift类型覆盖了同名C类型），但是能稍微加速解析速度，这是因为clang pcm和DWARF的解析实现差异。\n\n禁用之后，对内部项目测试工程部分场景有正向提升约10秒，如果遇到问题建议保持默认的true。\n\n## 优化External Module的查找路径逻辑\n\n在混编工程中，Swift Module依赖一个C/OC的clang module是非常常见的事情。在这种情况下，LLDB需要同时使用编译器，加载到对应的clang module到内存中，用于进行C/OC Type到Swift Type的导入逻辑。\n\n但是实际情况下，我们可能有一些Swift混编产物，是预二进制的产物，在非当前机器中进行的编译。这种情况下，对应编译器记录的的External Module的路径很可能是在当前机器找不到的。\n\nLLDB的原始逻辑，会针对每一个可能的路径，分别由它的4种ObjectFile插件（为了支持不同的二进制格式）依次进行判断。每个ObjectFile插件会各自通过文件IO读取和解析Header。这是非常大的开销。\n\n- 优化方案\n\n我们内部采取的策略比较激进，除了直接利用fstat进行前置的判断（而不是分别交给4个ObjectFile插件总计判断4次）外，还针对Mac机器的路径进行了一些特殊路径匹配规则，这里举个例子：\n\n比如说，Mac电脑的编译产物绝对路径，一定是以`/Users/${whoami}`开头，所以我们可以先尝试获取当前调试器进程的`uname`（非常快且LLDB进程周期内不会变化），如果不匹配，说明编译产物一定不是在当前设备进行上产出的，直接跳过。\n\n图14：特殊匹配规则，直接避免文件IO判定存在与否\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-05-07/16519143338511.png)\n\n通过这一项优化，在内部项目测试下（1000多个External Module路径，其中800+无效路径），可以减少首次变量显示v耗时约30秒。\n\n## 增加共享的symbols缓存\n\n我们使用内部项目进行性能Profile时，发现`Module::FindTypes`和`SymbolFile::FindTypes`函数耗时调用占了主要的大头。这个函数的功能是通过DWARF（记录于Mach-O结构中），查找一个符号字符串是否包含在内。耗时主要是在需要进行一次性DWARF的解析，以及每次查找的section遍历。\n\nLLDB本身是存在一个`searched_symbol_files`参数用来缓存，但是问题在于，这份缓存并不是存在于一个全局共享池中，而是在每个具体调用处的临时堆栈上。一旦调用方结束了调用，这份缓存会被直接丢弃。\n\n图15：symbols缓存参数\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-05-07/16519143338574.png)\n\n- 优化方案\n\n我们在这里引入了一个共享的symbols缓存，保存了这份访问记录来避免多个不同调用方依然搜索到同一个符号，以空间换时间。实现方案比较简单。\n\n内部工程实测，下来可以减少10-20秒的第一次访问开销，而每个symbol缓存占据字节约为8KB，一次调试周期约10万个符号占据800MB，对于Mac设备这种有虚拟内存的设备来说，内存压力不算很大。另外，也提供了关闭的开关。\n\n## 优化不必要的同名symbols查找\n\n另一项优化`Module::FindTypes`和`SymbolFile::FindTypes`函数开销的方案是，原始的这两个函数会返回所有匹配到的列表，原因在于C++/Rust/Swift等支持重载的语言，会使用naming mangle来区分同一个函数名的不同类型的变种。这些符号名称会以同样的demangled name，记录到DWARF中。\n\n但是调用方可能会关心同名类型的具体的变种（甚至包括是const还是非const），甚至有很多地方只取了第一个符号，搜索全部的Symbol File其实是一种浪费（在Swift 5.6版本中找到累积约10处调用只取了第一个）\n\n- 优化方案\n\n我们对上述`Module::FindTypes`和`SymbolFile::FindTypes`函数，提供了一个新的参数`match_callback`，用于提前过滤所需要的具体类型。类似于很多语言标准库提供sort函数中的stop参数。这样，如果只需要第一个找到的符号就可以提前终止搜索，而需要全部符号列表不受影响。\n\n图16：symbols查找筛选参数\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-05-07/16519143338656.png)\n\n内部项目测试这项优化以后，可以减少C++/C/OC类型导入到Swift类型这种场景下，约5-10秒的第一次查找耗时。\n\n# 其他优化\n\n## 定向优化Dynamic Type Resolve的一些特例\n\n在实际项目测试中，我们发现，Dynamic Type Resolve是有一些特例可以进行针对性的shortcut优化，剔除无用开销的。这部分优化仅对特定代码场景有效，并不通用。这里仅列举部分思路\n\n- 优化Core Foundation类型的Dynamic Type Resolve\n\nCore Foundation类型（后文以CF类型指代），是Apple的诸多底层系统库的支撑。Objc的Founadtion的NS前缀的很多类型，也会[Toll-Free Bridging](https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/Toll-FreeBridgin/Toll-FreeBridgin.html)[9]到CF类型上。而Swift也针对部分常用的CF类型支持了Briding。\n\nCF类型的特点是，它内存布局类似Objc的Class ISA，但是又不是真正的Objc Class或者Swift imported Type，ISA固定是`__NSCFType`。\n\n而目前LLDB遇到在Swift堆栈中出现的CF类型，依旧把它当作标准的clang type进行C++/C那一套解析，还会递归寻找父类ivar，比较费时。我们可以利用这一特点提前判定而跳过无用的父类查找。\n\n图17：筛选CF类型\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-05-07/16519143338723.png)\n\n这一项优化在特定场景（如使用CoreText和CoreVideo库和Swift混编）下，可以优化10-20秒的每次Dynamic Type Resolve耗时。\n\n# 接下来\n\n我们在之后会有一系列的相关话题，包括：\n\n- Xcode 13.3导致部分项目po提示Couldn't realize type of self，有什么解决办法？\n- 如何极速构建，分发自定义LLVM/LLDB工具链，来让用户无缝部署？\n- 如何进行调试性能指标的监控和建设，包括Xcode原生的LLDB？\n\n另外，这篇文章提到的非定制的优化和功能，均会向Apple或LLVM上游提交Patches，以回馈社区。\n\n# 总结\n\n这篇文章讲解了，大型Swift项目如何通过开关，以及自定义LLDB，优化Swift开发同学的调试速度，提高整体的研发效能。其中讲解了LLDB的部分工作流程，以及针对性优化的技术细节，以及实际效果。\n\n我们的优化目标，不仅仅是服务于字节跳动移动端内部，更希望能推动业界的Swift和LLVM结合领域的相关发展，交流更多工具链方向的优化建设。\n\n# 鸣谢\n\n感谢飞书基础技术团队提供的一系列技术支持，以及最终业务试点提供的帮助推广。\n感谢Apple同事Adrian Prantl在GitHub和邮件上进行的交流反馈，协助定位问题。\n\n# 引用链接\n\n1.  https://developer.apple.com/videos/play/wwdc2017/413/\n2.  https://developer.apple.com/videos/play/wwdc2019/429/\n3.  https://github.com/apple/swift/blob/release/5.6/stdlib/public/core/DebuggerSupport.swift#L242\n4.  https://developer.apple.com/documentation/swift/customdebugstringconvertible\n5.  https://developer.apple.com/documentation/swift/customreflectable\n6.  https://lldb.llvm.org/man/lldb.html#configuration-files\n7.  https://llvm.org/docs/BitCodeFormat.html\n8.  https://clang.llvm.org/docs/Modules.html#id20\n9.  https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/Toll-FreeBridgin/Toll-FreeBridgin.html\n","categories":["LLVM"],"tags":["swift","lldb","llvm"]},{"title":"Swift之AnyClass与动态类型","url":"/2016/03/30/Swift%E4%B9%8BAnyClass%E4%B8%8E%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B/","content":"\n> 这次写一下关于Swift中AnyClass的使用以及动态类型的实例化和使用场景\n\n# AnyClass与AnyObject\nSwift中，任何自定义的对象都是AnyClass的子类，类似于Java的Object类（但注意，这和Objective-C的NSObject不同，后者在Swift中是专门的UIKit或者AppKit框架里面定义的类型，而非语言所规定的类型）\n\n> AnyClass\nThe protocol to which all class types implicitly conform.\n\nDeclaration\n`typealias AnyClass = AnyObject.Type`\n\n> AnyObject\n\nprotocol AnyObject { ... }\n`The protocol to which all classes implicitly conform.`\n\n但是注意，这个AnyObject.Type是一个毕竟是一个接口的Property，所以只能在函数的参数里面使用，如果想要直接获取某个类（而非实例）的类型，使用类名.self即可；如果想要获取一个实例的类的类型，使用.dynamicType；对了，如果对象是NSObject的实例（iOS开发中常用），用classForCoder也是一个选择\n\n```swift\nclass Test {}\nfunc f(s: AnyClass) {\n    print(s)\n}\nlet a = Test.self\nlet b = Test().dynamicType\nlet c:AnyClass = \"test\".classForCoder //注意此时加了classForCoder的方法调用，编译器会推导出\"\"是一个NSString的实例而不是String\nf(a) //Test\nf(b) //Test\nf(c) //NSString\n```\n\n# 动态实例化\n\n既然我们有了某个AnyObject的Type，这样我们就可以直接构造出一个类型的实例。使用AnyObject都有的.init方法即可，当然，AnyObject本身并没有init的构造方法……\n\n```swift\nlet d = a.init() // d is an instance of Test\nlet e = (c as! NSString.Type).init(stringLiteral: \"test\") // e is \"test\"\n```\n\n当然，你也许肯定奇怪那个required的init是什么意思，其实这是为了避免出现你使用的这个Test.Type有继承的子类，然后子类的构造函数中使用了这个Type来构造父类这种边界情况出现（考虑的真细……）\n\n> Use an initializer expression to construct an instance of a type from that type’s metatype value. For class instances, the initializer that’s called must be marked with the required keyword or the entire class marked with the final keyword.\n\n而且对于一个Protocol，可以用.Protocol来获取这个Protocol的类型（还是AnyClass），也可以用self来统一处理，因为实际上\n\n`metatype-type(.self) -> type.Type | type.Protocol`\n\n这样的话，有了动态就可以开始干活了\n\n# Swift的反射\n\n或许你也想，既然我有了动态的类型实例，那么是不是能通过类似Java的反射，获取某个类型的所有Property，然后直接访问这个Property呢？答案也是有的，不过在Swift中很少用到，这里用到到了Mirror\n> struct Mirror { ... }\nRepresentation of the sub-structure and optional \"display style\" of any arbitrary subject instance.\n\n```swift\nclass Person {\n    var whatThisProperty:String\n    init(name:String) {\n        self.whatThisProperty = name\n    }\n}\nlet p = Person(name: \"Bob\")\nlet mirror = Mirror(reflecting: p)\nmirror.children.forEach {\n    print(\"\\($0.label!): \\($0.value)\")\n}\n```\n\n这里的children返回的是一个AnyForwardCollection，也是可以像数组一般用index来访问或者forEach遍历的，不过索引顺是序按照你的Property的声明顺序\n\n# 最后的小应用\n\n由于我也不怎么会写iOS，有时候遇到这样一种情况：\n我提供了一个3D Touch的按钮，四个按钮会对应四种ViewController，iOS提供的API可以获取到用户点击的那个按钮对应的设置的一个字符串值，那么，我可以这样来玩……\n\n```swift\n// 3D Touch 传入的字符串来判断返回某个ViewController\nstatic func shortcutToViewController(type:String) -> UIViewController.Type {\n    switch type {\n    case \"pe\":\n        return RunningViewController.self\n    case \"curriculum\":\n        return CurriculumViewController.self\n    case \"card\":\n        return SeuCardViewController.self\n    case \"nic\":\n        return NicViewController.self\n    default: return UIViewController.self\n    }\n}\n```\n\n这是用来判断字符串来产生对应的ViewController.Type的，然后，在真正需要实例化一个新的ViewController来显示一个View的时候，再实例化\n```swift\nfunc pushToViewController(vc: UIViewController.Type) {\n    // 确保要显示的ViewController不是顶层显示的ViewController\n    guard let duplication = navigationController?.topViewController?.isKindOfClass(vc) else { return }\n    if duplication { // 检查失败，重复的ViewController，不需要跳转\n        return\n    }\n    let viewController = vc.init(nibName: \"\\(vc.classForCoder())\", bundle: nil) // 初始化ViewController\n    navigationController?.pushViewController(viewController, animated: true)\n}\n```\n\n这也是一种比较奇怪的方式……不过如果不这样，就会导致在主类和上层里面引入过多的Switch Case或者导致代码中出现纯字符串定义的nibName，这对以后重构非常不利。\n\n# 结束语\n\n嗯，好久没写东西了……主要最近在学编译原理，之后会有几篇讲解通过Java实现一个简单的支持CFG的Yacc(误)的东西……顺便就当复习编译原理的Parser部分了。\n\nSwift如今开源了：[Swift](https://github.com/apple/swift)，不到几天Star就超过了2年出头的Rust(lol)……现如今Star也到了2W5的程度\n\n虽然UIKit和AppKit这种宝贵的财富Apple肯定不会开源，不过Swift标准库的实现也是越来越完善，而且也有Linux的版本，很多第三方的库开始加入了对Linux的支持（非面向iOS和OS X开发的，比如对SQLite，Redis的wrapper）\n\nSwift作为一个Rust的对手，一个完全抛弃了C的现代语言，之后在除客户端开发外，更可能的领域就是系统编程和服务端编程了吧。希望能够在在安全性，易用性，效率上达到一个更大的高度，让我们这种开发者也能用的爽，用的顺。","categories":["iOS"],"tags":["Swift"]},{"title":"Top Down --自顶向下的文法分析","url":"/2016/03/29/Top-Down-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%9A%84%E6%96%87%E6%B3%95%E5%88%86%E6%9E%90/","content":"\n# Top Down --自顶向下的文法分析\n\n读入：读取下一个待匹配字符进去stack，如果为#且栈顶也为＃，成功；如果此时栈顶不为#，失败\n检查：如果栈顶为终结符，回到读入；\n否则，随机选择一个规则（假如存在多个规则可以满足的话），使栈顶字符与左部（非终结符）匹配，匹配，用规则的右部（即终结符）替换，整个过程叫做规约(Derivation)\n\t如果找到匹配的规则，回到读入；\n\t否则，BackTracking，回溯到上一次的检查，换另一个规则\n\n```swift\nif Stack == None Terminal {\n\tchoose rule do divide {\n\t\tfrom right to left, push into stack\n\t}\n}\n\nmatch {\n\tpointer move right to read\n}\n\n\nif not match {\n\tbacktrack\n}\n\n```\n\n\nexample:\n\n1. $ S \\to a \\\\ S \\to Sa $, 给定 \"aa\"\n\n```text\n@1\nS# | aa#\na# | aa#\n# | a# -> backtrack\nS# | aa#\n@2\n```\n\n存在问题： \n\n1. 左递归问题：假如一直选择规则2，将导致无穷循环，无法停止     -->解决：设计文法的时候，消除左递归文法，具体见下专题：\n$ A \\to \\*\\* \\mid \\* \\\\ => \\\\ A \\to \\*B \\\\ B \\to \\epsilon \\\\ B \\to \\* $\n2. BackTracking花费时间\t\t-->解决：加入预测，对所有的非终结符加入到预测表中，在进行检查选定一个规则的时候，预读下一个字符，查表检查规则产生的右部是否以预测字符相同，相同继续，不相同直接返回错误，避免过多backtracking，具体见下专题：\n\n## 左递归\n\n1. 定义：\n\t直接左递归：$ P \\to P\\alpha \\mid \\beta \\\\ $\n\t间接左递归：$ \\\\ P \\to Aa \\\\ A \\to Bb \\\\ B \\to Pc $，可以存在多个中间非终结符，依次传递\n2. 消除：\n\t直接左递归：$ P \\to \\beta P^\\* \\\\ P^\\* \\to \\epsilon \\\\ P^\\* \\to \\alpha P^\\* $\n\t间接左递归：\n\t1. 首先，对所有参与递归的非终结符，排序，$ B \\ A \\ P $(其实顺序无关，但是把起始符放在最后，更能简化最终语法，其他顺序产生语法较为复杂）\n\t2. 依次检查非终结符，如果产生的右部，不含有在该非终结符前面序列的终结符，不处理。比如$ B \\to Pc $，$ P $在$ B $之后，故直接处理下一个终结符\n\t\t否则，含有在序列之前的终结符，比如$ A \\to Bb $含有$ B $，且$ B $在$ A $之前，则直接把所有$ B $使用$ B $的产生式替换，然后处理下一个终结符\n\t$ A \\to Pcb  $\n\t3. 直到所有的非终结符被处理，其中可能产生直接左递归式：\n\t$ B \\to Pc \\\\ A \\to Pcb \\\\ P \\to Pcba $\n\t4. 对这个直接左递归式，把$ cba $看作$ \\alpha $，使用直接左递归消除：\n\t$ B \\to Pc \\\\ A \\to Pcb \\\\ P \\to P^\\* \\\\ P^\\* \\to \\epsilon \\\\ P^\\* \\to cbaP^\\* $\n\t5. 最后一步进行简化，比如此时的$ P \\to P^\\* $，可替换之后的所有$ P^\\* $为$ P $，多行的非终结符合并\n\t6. 最终结果：$ B \\to Pc \\\\ A \\to Pcb \\\\ P \\to cbaP \\mid \\epsilon $\n\n## 预测表\n\n1. 定义：\n\t行为所有的终结符以及#，列为所有的非终结符。某一个产生式对应匹配（$ 列 \\to 行首字符 $)，比如$ E \\to iE^\\* $匹配[E,i]。匹配的元素标记为1，不匹配的为0\n2. 使用：\n\t在Top Down的时候，如果检查选择规则时候，查表发现该规则非终结符在表中的标记为1，则继续，否则直接返回错误，无需继续BackTracking\n\n\n# Bottom Up --自底向上\n\n读入：读取下一个待匹配字符进去stack，如果为#，停机\n检查：是否可以被reduction，即可以被某个产生式右部匹配，用左部分替换\n如果可以，pop待匹配字符，push那个被reduct的字符进去stack，回到检查\n如果不行，回到读入\n\n存在问题：\n1. 对于重复的字符匹配，比如 $ A \\to \\*\\* $，出现一个＊就会被规约，导致错误。使用Handling来特殊处理$ \\epsilon $","categories":["Code"],"tags":["编译原理"]},{"title":"WatchKit渲染原理以及SwiftUI桥接","url":"/2019/12/10/WatchKit%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8ASwiftUI%E6%A1%A5%E6%8E%A5/","content":"\n# WatchKit渲染原理以及SwiftUI桥接\n\n## 背景\n\nApple Watch作为苹果智能穿戴设备领域的重头，自从第一代发布已经经历了6次换代产品，操作系统的迭代也已经更新到了watchOS 6。\n\n不同于iPhone的App，watchOS上的大部分App都侧重于健康管理，并且UI交互以直观，快速为基准。在2015年WWDC上，苹果发布的watchOS的同时，面向开发者发布了WatchKit，以用于构建watchOS App。\n\n![watchkit-app.jpg](https://help.apple.com/assets/61BCCC0198613862887EA61B/61BCCC2A98613862887EA62C/en_US/091b3af363505482da15ec78aa547a4d.png)\n\n这篇主要讲了关于WatchOS上的App的架构介绍，基本概念，并深入分析了WatchKit的UI渲染逻辑，也谈了一些WatchOS和SwiftUI相关的问题。\n\n其实写这个文章的最主要的原因，是在于自己前段时间写库时候，在SwiftUI与watchOS的集成中，遇到了相当多的问题，迫使我对WatchKit进行了一些探索和逆向分析，这里共享出来，主要原因有多个：\n\n1. 能够了解WatchKit的背后实现细节，回答诸如这种问题：“为什么WatchKit使用Interface Object的概念，而不能叫做View“\n2. 能够理解WatchKit的架构设计，作为库开发者提升自己的分层抽象，架构能力，甚至可以自己做一\u0010套类似WatchKit的实现（上层封装布局框架或者DSL）\n3. 了解到SwiftUI和WatchKit之间的坑点在于什么，在开发时候遇到奇怪问题能够进行分析归因\n4. 实在被逼无奈的时候，可以考虑利用渲染机制走UIKit（注意私有API风险）\n\n## WatchKit架构介绍\n\n一个标准WatchKit App，可以分为至少两个部分：\n\n+ Watch App Target：只有Storyboard和资源，用来提供静态的UI层级，你不允许动态构建View树（可以隐藏和恢复）\n+ Watch Extension：管理所有逻辑代码，Interface Controller转场，更新UI\n\n如果没有接触过WatchKit，推荐参考这篇文章快速概览了解一下：[NSHipster - Watch​Kit](https://nshipster.cn/watchkit/)。只需要知道，我们的核心的UI构造单元，是Interface Object和Interface Controller，类似于UIKit的View和ViewController。\n\nInterface Controller用于管理页面展示元素的生命周期，而Interface Object是管理Storyboard上UI元素的单元，且只能触发更新，无法获取当前的UI状态（setter-only）。\n\n![](https://trymakedo.files.wordpress.com/2014/11/watch_app_lifecycle_simple_2x.png)\n\n在watchOS 1时代，WatchKit采取的架构是WatchKit Extension代码，运行在iPhone设备上，于Apple Watch使用无线通信来更新UI，并且由于运行在iPhone上，可以直接访问到App的共享沙盒和UserDefaults。这受当时早期的Apple Watch硬件和定位导致的一种局限性。\n\n在watchOS 2时代，为了解决1时候的更新UI延迟问题，WatchKit进行了改造，将Extension代码放到Apple Watch中执行，就在同样的进程当中，避免额外的传输。为了解决和iPhone的存储同步问题，与此同时推出了WatchConnectivity框架，可以与iPhone App进行通信。\n\n![](https://developer.apple.com/library/archive/documentation/General/Conceptual/AppleWatch2TransitionGuide/Art/architecture_compared_2x.png)\n\n## WatchKit UI布局原理\n\nWatchKit本身设计的是一个完整的客户端-服务端架构，在watchOS 1时代，由于我们的Extension进程在iPhone手机上，而App进程在Apple Watch上，因此通信方式必定是真正的网络传输，苹果采取了WiFi-Direct+私有协议，来传输对应的数据。\n\nwatchOS 1时代的App性能表现很糟糕，一旦iPhone和Apple Watch距离较远，整个watchOS App功能基本是无法使用，只能重新连接。\n\n在watchOS 2上，苹果取巧的把Extension进程放到了Apple Watch本身，而上层已有的WatchKit代码不需要大幅改变。但是，Apple并没有因为这个架构改变，而提供真正的UIKit给开发者。类似的，一些贯穿于iOS/macOS/tvOS的基本框架，Apple依旧把它保留为私有，包括：\n\n+ CoreAnimation\n+ Metal\n+ OpenGL/ES\n+ GLKit\n\n开发者在watchOS上，除了使用WatchKit以外，只能采取SceneKit或者SpriteKit这种高级游戏引擎，来开发你的watchOS App。\n\n虽然苹果这样做，有很多具体的原因，比如说兼容代码，比如性能考量，甚至还有从技术层面上强迫统一UI风格等等。不过随着watchOS 6的发布，watchOS终于有真正的UI框架了。\n\n### 客户端\n\nWatchKit的客户端，指的是Apple Watch App自带的WatchKit Extension部分。\n\n在watchOS 1上，客户端的进程位于iPhone当中，而不是和Apple Watch在一起。之间的传输需要走网络协议。在watchOS 2中，之间的传输依旧保持了一层抽象，但是实际上最终等价于同进程代码的调用。\n\n由Storyboard创建的WKInterfaceObject，一定会有与之绑定的WKInterfaceController，这些Controller会保留一个viewControllerID，用于向服务端定位具体的UIKit ViewController（后面提到）\n\nWKInterfaceObject的**所有**公开API相关属性设置，比如width height，alpha, image等，均会最终转发到一个`_sendValueChanged:forProperty:`方法上。Value是对应的对象（CGFloat会转换为NSNumber，部分属性会使用字典），Property是这些属性对应的名称（如width，height，image，text等）。\n\n根据是否WatchKit 2，会做不同的处理。WatchKit 2会经过Main Queue Dispatch分发，而Watch 1采取的是自定义的一个通信协议，通过和iPhone直连的WiFi和私有协议传输。\n\n简单来说，等价于如下伪代码：\n\n```objectivec\n@implementation WKInterfaceObject\n- (void)setWidth:(CGFloat)width {\n  [self _sendValueChanged:@(width) forProperty:@\"width\"];\n}\n\n- (void)_sendValueChanged:(id<NSCoding>)value forProperty:(NSString *)property {\n    NSDictionary *message = @{\n      @\"viewController\": self.viewControllerID,\n      @\"key\": \"wkInterfaceObject\",\n      @\"value\": value,\n      @\"property\": property,\n      @\"interfaceProperty\": self.interfaceProperty\n    };\n    [[SPExtensionConnection remoteObjectProxy] sendMessage:message];\n}\n@end\n```\n\n### 服务端\n\n这里的提到服务端，在watchOS 1时代其实就是Apple Watch上单独跑的进程，而在watchOS 2上，它和Extension都是在Apple Watch上，也实际上运行在同一个进程中。\n\n对于每个watchOS App，它实际可以当作一个UIKit App。它的main函数入口是一个叫做WKExtensionMain的方法，里面做了一些Extension的初始化以后，就直接调用了\n有UIApplicationMain。watchOS App有AppDelegate（类名为[SPApplicationDelegate](https://github.com/LeoNatan/Apple-Runtime-Headers/blob/master/watchOS/Frameworks/WatchKit.framework/SPApplicationDelegate.h)），会有一个全屏的root UIWindow当作key window。\n\n![watchkit1](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2019-12-10/image/watchkit1.jpg)\n\n#### UI初始化\n\n在服务端启动后，它会加载Storyboard中的UI。对每一个客户端的Interface Controller，实际上服务端对应会创建一个View Controller，对应UIViewController的生命周期，会转发到客户端，触发对应的Interface Controller的willActivate/didAppear方法。\n\n因此，watchOS创建了一个[SPInterfaceViewController](https://github.com/LeoNatan/Apple-Runtime-Headers/blob/master/watchOS/Frameworks/WatchKit.framework/SPInterfaceViewController.h)子类来统一做这个事情，它继承自[SPViewController](https://github.com/LeoNatan/Apple-Runtime-Headers/blob/master/watchOS/Frameworks/WatchKit.framework/SPViewController.h)，父类又继承自UIViewController，使用客户端传来的Interface Controller ID来绑定起来。\n\n对于UI来说，每一种WKInterfaceObject，其实都会有一个原生的继承自UIView的类去做真正的渲染，比如：\n\n+ WKInterfaceButton: [SPInterfaceButton](https://github.com/LeoNatan/Apple-Runtime-Headers/blob/master/watchOS/Frameworks/WatchKit.framework/SPInterfaceButton.h)，继承自`UIControl`\n+ WKInterfaceImage: [SPInterfaceImageView](https://github.com/LeoNatan/Apple-Runtime-Headers/blob/master/watchOS/Frameworks/WatchKit.framework/SPInterfaceImageView.h)，继承自`UIImageView`\n+ WKInterfaceGroup: [SPInterfaceGroupView](https://github.com/LeoNatan/Apple-Runtime-Headers/blob/master/watchOS/Frameworks/WatchKit.framework/SPInterfaceGroupView.h)，继承自`UIImageView`\n+ WKInterfaceMap: [SPInterfaceMapView](https://github.com/LeoNatan/Apple-Runtime-Headers/blob/master/watchOS/Frameworks/WatchKit.framework/SPInterfaceMapView.h)，继承自`MKMapView`\n+ WKInterfaceSwitch: [SPInterfaceSwitch](https://github.com/LeoNatan/Apple-Runtime-Headers/blob/master/watchOS/Frameworks/WatchKit.framework/SPInterfaceSwitch.h)，继承自`UIControl`\n+ WKInterfaceTable: [SPInterfaceListView](https://github.com/LeoNatan/Apple-Runtime-Headers/blob/master/watchOS/Frameworks/WatchKit.framework/SPInterfaceListView.h)，继承自`UIView`\n\nSPInterfaceViewController的主要功能，就是根据Storyboard提供的信息，构造出对应这些UIView的树结构，并且初始化对应的值渲染到UI上（比如说，Image有初始化的Name，Label有初始的Text）。实际上，这些具体的初始化值，都存储在Storyboard中，比如说，这里是一个简单的包含Table，每个TableRow是一个居中的Label，它对应的结构化数据如下：\n\n```json\n{\n    controllerClass = \"InterfaceController\";\n    items =     (\n                {\n            property = interfaceTable;\n            rows =             {\n                default =                 {\n                    color = EFF1FB24;\n                    controllerClass = \"ElementRowController\";\n                    items =                     (\n                                                {\n                            alignment = center;\n                            fontScale = 1;\n                            property = elementLabel;\n                            text = Label;\n                            type = label;\n                            verticalAlignment = center;\n                        }\n                    );\n                    type = group;\n                    width = 1;\n                };\n            };\n            type = table;\n        }\n    );\n    title = Catalog;\n}\n```\n\n这些信息会在运行时用于构建真正的View Tree。\n\n值得注意的是，watchOS由于本身的UI，这些SPInterfaceViewController的rootView，一定是一个容器的View。比如说一般的多种控件平铺的Storyboard会自带`SPInterfaceGroupView`，一个可滚动的Storyboard会自带一个`SPCollectionView`，等等。这里是简单的伪代码：\n\n```objectivec\n@implementation SPInterfaceViewController\n- (void)loadView {\n  Class rootViewClass;\n  UIView *rootView = [[rootViewClass alloc] initWithItemDescription:self.rootItemDescription bundle:self.bundle stringsFileName:self.stringsFileName];\n  self.view = rootView;\n}\n@end\n```\n\n#### UI更新\n\nUI创建好以后，实际上我们的Extension代码会触发很多Interface object的刷新，比如说更新Label的文案，Image的图片等等，这些会从客户端触发消息，然后在服务端统一由AppDelegate接收到，来根据viewControllerID找到对应先前创建的SPInterfaceViewController。\n\n```objectivec\n@interface SPApplicationDelegate : NSObject <SPExtensionConnectionDelegate, UIApplicationDelegate>\n@end\n\n@implementation SPApplicationDelegate\n- (void)extensionConnection:(SPExtensionConnection *)connection interfaceViewController:(NSString *)viewControllerID setValue:(id)value forKey:(NSString *)key property:(NSString *)key {\n    if ([key isEqualToString:@\"wkInterfaceObject\"]) {\n        SPInterfaceViewController *vc = [SPInterfaceViewController viewControllerForIdentifier:viewControllerID];\n        [vc setInterfaceValue:value forKey:key property:property];\n    }\n}\n@end\n```\n\n因此，拿到UIViewController以后，WatchKit会根据前面传来的interfaceProperty来定位，找到一个需要更新的View。然后向对应的UIView对象，发送对应的property和value，以更新UI。\n\n```objectivec\n@interface SPInterfaceImageView : UIImageView\n@end\n@implementation SPInterfaceImageView\n- (void)setInterfaceItemValue:(id)value property:(NSString *)property {\n    if ([property isEqualToString:@\"width\"]) {\n        self.width = value.doubleValue;\n    }\n    if ([property isEqualToString:@\"image\"]) {\n        self.image = value;\n    }\n    // ...\n}\n@end\n```\n\n后续的流程，就完全交给UIKit和CALayer来进行渲染了。\n\n## 总结流程\n\n![watchkit2](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2019-12-10/image/watchkit2.jpg)\n\n\n通过这张图，其实完整的流程，我们可以通过调用栈清晰看到，如图各个阶段：\n\n1. 开发者调用WKInterfaceObject的UI方法\n2. 客户端的WKInterfaceObject统一封装发送消息\n3. 传输层传输消息（watchOS 1走网络，watchOS 2实际上就Dispatch到main queue）\n4. 服务端接收到消息，消息分发给对应的ViewController\n5. ViewController分发消息给rootView（会递归处理）\n6. View解码消息，得到对应的需要设置的UIKit属性和值\n7. 调用UIKit的UI更新方法\n\n可以看出来，其实WatchKit这边主要的工作就是抽象了一层Interface Object而不让开发者直接更新UIView。在watchOS 1时代这是一个非常好的设计，因为Extension进程在iPhone中，而App进程在Apple Watch上。但是到了watchOS 2以后，依然保留了这一套设计方案，实际上开发者能自定义的UI很有限。\n\n## WatchKit与Long-Look Notification\n\nwatchOS除了本身的App功能外，还有一些其他特性，比如这里提到的Long-Look Notification。这是在Apple Watch收到推送通知时候展示的页面，它实际上类似于iOS上的Notification Extension，可以进行自定义的UI。\n\n![](https://docs-assets.developer.apple.com/published/2d2f6b930c/52360133-b314-48c5-aa59-f2cb6c5e4e8f.png)\n\n苹果这里面对Notification提供了3种类型，根据能不能动态更新UI/能不能响应用户点击可以分为：\n\n+ Static Notification（固定UI，点击后关闭）\n+ Dynamic Notification（可以更新UI，点击后关闭）\n+ Dynamic Interactive Notification（可以更新UI，可以响应交互，不默认关闭）\n\n和普通的WatchKit UI一样，Notification依然使用Storyboard构建。并且有单独的Storyboard Entry Point。在代码里面通过WKUserNotificationInterfaceController的方法`didReceive(_:)`，来处理接收到通知后的UI刷新，存储同步等等逻辑。\n\n![](https://docs-assets.developer.apple.com/published/0599a724ac/8487cfa2-b872-481d-b0ae-409d1aaea6d1.png)\n\n如图所示，整体的生命周期比较简单，可以参考苹果的文档即可：[Customizing Your Long-Look Interface](https://developer.apple.com/documentation/watchkit/enhancing_your_watchos_app_with_notifications/customizing_your_long-look_interface)\n\n### Long-Look Notification原理\n\n按照之前说的，WatchOS的Native App中，使用了SPApplicationDelegate作为它的AppDelegate，也直接实现了UNUserNotificationCenterDelegate相关方法。\n\n当有推送通知出现时，如果watchOS App正处于前台，会触发一系列UserNotification的通知。类似于UIKit的逻辑，就不再赘述。\n\n如果watchOS App未启动，那么会被后台启动（且不触发UserNotification的通知），对应Storyboard中的WKUserNotificationInterfaceController实例会被初始化。加载完成UI后，会调用`willActivate()`方法并自动弹起。\n\n![watchkit4](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2019-12-10/image/watchkit4.jpg)\n\n\n其实可以看出来，WatchKit主要做的事情，是在于watchOS App未启动时，需要对用户提供的WKUserNotificationInterfaceController，桥接对应的UserNotification接口和生命周期。\n\n1. 当SPApplicationDelegate的`userNotificationCenter:willPresentNotification:withCompletionHandler:`被调用，它会向客户端发送消息，触发WKUserNotificationInterfaceController的`didReceive(_:)`方法\n2. 当用户点击了Notification上面的按钮时，SPApplicationDelegate的`userNotificationCenter:didReceiveNotificationResponse:withCompletionHandler:`被调用，如果App不支持dynamic interactive notification，它会直接关闭通知，并唤起watchOS App到前台\n3. 如果支持dynamic interactive notification(watchOS 5/iOS 12)，那么用户点击的Button/Slider之类，会调用WKUserNotificationInterfaceController上绑定的Target-Action，开发者需要手动在交互完毕后调用`performNotificationDefaultAction`，`performDismissAction`关闭通知（系统不再自动关闭通知），另外，系统给通知的最下方提供了一个默认的Dismiss按钮，点击后会强制关闭。\n\n个人见解：之所以watchOS非要封装一层，主要原因是watchOS 1时代，不支持自定义通知；在watchOS 2时代，UserNotification这个框架还不存在，UIKit和AppKit都各自有一套接收Notification的实现，而WatchKit也照猫画虎搞了一套（当时就用的UILocalNotification）。UserNotification这个跨平台的通知库，是伴随着watchOS 3才出现的，但是已经晚了，因此WatchKit继续在已有的这个WKUserNotificationInterfaceController上新增功能。\n\n其实可以看到，WKUserNotificationInterfaceController实际上提供的接口，基本完全等价于UserNotifications + UserNotificationsUI，方法名类似，有兴趣的话自行参考官方文档对比一下[watchOS Custom Notification Tutorial](https://developer.apple.com/documentation/watchkit/enhancing_your_watchos_app_with_notifications) 和 [iOS Custom Notification Tutorial](https://developer.apple.com/documentation/usernotificationsui/customizing_the_appearance_of_notifications)\n\n## WatchKit和SwiftUI\n\n在WWDC 2019上，苹果发布了新的全平台UI框架，SwiftUI。SwiftUI是一个声明式的UI框架，大量使用了Swift语法特性和API接口设计，提倡Single Source of Truth而不是UIKit一直以来的View State Mutation。\n\n为什么专门要讲SwiftUI，因为实际上，SwiftUI才是Apple Watch上真正的完整UI框架，而WatchKit由于设计上的问题，无法实现**Owning Every Pixel**这一点，在我心中它的定位更类似于TVML的级别。\n\n![swiftui](https://developer.apple.com/assets/elements/icons/swiftui/swiftui-96x96_2x.png)\n\n关于SwiftUI在watchOS上的快速上手，没有什么比Apple官方文档要直观的了，有兴趣参考：[SwiftUI Tutorials - Creating a watchOS App](https://developer.apple.com/tutorials/swiftui/creating-a-watchos-app)\n\n这里不会专门介绍SwiftUI的基础知识，后续我可能也会写一篇SwiftUI原理性介绍的文章。但是这篇文章，主要侧重一些SwiftUI在watchOS的独有特性和注意点，以及一些自己发现的坑。\n\n### SwiftUI与WatchKit桥接\n\nSwiftUI，允许桥接目前已有的WatchKit的Interface Object，就如在iOS上允许桥接UIKit一样。但是它能做的事情和概念其实完全不一样。\n\n在iOS上，你能通过代码/Storyboard来构建你自己的UIView子类，并且你能构造自己的ViewController管理生命周期事件。这些都能通过SwiftUI的[UIViewRepresentable](https://developer.apple.com/documentation/swiftui/uiviewrepresentable)来桥接而来。与此同时，你还可以在你的UIKit代码中，来引入SwiftUI的View。你可以使用UIHostingController当作Child VC，甚至是对应的UIView（`UIHostingController.view`是一个私有类`_UIHostingView`，继承自UIView），是一种双向的桥接。\n\n但是，正如之前提到，WatchKit设计是严重Storyboard Based，你不允许继承Interface Object。你不能使用SwiftUI来引入Storyboard自己构建好的Interface Object/Controller层级。不过相反的是，你可以使用WKHostingController，在Storyboard中去present或者push一个新的SwiftUI页面，实际是一种单向的桥接。\n\nSwiftUI提供的[WKInterfaceObjectRepresentable](https://developer.apple.com/documentation/swiftui/wkinterfaceobjectrepresentable)，实际上它只允许你去绑定一些已有的系统UI到SwiftUI中（因为SwiftUI目前还不支持这些控件，比如InlineMovie，MapKit，不排除以后有原生实现）。这些对应的WatchKit Interface Object，在watchOS 6上面都加入了对应的init初始化方法，允许你代码中动态创建，这里是全部的列表：\n\n+ WKInterfaceActivityRing\n+ WKInterfaceHMCamera\n+ WKInterfaceInlineMovie\n+ WKInterfaceMap\n+ WKInterfaceMovie\n+ WKInterfaceSCNScene\n+ WKInterfaceSKScene\n\n桥接了Interface Object的View可以像普通的SwiftUI View一样使用，常见的SwiftUI的modifier（比如`.frame`, `.background`）也可以正常work。但是有一些系统UI有着自己提供的最小布局（比如MapKit），超过这个限制会导致渲染异常，建议采取scaleTransform处理。另外，请不要同时调用Interface Object的setWidth等概念等价的布局方法，这会导致更多的问题。\n\n### 桥接原理\n\n上文提到的所有可动态创建的Interface Object，根据我们之前的探索，它现在是没有绑定任何viewControllerID的，具体SwiftUI是怎么做的呢？\n\n答案是，SwiftUI会对这些init创建的interfaceObject，手动通过UUID构造一个单独的新字符串，然后用这个UUID，创建一个新ViewController到WatchKit App中，插入到对应HostingController的视图栈里面。\n\n它的初始化UI状态，通过一个单独的属性拿到（由每个子类实现，比如MapView，默认的经纬度是0,0）。整体伪代码如下：\n\n```objectivec\n@implementation WKInterfaceMap\n- (instancetype)init {\n    NSString *UUID = [NSUUID UUID].UUIDString;\n    NSString *property = [NSString stringWithFormat:@\"%@_%@\", [self class], UUID];\n    return [self _initForDynamicCreationWithInterfaceProperty:property];\n}\n\n- (NSDictionary *)interfaceDescriptionForDynamicCreation {\n    return @{\n        @\"type\" : @\"map\",\n        @\"property\" : self.interfaceProperty,\n    };\n}\n@end\n```\n\n\n另外，这种使用init注册的WKInterfaceObject，会保留一个对应UIView的weak引用，可以在运行时通过私有的`_interfaceView`拿到。SwiftUI内部在布局的时候也用到了这个Native UIView来实现。\n\n![watchkit-swiftui2](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2019-12-10/image/watchkit-swiftui2.png)\n\n### SwiftUI与watchOS Native App\n\n通过从Native watchOS App的布局分析上来看，SwiftUI参考iOS上的方案，依旧是用了一个单独的UIHostingView来插入到Native App的视图层级中，也有对应的UIHostingController。\n\n但是不同于iOS的是，SwiftUI会对每一个Push/Present出来的新View（与是否用了上面提到的WKInterfaceObjectRepresentable无关，这样设计的原因见下），额外套了一个叫做[SPHostingViewController](https://github.com/LeoNatan/Apple-Runtime-Headers/blob/master/watchOS/Frameworks/WatchKit.framework/SPHostingViewController.h)的类，它继承自上文提到的SPViewController。\n\n每个UIHostingController套在了SPHostingViewController的Child VC中，对应View通过约束定成一样的frame，可以看作是一个容器的关系。\n\n![watchkit3](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2019-12-10/image/watchkit3.jpg)\n\n当你的SwiftUI View，含有至少一个WatchKit Interface Object之后，这个SPHostingViewController就起到了很大作用。它需要调度和处理上文提到的WatchKit消息。SPHostingViewController内部存储了所有interface的property，Native UIView列表，通过遍历来进行分发，走普通的WatchKit流程。它相当于起到一个转发代理的作用，让这些WatchKit的Interface Object实现不需要修改代码能正常使用。\n\n![watchkit-swiftui1](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2019-12-10/image/watchkit-swiftui1.jpeg)\n\n\n### SwiftUI与Long-Look Notification\n\n到这里其实事情还算简单，但是还有一种更为复杂的情形。SwiftUI支持创建自定义的watchOS Long-Look UI。它提供了一个对应的WKUserNotificationHostingController（继承自WKUserNotificationInterfaceController），就像WatchOS App一样。\n\n但是，试想一下：既然SwiftUI支持桥接系统Interface Object，如果我在这里的HostingView中，再放一个WatchKit Interface Object，会怎么样呢？答案依然是支持。\n\nSPHostingViewController这个类兼容了这种极端Case，它转发所有收到的Remote/Local Notification，承担了原本WatchKit的WKUserNotificationInterfaceController的一部分责任（因为继承链的关系，它不是WKUserNotificationInterfaceController子类，但是实现了类似的功能）。因此实际上，SPHostingViewController内部除了上面提到的property, Native UIView列表外，还存储了对应Notification Action的列表，用于转发用户点击在通知上的动作来刷新UI。\n\n## Independent watchOS App\n\n在历史上，所有的watchOS App，都必须Bundle在一个iOS App中，换句话说，就算你的watchOS App是一个简单的计算器，不需要任何iPhone的联动和同步功能，你也必须创建一个能够在iOS上的App Store审核通过的App。因此制作一个watchOS App的前提变得更复杂，它需要一个iOS App。而且以这里的计算器来说，你不可以直接套一个简单空壳的iOS App，引导用户只使用Apple Watch，因为iOS App Store的审核将不会通过。这也是造成watchOS App匮乏的一个问题。\n\n从watchOS 6之后，由于上述的一系列开发工具上和模式上的改动，苹果听取了开发者的意见，能够允许你创造一个独立的watchOS App，它不再不需要任何iOS App，直接从Apple Watch上安装，下载，运行。watchOS App也不再必须和iOS App有所关联。\n\n### 开发配置\n\n将一个已有的非独立watchOS App转变为独立App比较简单，你只需要在Xcode中选中的watchOS Extension Target，勾选`Supports Running Without iOS App Installation`即可。\n\n注意，独立watchOS App目前并不意味着你不能使用WatchConnectivity来同步iPhone的数据。你依然可以在你的Extension Target中声明你对应的iOS App的Bundle ID。\n\n注意，如果用户没有下载这个watchOS App对应的iOS App，那么WatchConnectivity的`WCSession.companionAppInstalled`的方法会直接返回NO，就算强制调用`sendMessage:`，也会返回不可用的Error，在代码里面需要对此提前判断。\n\n### App Slicing\n\n独立watchOS App会利用App Slicing，而非独立App不会。Apple Watch从Series 4开始采取了64位的CPU，而与此同时，由于用户的iPhone的CPU架构和Apple Watch的CPU架构是无关的（你可以在iPhone 11上配对一个Apple Watch Series 3，对吧），而watchOS App又是捆绑在ipa中的，这就导致你的ipa包中，始终会含有两份watchOS的二进制（armv7k arm64_32），用户下载完成后，在同步手表时只会用到一份，并且原始ipa中依旧会保留这份二进制。这是一种带宽和存储浪费。\n\n对于独立watchOS App，可以直接从watchOS App Store下载，那么将只下载Slicing之后的部分，节省近一半的带宽/存储。值得注意的是，就算是独立watchOS App，依然可以从iPhone手机上操作，来直接安装到Apple Watch中，因为在Apple Watch小屏幕上的App Store搜索文本和语音输入的体验并不是很好。\n\n## 总结\n\n通过上面完整的原理分析，可以看到，WatchKit这一个UI框架，通过一种客户端/服务端的方案，由于抽象了连接，即使watchOS 1到watchOS 2产生了如此大的架构变化，对上层的API基本保持了相对不变。这一点对于库开发者值得参考，通过良好的架构设计能够平滑迁移。\n\n不过实际从各个社交渠道的反馈，开发者对于WatchKit的态度并不是那么乐观，由于隐藏了所有真正能够操作屏幕像素的方案（无法使用Metal这种底层接口，也没有UIKit这种上层接口），导致WatchOS App的生态环境实际上并不是那么理想，很多App都是非常简单和玩具级别的项目。虽然这是可以归因于Apple Watch本身硬件性能的限制，但是和WatchKit提供的接口也脱离不了关系。\n\n如果让我来重新设计WatchKit，可能在watchOS 2时代，就会彻底Deprecate目前的WatchKit，而是取而代之采取公开精简的UIKit实现来让开发者最大化利用硬件（类似于目前的UIKit在tvOS上的现状），同时，提供一个新的WatchUIKit来提供所有专为Apple Watch设计的UI和功能，比如Digital Crown，比如Activity Ring。\n\n![watchkit-twitte](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2019-12-10/image/watchkit-twitter.jpg)\n\nSwiftUI为watchOS App提供了一个新的出路，它可以说是真正的能够发挥开发者能力来实现精致的App，而不再受限于系统提供的基本控件。而WatchKit，也已经完成了它的使命。相信之后的SwiftUI Native App将会为watchOS创造一片新的生态，Apple Watch也能真正摆脱“iPhone外设”这一个尴尬的局面。\n\n## 参考资料\n\n+ [App Programming Guide for watchOS](https://developer.apple.com/library/archive/documentation/General/Conceptual/WatchKitProgrammingGuide/index.html)\n+ [WatchKit Catalog Example](https://developer.apple.com/library/archive/samplecode/WKInterfaceCatalog/Introduction/Intro.html)\n+ [NSHipster - WatchKit](https://nshipster.com/watchkit/)\n+ [WWDC - SwiftUI on watchOS](https://developer.apple.com/videos/play/wwdc2019/219/)\n+ [SwiftUI Tutorials - Creating a watchOS App](https://developer.apple.com/tutorials/swiftui/creating-a-watchos-app)\n+ [iOS Runtime Headers](http://developer.limneos.net)","categories":["iOS"],"tags":["iOS","watchOS","SwiftUI","WatchKit"]},{"title":"Web入门后端架构有感——Node.js","url":"/2016/03/30/Web%E5%85%A5%E9%97%A8%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E6%9C%89%E6%84%9F%E2%80%94%E2%80%94Node-js/","content":"\n说来也是惭愧，从大一暑假接触到第一门Web后端语言——PHP之后，自己对Web应用程序的认识却一直没有多大改变，对整个Web服务器的运行也没有清晰的概念。不过，这个大二的寒假里面，由于需要架设一个Web多人协作编辑平台，我接触到了这个非常热门尽管国内应用不多的后端架设方式——`Node.js`\n\n说到Node.js，其实很多人也都知道，一个JavaScript在本地的运行时，基于Google的V8引擎。很可惜，由于自己当时学习Web主要走的后端路线，自己对JavaScript的认识也就靠的是w3school的简单说明和了解以及简单的jQuery用法罢了。学Node.js对我印象最大的，就是事件驱动的回调函数。（其实还是与自己并未真正接触到函数式编程有关）\n\n举个例子，就是最简单的Hello World Web应用程序。 \n\n```javascript\nvar http = require(\"http\");\n\nhttp.createServer(function(request, response) {\n  response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n  response.write(\"Hello World\");\n  response.end();\n}).listen(8888);\n```\n\n在JavaScript里面，函数是和变量同地位的一等公民，它可以被传递进当为参数，这种写法初次接触JavaScript的人肯定感觉非常不适应（尤其从Java,PHP转来的），不过习惯之后便发现这样带来了不错的易读性。这里面，那个匿名函数function(request,response)就是一个回调函数，Node.js内置的http对象通过listen进行8888端口的监听，一旦有任何访问便会调用这个回调函数，执行那三行来发送一个Hello World的HTML文本回去\n\nNode.js编写Web程序的体验绝对是Java和PHP很难达到的，因为你不仅要写一个Web应用程序，必须自己写一个HTTP服务器程序。不过这也意味着你可以干更多的事而不用局限于PHP这种解释器一样执行的代码，很多人甚至不知道在一行简单的echo \"Hello World!\" 的背后的Web应用程序究竟是怎样工作的，你也可以不用再和Apache，Nginx这种Web应用程序的使用打交道，你可以自己写一个类似的出来，定制化更高。   上面关于Node.js的简单认识也就先这样，下面我想说说关于Web应用程序的非常简单的架构组织。\n\n一个Web应用程序，可以分这几个模块来进行编写： \n\n1.  **HTTP模块**\n2.  **路由模块**\n3.  **请求处理模块**\n4.  **数据库模块**\n5.  **外部模块**\n\n\n结合MVC模式，可以在请求处理模块这个大模块中进行分层，专门分出View层（使用模版来生成HTML也好，直接生成也好），Controller层（进行一定的业务逻辑判断），Model层（一般抽象出来的类来封装数据，包括了数据库，IO，外部数据等）。\n\n简单的说明一下：首先需要一个HTTP服务器模块，通过监听计算机的端口（一般是80端口）来发现所有对80端口的访问。正如上面的http.listen()一样。 \n\n```javascript\nvar express = require('./node_modules/express/lib/express');\nvar app = express();\napp.listen(80);\n```\n\n接下来，你便需要一个简单的路由模块。所谓路由，就是把对不同URL的访问根据URL的不同，指派给不同的请求处理程序来进行相应功能的使用。比如`http://dreampiggy.com/help`这个URL，你可以获取/help来指定用一个专门负责帮助说明的请求处理程序，返回一个关于帮助说明的HTML页面。对Web应用非常重要的Ajax访问的接口一般也是特定的URL，当然，需要POST/GET过来一定的AppID和Session来防止其他人恶意调用。 \n\n```javascript\nif(pathname == \"/\"){\n\thandler.home(request,response);\n}\nelse{\n\tresponse.writeHead(404,{\"Content-Type\":\"text/plain\"});\n\tresponse.write(\"404 not found\");\n\tresponse.end();\n}\n```\n\n路由的目的一般就是把URL请求分离出各参数，然后向请求处理程序传递，不推荐在这个模块进行过多的判断处理。对于请求处理程序而言，就是主要我们需要写Web应用的地方。我们可以通过MVC的方式进行分层，这时候就是你大展伸手的时候了。请求处理程序的Model层少不了和数据库打交道，不过我还是推荐把数据库访问抽象出来，放到一个新的模块，用请求处理模块来调用它。Node.js的模块导出和函数导出也是非常常见的，合理运用让自己的Web应用逻辑更为清晰。\n\n外部模块包含很多，比如你要对XSS注入加以防范，可以通过一定的外部XSS模块或者自己手写一个XSS来使用，然后在请求处理程序的View层进行过滤（当然这种做法不是很好，简单举例）。使用Node.js的一大好处就是你可以随时加入很多非常好的他人写好的模块（npm大法），而且对于不满意的地方自己进行修改，可以加快开发进度（比如我这个协作编辑平台需要的Markdown语法解析器就是用他人的加以改造的）\n\n题外话，对于习惯OO的人来说，JavaScript在继承，多态方面等常见OO的用法上面比较薄弱，而且又由于JavaScript的弱类型语言，你不能使用重载函数来对不同的参数进行判断，所以建议对于Node.js来说，可以使用比如typeof来进行判断再加以封装，多态方面可以通过虚函数来使用。JavaScript透露出的函数式编程还需要我一点点理解，正所谓学什么语言用什么语言思考，谨记不要随意就把PHP/Java的套路往JavaScript上套。\n\n就到这吧……或许几个月回过头来看这篇文章基本是废话，不过这确实是现在的我的一点感悟。\n\n**学才能深入，才能知不足。**","categories":["Web"],"tags":["JavaScript","Node.js"]},{"title":"Web幻灯片利器（前端工程师福利）——NodePPT","url":"/2016/03/30/Web%E5%B9%BB%E7%81%AF%E7%89%87%E5%88%A9%E5%99%A8%EF%BC%88%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%A6%8F%E5%88%A9%EF%BC%89%E2%80%94%E2%80%94NodePPT/","content":"\n提到幻灯片，人人第一直觉就想到一个东西：PPT（Microsoft Office PowerPoint），也许还有人可能会小声说到 Keynote，或者Prezi，能提到reveal.js的基本少之又少……\n\nPowerPoint：http://products.office.com/zh-CN/powerpoint\n\nKeynote：http://www.apple.com/cn/mac/keynote\n\nPrezi：http://prezi.com\n\nreveal.js：http://lab.hakim.se/reveal-js\n\n不过，常年用这些东西，未免也太”Low”了，我们需要追求更Fasion的幻灯片制方法。\n\n那么，就轮到我们今天的主角登场：NodePPT\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/9/7c/5f478c96f02982f6155b5206c40a3.png)\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/9/aa/6c75dff6a7972a25e3d7617b2fdbc.png)\n\n怎么样？Markdown语法支持，完美的响应式设计，多种切换动画随意上，自定义主题（CSS上手的时候到了），炫丽的双屏， 远程控制，你还在等什么？？\n\n使用起来很简单，GitHub上项目Fork一下，然后用在ppts/demo.md里面，按照Markdown语法写你的PPT内容，然后找一个服务器挂起来运行起来就O了，像我这种穷人只好再依靠SAE啦～\n\nGitHub上地址链接：**https://github.com/ksky521/nodePPT**\n\n其实现在这个东西还有一些小小的Bug（比如连按下一页，有些提醒动画会不消失……Overview模式下部分页面的切换动画还会显示等等……），希望有致人一起贡献一下，更加完善此项目～","categories":["Web"],"tags":["Node.js","Web","前端"]},{"title":"Web项目3-基于Node.js的多人协作编辑平台的设计实现","url":"/2016/03/30/Web%E9%A1%B9%E7%9B%AE3-%E5%9F%BA%E4%BA%8ENode-js%E7%9A%84%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C%E7%BC%96%E8%BE%91%E5%B9%B3%E5%8F%B0%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0/","content":"\n终于，我参加的第三个Web项目基本已经完成了Beta版本的整体架构和实现。\n\n这次的Web项目要求，是制作一个基于Web（或者移动Web）的在线协作编辑平台，主要支持Markdown语法及同步预览，类似于<a title=\"Google Docs\" href=\"https://docs.google.com/document\" target=\"_blank\">Google Docs</a>或者<a title=\"Office Online\" href=\"https://office.live.com/start/default.aspx\" target=\"_blank\">Office Online</a>这样的东西（但是绝对不可能达到国际一流大厂的水平）\n\n由于只有我们4个人开发（其中2个还算专门前端开发），所以尽可能减少后端开发压力，经过初步的讨论，最终选择了使用Node.js作为后端开发语言。Node.js强力的非阻塞IO和异步事件非常适合我们这种IO密集型的应用。而对于协作的部分，我们选择使用<a title=\"socket.io\" href=\"http://socket.io/\" target=\"_blank\">socket.io</a>来进行这种密集文本数据的通信和广播，也能很大的减少开发周期。\n\n嘛，整体架构大概这样，虽然很丑陋，对于我这种没有实际架构Web经验以及Beta版来说，已经足够了。\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/e/bc/22d0e801243e1c22305ce85f897b3.png)\n\n话不多说，作为一个多人编辑的平台，首先就需要传统的Web应用的老三样：用户管理，文档管理，项目管理，今天就主要说这些。\n\n\n### **一、用户管理**\n\n作为最基础的Web提供的服务，也许不用多说，用PHP当年也是基本这个样子，包括注册登录，信息验证，加上增删改查(REST) <span style=\"font-size: 13px;\"> </span> 借助于Node的模块导出(Module.exports)，我们可以把不同层次的模块分层，比如说，我们可以建立一个user.js模块，存储底层的对user数据库的操作，在上层的account.js模块中直接进行整合，达到上层的用户注册，登陆，编辑，查询，删除，邀请，接受，拒绝的功能。\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/4/2c/cbc5296c83216b037c0bd6ac607d0.png)\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/8/fd/7de6621bfaa012093edbdc6194923.png)\n\n上篇已经说过，Node.js是异步事件编程的，所有对数据库的访问都是异步的，也就是说你不能用同步编程控制顺序来进行验证。怎么办呢？两种方法，要么用回调函数处理（对于著名的callback hell问题，可以使用<a title=\"async\" href=\"https://github.com/caolan/async\" target=\"_blank\">async</a>或者Promises处理，如<a title=\"Q\" href=\"https://github.com/kriskowal/q\" target=\"_blank\">Q</a>），个人的丑陋方法是通过将数据库查询结果传入回调函数来进行调用，分层调用起来也能向面向对象时候使用对象调用一样方便。\n\n信息验证，主要就是指Session，关于这个可以在之后写一下，在此只提供方法：我使用Redis数据库来存取sessionID，存入一个Hashmap中，顺便可以绑定一些常用的信息，比如验证码，状态，减少对MySQL数据库的压力。相关的用法可以查阅：<a title=\"node-redis\" href=\"https://github.com/mranney/node_redis\" target=\"_blank\">node-redis</a>、<a title=\"express-session\" href=\"https://github.com/expressjs/session\" target=\"_blank\">express-session</a>、<a title=\"cookie-parser\" href=\"https://github.com/expressjs/cookie-parser\" target=\"_blank\">cookie-parser</a>等\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/0/fd/64e2f6885fda48496392b72787e42.png)\n\n### **二、文档管理**\n\n做为比较重要的文档管理，其实也莫过于增删改查四个接口，只不过所有修改你当然需要对用户进行验证，所以这里在设计时需要数据库同步user表的内容到docs表，而且验证的时候可以复用user.js模块中的验证。\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/9/b4/c5f6392ba72369c19f6ffb1eaa5ef.png)\n\n这里现在是第一版的，之后我会写怎么讲markdown文本内容转入Redis数据库，来满足实时协作编辑的需要。甚至为了功能可以提供一个预览文档的功能，在Redis中进行缓存，可以快速的提取预览，减少对真正读写文档的IO压力。\n\n### **三、项目管理**\n\n项目管理，当然不再是简单的增删改查啦，不过还是REST那一套，你只需要复用user.js和docs.js中对于文档，对于用户的接口，然后再次封装一下，就可以满足文档的管理（主要是项目新建，删除，编辑，项目用户邀请，权限管理-这个暂时没做，项目中新建文档，查询文档，编辑文档，删除文档这几个接口），数据库表也就随意做一个\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/0/f2/f8a644c7bd838a96205147c28a7bf.png)\n\n主要的接口大概就是这些，配合路由以及Session验证，就可以出来一个简单的API调用。对于我们这个项目，路由就是这种丑陋的写法：\n\n```javascript\n\tapp.post('/api/user/register',function(req,res){\n\t\thandler.userRegister(req,res);\n\t});\n//User Login\n\tapp.post('/api/user/login',function(req,res){\n\t\thandler.userLogin(req,res);\n\t});\n//User Captcha\n\tapp.get('/api/user/captcha',function(req,res){\n\t\thandler.userCaptcha(req,res);\n\t});\n//User Logout\n\tapp.post('/api/user/logout',function(req,res){\n\t\thandler.userLogout(req,res);\n\t})\n//User Info\n\tapp.post('/api/user/info',function(req,res){\n\t\thandler.userInfo(req,res);\n\t});\n//User Invite\n\tapp.post('/api/user/invite',function(req,res){\n\t\thandler.userInvite(req,res);\n\t});\n//User Accept\n\tapp.post('/api/user/accept',function(req,res){\n\t\thandler.userAccept(req,res);\n\t});\n//User Reject\n\tapp.post('/api/user/reject',function(req,res){\n\t\thandler.userReject(req,res);\n\t});\n```\n\n而最后handler负责对路由来的请求进行验证，进行缓存，以及进行POST参数提取，静态文件返回等等这种中间件的杂事，controller不需要request对象，model不需要request和response对象两者，这样也能减少藕合度，便于单元测试。（其实感觉这层和controller有重复，不过暂时先这样，加快开发）\n\n一些小东西，比如说验证码，session处理什么的，灵活使用网上的node_modules进行封装，然后便可以快速使用了，想要了解底层实现也可以自己看看源码，对之后开发很重要。\n\n说实话，Node开发比当年用PHP开发难度要大，因为你不可避免要接触到很多HTTP协议的规定，网络编程的知识，而PHP就是纯粹一个模版让你使用，不需要太多编程或者网络知识，对深入学习其实是很不利的。当年对于PHP中Session的理解就是`$_SESSION['name']`这样用，然后另一个也看就可以访问到，却不知道Session的原理，真是太天真了……\n\n先到这里吧，下一篇主要说明\n\n**如何设计协作以及对<a title=\"socket.io\" href=\"http://socket.io\" target=\"_blank\">socket.io</a>的使用**，来满足实时协作编辑。","categories":["Web"],"tags":["JavaScript","Node.js","Web"]},{"title":"Xcode LLDB耗时监控统计方案","url":"/2022/09/07/Xcode-LLDB%E8%80%97%E6%97%B6%E7%9B%91%E6%8E%A7%E7%BB%9F%E8%AE%A1%E6%96%B9%E6%A1%88/","content":"\n# 声明\n\n此篇文章在字节跳动的技术公众号已经刊登：[《字节跳动DanceCC工具链系列之Xcode LLDB耗时监控统计方案》](https://mp.weixin.qq.com/s/4DgbZosBit-kTVhYMwRlHw)\n\n# 背景介绍\n\n在[《Swift 调试性能的优化方案 》](https://dreampiggy.com/2022/05/07/Swift-%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/)一文中，我们介绍了如何使用自定义的工具链，来针对性优化调试器的性能，解决大型Swift项目的调试痛点。\n\n在经过内部项目的接入以及一段时间的试用之后，为了精确测量经过优化后的LLDB调试Xcode项目效率提升效果，衡量项目收益，需要开发一套能够同时获取Xcode官方工具链与DanceCC工具链调试耗时的耗时监控方案。\n\n一般来说，LLDB内置的工作耗时，可以通过输入log timers dump来获取粗略的累计耗时，但是这个耗时只包括了源代码中插入了LLDB_SCOPED_TIMER()宏的函数，并不代表完整的真实耗时。并且这个耗时统计需要用户手动触发，如果要单独获取某次操作的耗时还需要先进行reset操作清空之前的耗时记录；对于我们目前的需求而言不够精确也不够自动。\n\n因此DanceCC提出了一套专门的方案。方案原理基于[LLDB Plugin](https://reviews.llvm.org/rG4272cc7d4c1e1a8cb39595cfe691e2d6985f7161)，利用[Fishhook](https://github.com/facebook/fishhook)，从LLDB的[Script Bridge API](https://lldb.llvm.org/design/sbapi.html)层面拦截Xcode对LLDB调用，以此来进行耗时监控统计。\n\n注：LLDB论坛也有贡献者，讨论另一套内置的[LLDB metries方案](https://discourse.llvm.org/t/rfc-lldb-telemetry-metrics/64588)，但是目标侧重点和我们略有不同，并且截至发稿日未有完整的结论，因此仅在引用链接提及供读者延伸阅读。\n\n# 方案原理\n\n## LLDB Plugin\nApple在其LLDB和早期Xcode集成中，为了不侵入一些容易改动的上层逻辑，引入了LLDB Plugin的设计和支持。\n\n每个Plugin是一个动态链接库，需要实现特定的C++/C入口函数，由LLDB主进程在运行时通过dladdr找到函数入口并加载进内存。目前有两种Plugin的接口形式（网上常见第一种）\n\n- 新Plugin接口：\n\n```cpp\nnamespace lldb {\nbool PluginInitialize(SBDebugger debugger);\n}\n```\n\n这种Plugin，需要用户在脚本中手动按需加载，并常驻在内存中：\nplugin load /path/to/plugin.dylib\n\n- 老Plugin接口：\n\n```c\nextern \"C\" bool LLDBPluginInitialize(void);\nextern \"C\" void LLDBPluginTerminate(void);\n```\n\n将编译的动态库放入以下两个目录，即可自动被加载，无法手动控制时机，在当前调试Session结束时卸载：\n\n```\n/path/to/LLDB.framework/Resources/Plugins\n~/Library/Application Support/LLDB/PlugIns\n```\n\n## 注入动态库\n![1](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-09-07/images/1.png)\n\n正常流程中，Xcode开始调试时会启动一个lldb-rpc-server的进程，这个进程会加载Xcode默认工具链，或指定工具链中的LLDB.framework，并且通过这个动态库中暴露出的Script Bridge API调用LLDB的各功能。\n\n![2](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-09-07/images/2.png)\n\n监控流程中，我们向lldbinit文件中添加了`command script import ~/.dancecc/dancecc_lldb.py`，用于在LLDB启动时加载脚本，脚本内会执行`plugin load ~/.dancecc/libLLDBStatistics.dylib`，加载监控动态库。\n\n监控动态库在被加载时，因为被加载的动态库和LLDB.framework不在一个MachO Image中，我们能够通过Fishhook方案，对LLDB.framework暴露出的我们关心的Script Bridge API进行hook。\n\nhook成功之后，每次Xcode对Script Bridge API进行调用都会先进入我们的监控逻辑。此时我们记录时间戳来计时，然后再进入LLDB.framework中的逻辑，获取结果后返回给lldb-rpc-server，并在Xcode的GUI中展示。\n\n## Hook SB API\nHook SB API时，需要一份含有要部署的LLDB.framework的头文件（Xcode并未内置）。由于上述的流程使用了动态链接的LLDB.framework，我们选择了Swift 5.6的产物，并tbd化避免仓库膨胀。\n\n由于LLDB Script Bridge API相对稳定，因此可以使用一个动态库实现，通过运行时来应对不同版本的API变化（极少出现，截止发文调研5.5~5.7之间Xcode并没有改变调用接口）。\n\n对于hook C++函数的方式，这里借用了Fishhook进行替换。原C++的函数地址，可通过dlsym调用得到。注意C++函数名使用mangled后的名称（在tbd文件中可找到）。\n\n```cpp\n///\n/// Hook a SB API using the stub method defined with the macros above\n///\n#define LLDB_HOOK_METHOD(MANGLED, CLASS, METHOD) \\\nLogger::Log(\"Hook \"#CLASS\"::\"#METHOD\" started!\"); \\\nptr_##MANGLED.pvoid = dlsym(RTLD_DEFAULT, #MANGLED); \\\nif (!ptr_##MANGLED.pvoid) { \\\n    Logger::Log(dlerror()); \\\n    return; \\\n} \\\nif (rebind_symbols((struct rebinding[1]){{#MANGLED, (void *) hook_##MANGLED, (void **) & ptr_##MANGLED.pvoid }}, 1) < 0) { \\\n    Logger::Log(dlerror()); \\\n    return; \\\n} \\\nLogger::Log(\"Hook \"#CLASS\"::\"#METHOD\" succeed!\");\n```\n\nC++的成员函数的函数指针第一个应该是this指针，这里用self命名。也可以调用原实现先获取结果，再根据结果进行相关的统计逻辑。\n```cpp\n///\n/// Call the original implementation for member function\n///\n#define LLDB_CALL_HOOKED_METHOD(MANGLED, SELF, ...)  (SELF->*(ptr_##MANGLED.pmember))(__VA_ARGS__)\n最终整体代码中Hook一个API就可以写为：\n// 假设期望Hook方法为：char * ClassA::MethodB(int foo, double bar)\n// 这里写被Hook的方法实现\nLLDB_GEN_HOOKED_METHOD(mangled, char *, ClassA, MethodB, int foo, double bar) {\n  return LLDB_CALL_HOOKED_METHOD(mangled, self, 1, 2.0);\n}\n// 这里是执行Hook（只执行一次）\nLLDB_HOOK_METHOD(mangled, ClassA, MethodB);\n```\n\n# 耗时监控场景\n\n目前耗时监控包含下列场景：\n- 展示frame变量\n- 展开变量的子变量\n- 输入expr命令（p, po命令也是expr命令的alias）\n- Attach进程耗时\n- Launch进程耗时\n\n## 展示frame变量场景\n经过观察，我们发现当在Xcode中进入断点，GUI显示当前frame的变量时，lldb-rpc-server调用SB API的流程为先调用`SBFrame::GetVariables`方法，返回一个表示当前frame中所有变量的SBValueList对象，然后再调用一系列方法获取它们的详细信息，最后调用`SBListener::GetNextEvent`等待下一个event出现。\n\n因此我们计算展示frame变量的流程为，当`SBFrame::GetVariables`方法被调用时记录当前时间戳，等待直至`SBListener::GetNextEvent`方法被调用，再记录此时时间戳算出耗时。\n\n## 展示子变量场景\n经过观察，我们发现当在Xcode中展开变量，需要显示当前变量的子变量时，lldb-rpc-server调用SB API的流程为先调用SBValue::GetNumChildren方法，返回表示当前变量中子变量的数目，然后再调用`SBValue::GetChildAtIndex`获取这些子变量以及它们的的详细信息，最后调用`SBListener::GetNextEvent`等待下一个event出现。\n\n因此我们计算展示frame变量的流程为，当`SBValue::GetNumChildren`方法被调用时记录当前时间戳，等待直至`SBListener::GetNextEvent`方法被调用，再记录此时时间戳算出耗时。\n\n## 输入expr命令场景\nXcode中用户直接从debug console中输入LLDB命令的方式是不走SB API的，因此无法直接通过hook的方式获取耗时。我们发现大多数开发者，都习惯在debug console中使用po/expr等命令而不是GUI点击输入框。因此我们专门做了支持，通过SB API的OverrideCallback方法进行了拦截。\n\nLLDB.framework暴露了一个用于注册在LLDB命令前调用自定义callback的接口：`SBCommandInterpreter::SetCommandOverrideCallback`；我们利用了这个接口注册了一个用于拦截并获取用户输入命令的callback函数，这个callback会记录当前耗时，然后调用`SBDebugger::HandleCommand`来处理用户输入的命令。但是当`SBDebugger::HandleCommand`被调用时，我们注册的callback一样会生效，并再次进入我们拦截的callback流程中。\n\n为了解决这个递归调用自己的问题，我们通过一个`static bool isTrapped`变量表示当前进入的expr命令是否被OverrideCallback拦截过。如果未被拦截，将isTrapped置true表示expr命令已经被拦截，则调用HandleCommand方法重新处理expr命令，此时进入的HandleCommand方法同样会被OverrideCallback拦截到，但是此时isTrapped已经被置true，因此callback返回false不再进入拦截分支，而是走原有逻辑正常执行expr命令\n![3](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-09-07/images/3.png)\n\n\n## Attach进程场景\nAttach进程时，lldb-rpc-server会调用SBTarget::Attach方法，常见于真机调试的场景。\n这里在调用前后记录时间戳，计算出耗时即可。\n\n## Launch进程场景\nLaunch进程时，lldb-rpc-server会调用SBTarget::Launch方法，常见于模拟器启动并调试的场景。\n这里在调用前后记录时间戳，计算出耗时即可。\n\n# 上报部分\n\n## 数据上报\n为了进一步还原耗时的细节，除了标记场景的类型以外，我们还会统一记录这些非敏感信息：\n\n- 正在调试的进程名，用于区分多调试Session并存的场景\n- 正在调试的App的Bundle ID\n- 当前断点位置在哪个文件\n- 当前断点位置在哪一行\n- 当前断点位置在哪个函数\n- 当前断点位置在哪个Module\n- 表示当前使用的工具链是Xcode的还是DanceCC的\n- 表示当前使用的Swift版本（与Xcode版本一一对应）\n\n在内网提供的版本中，也通过外部环境变量，得知对应的App的仓库标识，用于在内网的数据统计平台上展示和区分。\n\n如图，这是内网大型Swift工程，飞书iOS App接入DanceCC工具链之后，某时间的耗时数据，可以明显看出，DanceCC相比于Xcode的变量显示耗时，优化了接近一个数量级。\n![4](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-09-07/images/4.png)\n![5](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-09-07/images/5.png)\n\n## 极端耗时场景堆栈收集\n\n除了基本的耗时时间收集以外，我们还希望能够及时发现新增的极端耗时场景和新问题，因此设计了一套极端耗时情况下的调试器堆栈收集机制，目前只要发现，展示变量场景和输入expr命令耗时超过10秒种，则会记录LLDB.framework的当前调用堆栈的每个函数耗时，并将数据上报到后台进行统计和人工分析。\n\n堆栈收集使用了log timers dump所产出的堆栈和耗时信息，本质上是LLDB代码中通过`LLDB_SCOPED_TIMER()`宏记录的函数，其会使用编译器的`__PRETTY_FUNCTION__`能力来在运行时得到一个用于人类可读的函数名。\n\n在获取到调用前和调用后的两条堆栈后，我们会对每个函数进行Diff计算和排序，将最耗时的前10条进行了采样记录，使用字符串一同上传到统计后台中。\n![6](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-09-07/images/6.png)\n\n# 总结\n无论是App还是工具链，在做性能优化的同时，数据指标建设是必不可少的。这篇文章讲述的监控方案，在后续迭代DanceCC工具链的时候，能够明确相关的优化对实际的调试体验有所帮助，能避免了主观和片面的测试来评估调试器的可用性。\n\n除了调试器之外，DanceCC工具链还包括诸如链接器，编译器，LLVM子工具（如dsymutil）等相关优化，系列文章也会进一步进行相关的分享，敬请期待。\n\n# 引用链接\n1. https://mp.weixin.qq.com/s/MTt3Igy7fu7hU0ooE8vZog\n2. https://reviews.llvm.org/rG4272cc7d4c1e1a8cb39595cfe691e2d6985f7161\n3. https://github.com/facebook/fishhook\n4. https://lldb.llvm.org/design/sbapi.html\n5. https://discourse.llvm.org/t/rfc-lldb-telemetry-metrics/64588\n","categories":["LLVM"],"tags":["swift","lldb","llvm"]},{"title":"Xcode自带的UI调试工具","url":"/2016/05/30/Xcode%E8%87%AA%E5%B8%A6%E7%9A%84UI%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/","content":"\n## Xcode or Reveal\n\n在iOS开发中，UI调试总是一个大问题……原始的暴力调试（View强行着色然后看，或者在@Selector中直接把`viewForLastBaselineLayout`或者`viewForFirstBaselineLayout`）利用`Swizzle` Hook，然后Debug输出相应的内容（比如View的属性，描述符等等）。\n\n这是一个好方法……但是过于暴力，而且非常不直观。虽然iOS开发者都知道的[Reveal](http://revealapp.com)是好东西，然而价格并不是人人都买得起……（不过对iOS专业开发者确实是一个必备的工具）。其实Xcode 7自带了一套UI调试的工具，熟悉使用之后也是非常好用。\n\n## 使用\n\n使用方法很简单，首先自然得运行项目，然后Run(Command R)，然后切换到Debug栏(Command 6)，点击左边栏最右侧的图表，选择`View UI Hierarchy`即可。\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/d/b8/3ee5a4bd1289d16d36db566f3bf1e.png)\n\n### UI列表\n\n进入UI Debugger视图后，App会被lldb暂停，左侧为所有当前的UI对象，以及它们的继承顺序。注意，此时的UIView对象按照由上到下，对应了UIView的层级顺序（即UIView.subviews)，最上方为最底层的View（对应subviews atIndex 0)，最下方即当前的顶层视图。点击对应的UIView可以在右侧的图形化视图中看到。\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/a/72/a576918da1fc5658bccaab351b669.png)\n\n### 层级预览\n\n右侧的图形化视图，默认下是显示了所有视图以及它们的外边框，并且以实际显示(非3D层次)。点击下方的立方体按钮切换到3D预览（像不像Reveal？）\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/5/8b/c05da0308cc5f1b90e1ee80e14756.png)\n\n### 配合检查器\n\n点击控件也可在左侧标记出对象，可以在右侧的Object Inspector来查看它们的属性，还能看到不同View的约束在真实运行时候的表现状态，对于使用大量Autolayout和约束的应用来说非常方便。\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/0/4a/c340caefd7bd60c6deb7dd07eef43.png)\n\n## 总结\n\n怎么样，虽然相比Reveal虽然不能实时Debug，但可以用Debug的`Continue exec`来使App恢复再继续Debug……而且有着非常详细的图形化和属性检测，还有官方支持……对于大部分开发者来说基本足够了，也不必真心追求昂贵的Reveal来支持UI Debug。\n\n> 补充：Xcode 7自带的UI Debugger由于在对UIView绘图时，使用了在iOS 9才加入的`viewForFirstBaselineLayout`\n而iOS 8上使用的`viewForBaselineLayout`被deprecated，因此默认无法正确调试，如果需要在iOS 8及以下的模拟器或者真机上进行UI Debug，可以参考别人提供一个Swizzle替换\n\n```objectivec\n#ifdef DEBUG\n\n#import <UIKit/UIKit.h>\n#import <objc/runtime.h>\n\n@implementation UIView (FixViewDebugging)\n\n+ (void)load\n{\n    Method original = class_getInstanceMethod(self, @selector(viewForBaselineLayout));\n    class_addMethod(self, @selector(viewForFirstBaselineLayout), method_getImplementation(original), method_getTypeEncoding(original));\n    class_addMethod(self, @selector(viewForLastBaselineLayout), method_getImplementation(original), method_getTypeEncoding(original));\n}\n\n@end\n\n#endif\n```","categories":["iOS"],"tags":["iOS","Xcode","Debug"]},{"title":"iOS平台图片编解码入门教程（Image/IO篇）","url":"/2017/10/30/iOS%E5%B9%B3%E5%8F%B0%E5%9B%BE%E7%89%87%E7%BC%96%E8%A7%A3%E7%A0%81%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%88Image:IO%E7%AF%87%EF%BC%89/","content":"> 这篇教程是系列教程的第一篇，主要是面向于没有怎么接触过iOS平台上图像编解码的人的，不会涉及到多媒体处理中的数字信号处理、图像编码的深入知识。这是系列最简单的一篇，之后会有关于第三方编解码，以及vImage的另两篇教程。\n\n# Image/IO\nImage/IO是Apple提供的一套用于图片编码解码的系统库，对外是一层非常直观易用的C的接口。上层的UIKit，Core Image，还有Core Graphics中的CGImage处理，都是依赖Image/IO库的。因此，掌握Image/IO的基本编解码操作，对一些图像相关的数据处理是非常必要的。这篇教程就主要从简单的用法，说明Image/IO的用法，完整的文档，可以参考[Apple Image/IO](https://developer.apple.com/documentation/imageio)\n\n# 解码\n解码，指的是讲已经编码过的图像封装格式的数据，转换为可以进行渲染的图像数据。具体来说，iOS平台上就指的是将一个输入的二进制Data，转换为上层UI组件渲染所用的UIImage对象。\n\nImage/IO的解码，支持了常见的图像格式，包括PNG（包括APNG）、JPEG、GIF、BMP、TIFF（具体的，可以通过`CGImageSourceCopyTypeIdentifiers`来打印出来，不同平台不完全一致）。在iOS 11之后另外支持了HEIC（即使用了HEVC编码的HEIF格式）。\n\n对于解码操作，我们可以分为静态图（比如JPEG，PNG）和动态图（比如GIF，APNG）的两种，分别进行说明一下解码的过程。\n\n## 静态图\n静态图的解码，基本可以分为以下步骤：\n\n1. 创建CGImageSource\n2. 读取图像格式元数据（可选）\n3. 解码得到CGImage\n4. 生成上层的UIImage，清理\n\n### 1. 创建ImageSource\nCGImageSouce，表示的是一个待解码数据的输入。之后的一系列操作（读取元数据，解码）都需要到这个Source，与解码流程一一对应。\n\nCGImageSource可以通过不同的几个接口构造（这里先忽略渐进式解码的接口）：\n\n+ `CGImageSourceCreateWithData`： 从一个内存中的二进制数据（CGData）中创建ImageSource，相对来说最为常用的一个\n+ `CGImageSourceCreateWithURL`： 从一个URL（支持网络图的HTTP URL，或者是文件系统的fileURL）创建ImageSource，\n+ `CGImageSourceCreateWithDataProvider`：从一个DataProvide中创建ImageSource，DataProvider提供了很多种输入，包括内存，文件，网络，流等。很多CG的接口会用到这个来避免多个额外的接口。\n\n示例代码：\n\n```objectivec\nCGImageSourceRef source = CGImageSourceCreateWithData((__bridge CFDataRef)data, NULL);\nif (!source) { // 一般这时候都是输入图像数据的格式不支持\n    return nil;\n}\n```\n\n### 2. 读取图像格式元数据\n创建好CGImageSource之后，我们是可以立即解码。但是很多情况下，我们需要获取一些相关的图像信息，包括图像的格式，图像数量，[EXIF元数据](https://en.wikipedia.org/wiki/Exif)等。在真正解码之前，我们可以拿到这些数据，进行一些处理，之后再开始解码过程。\n\n其中，这些信息可以直接在CGImageSource上获取：\n\n+ 图像格式：`CGImageSourceGetType`\n+ 图像数量（动图）：`CGImageSourceGetCount`\n\n其他的，需要通过获取属性列表来查询。对于图像容器的属性（EXIF等），我们需要使用`CGImageSourceCopyProperties`即可，然后根据不同的Key去获取对应的信息。\n\n其实苹果还有一套`CGImageSourceCopyMetadataAtIndex`，对应的数据不是字典，而是一个`CGImageMetadata`，再通过其他方法去取。这套API使用起来也是可以的，读取数据和前者是完全兼容一致的，优点是能够进行自定义扩展（比如说你有非标准的图像信息想自己添加和删除）。一般来说使用前者就足够了。\n\n示例代码：\n\n```objectivec\nCGImageSourceRef source;\nNSDictionary *properties = (__bridge NSDictionary *)CGImageSourceCopyProperties(source, NULL);\nNSUInteger fileSize = [properties[kCGImagePropertyFileSize] unsignedIntegerValue]; // 没什么用的文件大小\n\nNSDictionary *exifProperties = properties[(__bridge NSString *)kCGImagePropertyExifDictionary]; // EXIF信息\nNSString *exifCreateTime = exirProperties[(__bridge NSString *)kCGImagePropertyExifDateTimeOriginal]; // EXIF拍摄时间\n```\n\n当然，前面这个指的是图像容器的属性，而真正的获取图像的元信息，需要使用`CGImageSourceCopyPropertiesAtIndex`，对于静态图来说，index始终传0即可。\n\n示例代码：\n\n```objectivec\nNSDictionary *imageProperties = (__bridge NSDictionary *) CGImageSourceCopyPropertiesAtIndex(source, 0, NULL);\nNSUInteger width = [imageProperties[(__bridge NSString *)kCGImagePropertyPixelWidth] unsignedIntegerValue]; //宽度，像素值\nNSUInteger height = [imageProperties[(__bridge NSString *)kCGImagePropertyPixelHeight] unsignedIntegerValue]; //高度，像素值\nBOOL hasAlpha = [imageProperties[(__bridge NSString *)kCGImagePropertyHasAlpha] boolValue]; //是否含有Alpha通道\nCGImagePropertyOrientation exifOrientation = [imageProperties[(__bridge NSString *)kCGImagePropertyOrientation] integerValue]; // 这里也能直接拿到EXIF方向信息，和前面的一样。如果是iOS 7，就用NSInteger取吧 :)\n```\n\n### 3. 解码得到CGImage\n通过Image/IO解码到CGImage确实非常简单，整个解码只需要一个方法`CGImageSourceCreateImageAtIndex`。对于静态图来说，index始终是0，调用之后会立即开始解码，直到解码完成。\n\n值得注意的是，Image/IO所有的方法都是线程安全的，而且基本上也都是同步的，因此确保大图像文件的解码最好不要放到主线程。\n\n示例代码：\n\n```objectivec\nCGImageRef imageRef = CGImageSourceCreateImageAtIndex(source, 0, NULL);\n```\n\n### 4. 生成上层的UIImage，清理\n解码得到CGImage后，就基本完成了，我们可以直接构造对应的UIImage用于UI组件渲染。其中UIImage的orientation，可以通过之前的EXIF元信息获得（注意，需要转换EXIF的方向，到UIImageOrientation的方向）。然后就完成了，比较简单。\n\n示例代码：\n\n```objectivec\n// UIImageOrientation和CGImagePropertyOrientation枚举定义顺序不同，封装一个方法搞一个switch case就行\nUIImageOrientation imageOrientation = [self imageOrientationFromExifOrientation:exifOrientation];\nUIImage *image = [[UIImage imageWithCGImage:imageRef scale:[UIScreen mainScreen].scale orientation:imageOrientation];\n\n// 清理，都是C指针，避免内存泄漏\nCGImageRelease(imageRef);\nCFRelease(source)\n```\n\n## 动态图\n前面的情况，主要介绍了是静态图（也就是说，取的index都是0的情况 ）。对于动态图来说，我们可以通过`CGImageSourceGetCount`来获取动图的帧数，之后就比较简单了，通过循环遍历每一帧，重复2-4步骤生成对应的UIImage，最后通过UIImage自带的`animatedImageWithImages:duration:`来生成一张动图即可。但是关于这里有坑，在下面说明。\n\n步骤：\n\n1. 静态图的步骤1\n2. 遍历所有图像帧，重复静态图的步骤2-4\n3. 生成动图UIImage\n\n### 1. 生成动图UIImage\n由于遍历很简单，就不重复了，这里我们以一个GIF为例，简单说明一下解码过程，直观易懂。\n\n示例代码：\n\n```objectivec\nNSUInteger frameCount = CGImageSourceGetCount(source); //帧数\nNSMutableArray <UIImage *> *images = [NSMutableArray array];\ndouble totalDuration = 0;\nfor (size_t i = 0; i < frameCount; i++) {\n    NSDictionary *frameProperties = (__bridge NSDictionary *) CGImageSourceCopyPropertiesAtIndex(source, i, NULL);\n    NSDictionary *gifProperties = frameProperties[(NSString *)kCGImagePropertyGIFDictionary]; // GIF属性字典\n    double duration = [gifProperties[(NSString *)kCGImagePropertyGIFUnclampedDelayTime] doubleValue]; // GIF原始的帧持续时长，秒数\n    CGImagePropertyOrientation exifOrientation = [frameProperties[(__bridge NSString *)kCGImagePropertyOrientation] integerValue]; // 方向\n    CGImageRef imageRef = CGImageSourceCreateImageAtIndex(source, i, NULL); // CGImage\n    UIImageOrientation imageOrientation = [self imageOrientationFromExifOrientation:exifOrientation];\n    UIImage *image = [[UIImage imageWithCGImage:imageRef scale:[UIScreen mainScreen].scale orientation:imageOrientation];\n    totalDuration += duration;\n    [images addObject:image];\n}\n\n// 最后生成动图\nUIImage *animatedImage = [UIImage animatedImageWithImages:images duration:totalDuration];\n```\n\n这样处理的话，大部分情况下基本是可以接受的。但是这里有一个坑：UIImage这个animatedImages的接口，只会根据你传入的images的数量，平均分配传入的totalDuration的展示时长。但是大部分动图格式（GIF，APNG，WebP等等），都是不同帧不同时长的，这就会导致最后看到的动图每帧时长乱掉。\n\n对于这个的解决方式也有。简单来说，就是通过对特定图像帧重复特定次数，以填充满整个应该播放的时长。其实实现也比较简单，我们可以对所有帧的时长，求一个最大公约数`gcd`，这样的话，只需要每帧重复播放`duration / gcd`次数，最终的总时长各帧`repeat * duraion`的和，就可以实现这个了，有兴趣可以看看我参与维护的[SDWebImage的代码](https://github.com/rs/SDWebImage/blob/4.1.2/SDWebImage/UIImage%2BWebP.m#L281=L294)。\n\n示例代码：\n\n```objectivec\nNSUInteger durations[frameCount];\nNSUInteger const gcd = gcdArray(frameCount, durations);\nfor (size_t i = 0; i < frameCount; i++) {\n    NSUInteger duration = durations[i];\n    NSUInteger repeatCount = duration / gcd;\n    for (size_t j = 0; j < repeatCount; j++) {\n        [animatedImages addObject:image];\n    }\n}\n```\n\n## 渐进式解码\n渐进式解码（Progressive Decoding），即不需要完整的图像流数据，允许解码部分帧（大部分情况下，会是图像的部分区域），对部分使用了渐进式编码的格式（参考：[渐进式编码](https://en.wikipedia.org/wiki/Interlacing_\\(bitmaps)），则更可以解码出相对模糊但完整的图像。\n\n比如说，JPEG支持三种方式的渐进式编码，包括Baseline，interlaced，以及progressive（参考：[iOS 处理图片的一些小 Tip](https://blog.ibireme.com/2015/11/02/ios_image_tips/))\n\nBaseline | Interlaced | Progressive\n:-: | :-: | :-:\n![](https://blog.ibireme.com/wp-content/uploads/2015/11/image_baseline.gif) | ![](https://blog.ibireme.com/wp-content/uploads/2015/11/image_interlaced.gif) | ![](https://blog.ibireme.com/wp-content/uploads/2015/11/image_progressive.gif)\n\n对于Image/IO的渐进式解码，其实和静态图解码的过程类似。但是第一步创建CGImageSource时，需要使用专门的`CGImageSourceCreateIncremental`方法，之后每次有新的数据（下载或者其他流输入）输入后，需要使用`CGImageSourceUpdateData`（或者`CGImageSourceUpdateDataProvider`）来更新数据。注意这个方法需要每次传入所有至今为止解码的数据，不仅仅是当前更新的数据。\n\n之后的过程，就和普通的解码一致，就不再说明了。\n\n示例代码：\n\n```objectivec\nNSData *data;\nbool finished = data.length == totalLength;\nCGImageSourceRef source;\n// 更新数据\nCGImageSourceUpdateData(source, (__bridge CFDataRef)data, finished);\n\n// 和普通解码过程一样\nCGImageRef imageRef = CGImageSourceCreateImageAtIndex(source, 0, NULL);\n```\n\n# 编码\n编码过程，这里指的就是将一个UIImage表示的图像，编码为对应图像格式的数据，输出一个NSData的过程。Image/IO提供的对应概念，叫做CGImageDestination，表示一个输出。之后的编码相关的操作，和这个Destination一一对应。\n\n## 静态图\n静态图的编码，基本可以分为以下步骤：\n\n1. 创建CGImageDestination\n2. 添加图像格式元数据（可选）和CGImage\n3. 编码得到NSData，清理\n\n### 1. 创建CGImageDestination\nCGImageDestination的创建也有三个接口，你需要提供一个输出的目标来输出解码后的数据。同时，由于编码需要提供文件格式，你需要指明对应编码的文件格式，用的是[UTI Type](https://developer.apple.com/library/content/documentation/FileManagement/Conceptual/understanding_utis/understand_utis_intro/understand_utis_intro.html#//apple_ref/doc/uid/TP40001319)。对于静态图来说，第三个参数的数量都写1即可。\n\n+ `CGImageDestinationCreateWithData`：指定一个可变二进制数据作为输出\n+ `CGImageDestinationCreateWithURL`：指定一个文件路径作为输出\n+ `CGImageDestinationCreateWithDataConsumer`：指定一个DataConsumer作为输出\n\n示例代码：\n\n```objectivec\nCFStringRef imageUTType; //目标格式，比如kUTTypeJPEG\n// 创建一个CGImageDestination\nCGImageDestinationRef destination = CGImageDestinationCreateWithData((__bridge CFMutableDataRef)imageData, imageUTType, 1, NULL);\nif (! destination) {\n    // 无法编码，基本上是因为目标格式不支持\n    return nil;\n}\n```\n\n### 2. 添加图像格式元数据（可选）和CGImage\n接下来就是添加图像了，由于CGImage只是包含基本的图像信息，很多\u0010额外信息比如说EXIF都已经丢失了，如果我们需要，可以添加对应的元信息。不像解码那样提供了两个API分别获取元信息和图像。使用的接口是`CGImageDestinationAddImage`。\n\n当然，如果有自定义的元信息，可以通过另外的`CGImageDestinationAddImageAndMetadata`来添加`CGImageMetadata`，这个上面解码也说到过，这里就不解释了。\n\n此外，还有一个ImageIO最强大的功能，叫做`CGImageDestinationAddImageFromSource `（这个东西可以媲美`vImageConvert_AnyToAny`，后续教程会谈到），这个能够从一个任意的CGImageSource，添加一个图像帧到任意一个CGImageDestination。这个一般的用途，就是专门给图像转换器用的，比如说从图像格式A，转换到图像格式B。我们不需要先解码到A的UIImage，再通过编码到B的NSData，直接在中间就进行了转换。能够极大地提升转换效率（Image/IO底层就是通过vImage，传的是Bitmap的引用，没有额外的消耗）。不过这篇教程侧重于Image/IO的编码和解码，转换可以自行参考处理，不再详细说明了。\n\n示例代码：\n\n```objectivec\nCGImageRef imageRef = image.CGImage; // 待编码的CGImage\n\n// 可选元信息，比如EXIF方向\nCGImagePropertyOrientation exifOrientation = kCGImagePropertyOrientationDown;\nNSMutableDictionary *frameProperties = [NSMutableDictionary dictionary];\nimageProperties[(__bridge_transfer NSString *) kCGImagePropertyExifDictionary] = @(exifOrientation);\n// 添加图像和元信息\nCGImageDestinationAddImage(destination, imageRef, (__bridge CFDictionaryRef)frameProperties);\n```\n\n### 3. 编码得到NSData，清理\n当添加完成所有需要编码的CGImage之后，最后一步，就是进行编码，得到图像格式的数据。这里直接用一个方法`CGImageDestinationFinalize`即可，编码得到的数据，会写入最早初始化时提供的Data或者DataConsumer。\n\n示例代码：\n\n```objectivec\nif (CGImageDestinationFinalize(destination) == NO) {\n    // 编码失败\n    imageData = nil;\n}\n// 编码成功，清理……\nCFRelease(destination);\n```\n\n## 动态图\n动态图的编码，其实不像解码那样困难。只需要准备好所有的动态图的帧，按照帧的顺序进行一一添加即可。基本步骤可以概括为：\n\n1. 静态图的步骤1，提供帧数\n2. 遍历所有图像帧，重复静态图的步骤2\n3. 静态图的步骤3\n\n\n### 1. 提供帧数，遍历图像帧\n在进行动态图编码时，创建CGImageDestination的时候需要提供动态图的张数。即在`CGImageDestinationCreateWithData`的参数中，将`count`设置为需要编码的总张数。\n\n另外，在遍历图像帧的过程，其实只需要不断地按顺序添加就行了，如果需要设置额外元信息，也需要按顺序设置到当前帧上。相对于解码来说简单多了。其他的没有什么大的区别。我们这里还是以GIF为例，简单说明一下。\n\n示例代码：\n\n```objectivec\nNSArray<UIImage *> *images;\nfloat durations[frameCount];\nfor (size_t i = 0; i < frameCount; i++) {\n    float frameDuration = durations[i];\n    CGImageRef frameImageRef = images[i].CGImage;\n    NSDictionary *frameProperties = @{(__bridge_transfer NSString *)kCGImagePropertyGIFDictionary : @{(__bridge_transfer NSString *)kCGImagePropertyGIFUnclampedDelayTime : @(frameDuration)}};\n    CGImageDestinationAddImage(imageDestination, frameImageRef, (__bridge CFDictionaryRef)frameProperties);\n}\n```\n\n# 总结\nImage/IO封装了非常简单直观的接口来处理图像编解码，对于任何开发者来说都能轻易上手。而且性能方面很多格式都有Apple自己的硬件解码器来做保证。另外，对于图像转换，Image/IO所提供的这种Source-Destination的操作能够非常方便地在不同格式之间转换，有兴趣的人务必可以试试。\n\n不过遗憾的是，Image/IO的接口设计并没有提供可以扩展或者插件化的地方，不支持的图像格式就比较无能为力了。关于这个问题，请期待系列教程第二篇——第三方编解码教程。\n","categories":["iOS"],"tags":["iOS","Image"]},{"title":"iOS平台图片编解码入门教程（vImage篇）","url":"/2017/11/12/iOS%E5%B9%B3%E5%8F%B0%E5%9B%BE%E7%89%87%E7%BC%96%E8%A7%A3%E7%A0%81%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%88vImage%E7%AF%87%EF%BC%89/","content":"> 这篇教程，是系列教程的第三篇，前篇名为iOS平台图片编解码入门教程（第三方编解码篇）。由于vImage已经属于较为底层框架，这一篇将不会特别着重图片封装格式的编解码，会介绍一些Bitmap级别的操作，包括了图像的色彩转换，Alpha合成、基本几何变换等实际用法。由于教程侧重是图像格式，所以不会介绍vImage强大的Convolution等知识，这方面涉及到数字图像处理的复杂知识，不是教程的目标\n\n# 基本介绍\n\n[vImage](https://developer.apple.com/library/content/documentation/Performance/Conceptual/vImage/Introduction/Introduction.html)是Apple的Accelerate库的一部分，侧重于高性能的图像Bitmap级别的处理。库本身全部是C的接口，而且不同于Core系列的（Core Graphics/Core Foundation）C接口，是比较贴近传统C语言的接口，不会有XXXRef这种贴心的定义，而且很多接口需要自己手动分配内存。\n\nvImage按照功能，可以分为Alpha Compositing（Alpha合成）、Geometry（几何变换）、Conversion（色彩转换）、Convolution（卷积，用于图像滤镜）Morphology（形态学处理）等。这里主要介绍的，就是色彩转换，Alpha合成，以及几何变换的内容。\n\n首先需要对vImage的基本接口有所了解，有这么几个概念：\n\n+ `vImage_Buffer`: 对应Bitmap的数据，只有最基本的width、height、rowBytes(stride)以及data\n+ `vImage_CGImageFormat`: 每个vImage的功能，会提供不同色彩格式的类似接口，比如会有ARGB8888，Planar8的同样功能。这里ARGB8888指的是ARGB排列，每通道占8个Bit，也就是一个Piexel占32Bit。而vImage还有一个常见的色彩格式Plane8，指的是只有一个通道（平面），按照顺序排列，比如`{R, R, R, R}`这样，更方便进行计算\n+ `vImage_Flags`: 每个vImage接口，都会有一个`flags `参数来控制一些选项，比如说可以自己定义内存分配，背景色填充策略，重采样策略等，默认的是`kvImageNoFlags`\n+ `vImage_Error`: 每个vImage的接口，都会返回这个result，来让用户确认是否成功，以及失败的原因，在Debug下比较有帮助\n\n为了统一期间，以下的内容，都是基于ARGB8888色彩格式的输入来说明的。其他的情况处理，参考同名接口的不同格式即可。\n\n# 色彩转换\n\n色彩转换指的是将图像的Bitmap格式，从一个色彩格式，比如ARGB8888，转换到另一个色彩格式，比如说RGB888的功能。对于RGB来说，一般来说就是通道的增加和减少。当然还有RGB转为Planar8的情况。\n\nvImage对这些色彩转换的功能，统一提供了方法`vImageConvert_AtoB`，比如ARGB8888转RGB888，就可以用下面的代码来处理。顺便通过这个代码，来简单了解vImage的API的基本用法。\n\n先来定义几个简单的结构体，方便后续使用：\n\n```objectivec\n// 为了方便，我们首先直接定义好ARGB8888的format结构体，后续需要多次使用\nstatic vImage_CGImageFormat vImageFormatARGB8888 = (vImage_CGImageFormat) {\n    .bitsPerComponent = 8, // 8位\n    .bitsPerPixel = 32, // ARGB4通道，4*8\n    .colorSpace = NULL, // 默认就是sRGB\n    .bitmapInfo = kCGImageAlphaFirst | kCGBitmapByteOrderDefault, // 表示ARGB\n    .version = 0, // 或许以后会有版本区分，现在都是0\n    .decode = NULL, // 和`CGImageCreate`的decode参数一样，可以用来做色彩范围映射的，NULL就是[0, 1.0]\n    .renderingIntent = kCGRenderingIntentDefault, // 和`CGImageCreate`的intent参数一样，当色彩空间超过后如何处理\n};\n// RGB888的format结构体\nstatic vImage_CGImageFormat vImageFormatRGB888 = (vImage_CGImageFormat) {\n    .bitsPerComponent = 8, // 8位\n    .bitsPerPixel = 24, // RGB3通道，3*8\n    .colorSpace = NULL,\n    .bitmapInfo = kCGImageAlphaNone | kCGBitmapByteOrderDefault, // 表示RGB\n    .version = 0,\n    .decode = NULL,\n    .renderingIntent = kCGRenderingIntentDefault,\n};\n// 字节对齐使用，vImage如果不是64字节对齐的，会有额外开销\nstatic inline size_t vImageByteAlign(size_t size, size_t alignment) {\n    return ((size + (alignment - 1)) / alignment) * alignment;\n}\n```\n\n接着，就是完整的转换代码：\n\n```objectivec\n+ (CGImageRef)nonAlphaImageWithImage:(CGImageRef)aImage\n{\n    // 首先，我们声明input和output的buffer\n    __block vImage_Buffer a_buffer = {}, output_buffer = {};\n    @onExit {\n        // 由于vImage的API需要手动管理内存，避免内存泄漏\n        // 为了方便错误处理清理内存，可以使用clang attibute的cleanup（这里是libextobjc的宏）\n        // 如果不这样，还有一种方式，就是使用goto，定义一个fail:的label，所有return NULL改成`goto fail`;\n        if (a_buffer.data) free(a_buffer.data);\n        if (output_buffer.data) free(output_buffer.data);\n    };\n    \n    // 首先，创建一个buffer，可以用vImage提供的CGImage的便携构造方法，里面需要传入原始数据所需要的format，这里就是ARGB8888\n    vImage_Error a_ret = vImageBuffer_InitWithCGImage(&a_buffer, &vImageFormatARGB8888, NULL, aImage, kvImageNoFlags);\n    // 所有vImage的方法一般都有一个result，判断是否成功\n    if (a_ret != kvImageNoError) return NULL;\n    // 接着，我们需要对output buffer开辟内存，这里由于是RGB888，对应的rowBytes是3 * width，注意还需要64字节对齐，否则vImage处理会有额外的开销。\n    output_buffer.width = a_buffer.width;\n    output_buffer.height = a_buffer.height;\n    output_buffer.rowBytes = vImageByteAlign(output_buffer.width * 3, 64);\n    output_buffer.data = malloc(output_buffer.rowBytes * output_buffer.height);\n    // 这里使用vImage的convert方法，转换色彩格式\n    vImage_Error ret = vImageConvert_ARGB8888toRGB888(&a_buffer, &output_buffer, kvImageNoFlags);\n    if (ret != kvImageNoError) return NULL;\n    // 此时已经output buffer已经转换完成，输出回CGImage\n    CGImageRef outputImage = vImageCreateCGImageFromBuffer(&output_buffer, &vImageFormatRGB888, NULL, NULL, kvImageNoFlags, &ret);\n    if (ret != kvImageNoError) return NULL;\n    \n    return outputImage;\n}\n```\n\n## 任意色彩格式转换\n\n除了一系列`vImageConvert_AtoB`的转换，vImage还提供了一个非常抽象的接口，叫做`vImageConvert_AnyToAny`，只需要你提供一个input format，一个output format，就可以直接转换。这个接口比较强大，不仅能够handler所有支持的色彩格式，而且还能支持`CVImageBuffer`（通过这个`vImageConverter`来构造）。所以一般如果做库封装，做一些色彩转换的case的时候，就可以试着用这个接口。\n\n因此，我们之前的ARGB8888ToRGB888的色彩转换，可以这样写，更为通用。示例代码：\n\n```objectivec\n    vImageConverterRef converter = vImageConverter_CreateWithCGImageFormat(&vImageFormatARGB8888, &vImageFormatRGB888, NULL, kvImageNoFlags, &ret);\n    if (ret != kvImageNoError) return NULL;\n    ret = vImageConvert_AnyToAny(converter, &a_buffer, &output_buffer, NULL, kvImageNoFlags);\n```\n\n\n# Alpha合成\n\n![Alpha合成](https://raw.githubusercontent.com/dreampiggy/vImageProcessor/master/Example/Screenshot/Screenshot1.png)\n\n\n[Alpha合成](https://en.wikipedia.org/wiki/Alpha_compositing)指的是将两张含有Alpha通道的图（被Blend的叫做bottom，Blend的叫做top），通过一定的公式合成成为\u0010一张新的含Alpha通道的图，一般来说用于给图像添加遮罩、覆盖等，常见的图像处理软件都有这个功能。其实本质上来说，Alpha合成，就是对图像的每一个像素值，进行这样一个计算：\n\n```c\nresultAlpha = (topAlpha * 255 + (255 - topAlpha)\n                 * bottomAlpha + 127) / 255\nresultColor = (topAlpha * topColor + (((255 - topAlpha)\n                 * bottomAlpha + 127) / 255) * bottomColor +  127)\n                    / resultAlpha\n```\n\n公式看起来比较复杂，因此这里顺便可以介绍一下关于[premultiplied-alpha](https://segmentfault.com/a/1190000002990030)的概念，直观地说，就是将`(r, g, b, a)`预先乘以了对应的alpha通道的值，成为`(r * a, g * a, b * a, a)`。这个带来的好处，就是Alpha合成的时候，可以少一次乘法，而且简化了计算，成为这样子：\n\n```c\nresultColor = (topColor + (((255 - topAlpha)\n                 * bottomAlpha + 127) / 255) * bottomColor +  127)\n```\n\n在vImage中，已经提供了一个接口来专门处理Alpha合成，针对nonpremultiplied的，是`vImageAlphaBlend_ARGB8888`，而针对premultiplied，是`vImagePremultipliedAlphaBlend_ARGB8888`。需要注意的是，这个接口要求的两个buffer，宽度和高度必须相等，因此，我们对于Color和Image的遮罩，需要进行处理，保证这两个buffer满足要求。\n\n## Alpha Blend Color\n\n这个用处，一般是用来做图像的遮罩的，可以对图像整体盖一层有透明度的颜色，比如说夜间模式，纯色滤镜等。根据上面说的，如果需要对一个Bitmap使用vImage进行Alpha Blend，我们需要保证两个buffer的宽度和高度相同，因此可以使用`vImageBufferFill_ARGB8888`填充整个Color来构造一个与输入图像Buffer相同宽高的新buffer，然后用它来进行Alpha Blend。\n\n代码示例：\n\n```objectivec\n    CGImageRef aImage; // 输入的bottom Image\n    CGColorRef color; // 输入的color\n    __block vImage_Buffer a_buffer = {}, b_buffer = {}, output_buffer = {}; // 分别是bottom buffer，top buffer和最后的output buffer\n    Pixel_8888 pixel_color = {0};\n    const double *components = CGColorGetComponents(color);\n    const size_t components_size = CGColorGetNumberOfComponents(color);\n    // 对CGColor进行转换到Pixel_8888\n    if (components_size == 2) {\n        // white, alpha\n        pixel_color[0] = components[1] * 255;\n    } else {\n        // red, green, blue, (alpha)\n        pixel_color[0] = components_size == 3 ? 255 : components[3] * 255;\n        pixel_color[1] = components[0] * 255;\n        pixel_color[2] = components[1] * 255;\n        pixel_color[3] = components[2] * 255;\n    }\n    // 填充color到top buffer\n    vImage_Error b_ret = vImageBufferFill_ARGB8888(&b_buffer, pixel_color , kvImageNoFlags);\n    if (b_ret != kvImageNoError) return NULL;\n    // Alpha Blend\n    vImage_Error ret = vImageAlphaBlend_ARGB8888(&b_buffer, &a_buffer, &output_buffer, kvImageNoFlags);\n```\n\n\n## Alpha Blend Image\n\n上面说到了关于Color的Alpha Blend，不同于Color这种需要填充全部宽度，如果对于一个Image需要进行Alpha Blend，我们大部分情况都是需要制定一个起始点的，因为不能保证所有输入的两个Image的宽高相同。因此设计的时候，可以给用户提供一个point参数，以这个坐标点开始来绘制Alpha Blend，类似于很多图像编辑软件提供的图层功能。\n\n由于vImage的Alpha Blend需要两个等宽高的Buffer，因此我们需要对用户提供的Top Image进行处理，通过平移变换移动到指定的Point以后，填充其余部分为Clear Color。最后进行Alpha Blend即可。\n\n```objectivec\n    CGImageRef aImage, bImage; // 输入的bottom Image和top Image\n    __block vImage_Buffer a_buffer = {}, b_buffer = {}, c_buffer = {}, output_buffer = {};\n    //c buffer指的是将top Image进行处理后的临时buffer，使得宽高同bottom image相同\n    // 这里我们使用到了线性变换的平移变换，以(0,0)放置top image，然后偏移point个像素点，其余部分填充clear color，即可得到这个处理后的c buffer\n    CGAffineTransform transform = CGAffineTransformMakeTranslation(point.x, point.y);\n    vImage_CGAffineTransform cg_transform = *((vImage_CGAffineTransform *)&transform);\n    Pixel_8888 clear_color = {0};\n    vImage_Error c_ret = vImageAffineWarpCG_ARGB8888(&b_buffer, &c_buffer, NULL, &cg_transform, clear_color, kvImageBackgroundColorFill);\n    if (c_ret != kvImageNoError) return NULL;\n    // 略过output buffer初始化\n    // 将bottom image和处理后的c buffer进行Alpha Blend\n    vImage_Error ret = vImageAlphaBlend_ARGB8888(&c_buffer, &a_buffer, &output_buffer, kvImageNoFlags);\n```\n\n# 几何变换\n\n几何变换，指的是将一个原始的Bitmap，通过线性方法进行处理，实现比如平移、缩放、旋转、错切等操作的图像处理技术。\n\n可能大部分人已经知道了（之前也说过），Core Graphics的坐标系统，和UIKit的坐标系统，在Y坐标上是相反的。UIKit的使用的是Y轴正向垂直向下的左手系，而Core Graphics和普通的右手系直角坐标系相同。vImage也遵守了右手系，因此之后介绍的变换都是按照右手系的，如果想处理UIKit的坐标系，自己转换一下即可（一般就是取`image.height - offsetY`即可）\n\n关于要介绍的的这些几何变换，虽然都最后可以统一到到线性变换上，只不过效率上可能相比单独的方法来说有所损耗，因此单独对每个功能所需要的vImage接口进行了介绍。关于线性变换不太理解的，可以参考一下之前的一篇教程：[Core Graphics仿射变换知识](http://dreampiggy.com/2016/09/27/core-graphicsfang-she-bian-huan/)\n\n## 缩放\n\n![缩放](https://raw.githubusercontent.com/dreampiggy/vImageProcessor/master/Example/Screenshot/Screenshot2.png)\n\n缩放是最简单的一个处理过程，但是由于缩放之后，之前的同一个像素点，现在可能会映射到4个或者更多像素点，或者是原本4个像素点，现在需要映射到1个像素点。这就会涉及到一个叫做[图像重采样](https://en.wikipedia.org/wiki/Image_scaling)的过程。具体来说，就是对每一个像素，所在的Bitmap的子矩阵（比如3x3），通过一定的算法计算，得到对应的缩放以后的中心像素的值。同时，这个像素值可能变成浮点数，还需要进行处理，最后填到采样后的Bitmap相应的位置上。常见的简单处理有最邻近算法、双线性算法、双立方算法等。\n\nvImage默认使用的是[Lanczos Algorithm](https://en.wikipedia.org/wiki/Lanczos_resampling)，具体的介绍可以参考Wikipedia和DSP相关的书籍。这里有一个直观的对比表现[网页](https://clouard.users.greyc.fr/Pantheon/experiments/rescaling/index-en.html)。如果想要更高画质的算法，可以提供`kvImageHighQualityResampling`参数，来使用`Lanczos5`算法。或者可以使用之后要谈的相对底层一点的错切API，来自定义你的重采样过程。\n\nvImage提供了自带的`vImageScale_ARGB8888`方法，这里就简单举个例子（之前重复代码的都略过）：\n\n```objectivec\n    CGSize size; // 目标大小\n    output_buffer.width = MAX(size.width, 0);\n    output_buffer.height = MAX(size.height, 0);\n    output_buffer.rowBytes = vImageByteAlign(output_buffer.width * 4, 64);\n    output_buffer.data = malloc(output_buffer.rowBytes * output_buffer.height);\n    if (!output_buffer.data) return NULL;\n    // 进行缩放，输出到output buffer中\n    vImage_Error ret = vImageScale_ARGB8888(&a_buffer, &output_buffer, NULL, kvImageHighQualityResampling);\n```\n\n## 裁剪\n\n裁剪是指的将原始Bitmap，只裁出来指定矩形大小的部分，其余部分直接丢弃的过程。虽然vImage没有提供直接的API来处理这个流程（当然你是可以用vecLib的方法，直接对Bitmap进行矩阵操作，但是有点过于小题大做了）。但是实际上，这就是一个平移变换能够搞定的事情。我们只需要对输入目标的坐标的`CGRect`进行转换，将原始图像平移之后，再限制输出的Bitmap的大小，这样平移超出部分就会自动被裁掉。不需额外的处理，示例代码如下：\n\n```objectivec\n    CGRect rect; // 输入的目标rect\n    output_buffer.width = MAX(CGRectGetWidth(rect), 0); // 输出宽度\n    output_buffer.height = MAX(CGRectGetHeight(rect), 0); // 输出高度\n    output_buffer.rowBytes = vImageByteAlign(output_buffer.width * 4, 64);\n    output_buffer.data = malloc(output_buffer.rowBytes * output_buffer.height);\n    if (!output_buffer.data) return NULL;\n    \n    // 使用平移来处理，X轴Y轴分别平移负向的minX，minY即可\n    CGFloat tx = CGRectGetMinX(rect);\n    CGFloat ty = CGRectGetMinY(rect);\n    CGAffineTransform transform = CGAffineTransformMakeTranslation(-tx, -ty);\n    vImage_CGAffineTransform cg_transform = *((vImage_CGAffineTransform *)&transform);\n    Pixel_8888 clear_color = {0};\n    vImage_Error ret = vImageAffineWarpCG_ARGB8888(&a_buffer, &output_buffer, NULL, &cg_transform, clear_color, kvImageBackgroundColorFill);\n```\n\n## 镜像\n\n镜像顾名思义，就是将图像沿着某个轴进行翻转，比如沿X轴就是水平镜像，同一个像素点，对应的X坐标不变，Y坐标变为高度减去本身的Y坐标即可。\n\nvImage对应的API，是`vImageVerticalReflect_ARGB8888`和`vImageHorizontalReflect_ARGB8888`，使用起来也比较简单。直接上一个简单的示例：\n\n\n```objectivec\n    BOOL horizontal;\n    __block vImage_Buffer a_buffer = {}, output_buffer = {};\n    // 省略\n    vImage_Error ret;\n    if (horizontal) {\n        // 水平镜像\n        ret = vImageHorizontalReflect_ARGB8888(&a_buffer, &output_buffer, kvImageHighQualityResampling);\n    } else {\n        // 垂直镜像\n        ret = vImageVerticalReflect_ARGB8888(&a_buffer, &output_buffer, kvImageHighQualityResampling);\n    }\n```\n\n\n\n## 旋转\n\n旋转也是非常常见一个图像几何几何变化。具体坐标的变化就是对旋转的角度，求对应三角函数到X轴和Y轴的投影结果，比较直观。\n\nvImage对旋转也提供了一个非常方便的API，角度是弧度值，按照顺时针方向进行。另外，由于输出的Buffer的大小会限制图像大小，而旋转后可能超出原图大小，我们需要对输出的大小也计算出对应的新的大小。示例代码：\n\n```objectivec\n    CGFloat radians; //旋转的弧度\n    CGSize size = CGSizeMake(a_buffer.width, a_buffer.height);\n    // 这里直接借用CG的方法来计算旋转后的大小，方便\n    CGAffineTransform transform = CGAffineTransformMakeRotation(radians);\n    size = CGSizeApplyAffineTransform(size, transform);    output_buffer.width = ABS(size.width);\n    output_buffer.height = ABS(size.height);\n    output_buffer.rowBytes = vImageByteAlign(output_buffer.width * 4, 64);\n    output_buffer.data = malloc(output_buffer.rowBytes * output_buffer.height);\n    if (!output_buffer.data) return NULL;\n    Pixel_8888 clear_color = {0};\n    // 旋转操作，多余部分填充Clear Color\n    vImage_Error ret = vImageRotate_ARGB8888(&a_buffer, &output_buffer, NULL, radians, clear_color, kvImageBackgroundColorFill | kvImageHighQualityResampling);\n```\n\n## 错切\n\n![错切](https://raw.githubusercontent.com/dreampiggy/vImageProcessor/master/Example/Screenshot/Screenshot3.png)\n\n[错切](https://en.wikipedia.org/wiki/Shear_mapping)是一种特殊的线性变换，直观的介绍可以从Wikipedia上看，也可以参考之前的另一篇教程。主要的参数有一个m值，表示对应参考坐标的缩放倍数。\n\n在vImage中，错切变换是相对底层的接口，实际上，线性变换是通过这三个接口（错切、旋转、镜像）来实现的。错切的接口，比如水平错切对应的是`vImageHorizontalShear_ARGB8888`，参数算是最多的一个，稍微详细介绍一下：\n\n+ `srcOffsetToROI_X`: 错切定位点水平偏移量，具体指的就是左上角那个像素点，在经过旋转的映射后，水平偏移的距离，会影响最后图像（除去Buffer的宽度限制）的整体宽度\n+ `srcOffsetToROI_Y`: 错切定位点的垂直偏移量，类似水平值\n+ `xTranslate`: 错切完成后的水平平移距离\n+ `shearSlope`: 错切的弧度值，顺时针\n+ `filter`: 用来自定义重采样的方法，一般用自带的`vImageNewResamplingFilter`，或者也可以提供一个函数指针构造对应的重采样过程。会用到一个scale参数，表示这个重采样对应的缩放倍数，也就是错切的m值\n+ `backgroundColor`: 背景填充色\n\n对应的示例代码：\n\n\n```objectivec\n    CGVector offset; // 定位点偏移量\n    CGFloat translation; // 水平平移量\n    CGFloat slope; // 旋转弧度\n    CGFloat scale; // 对应错切的m值\n    output_buffer.width = MAX(a_buffer.width - offset.dx, 0); //这里需要同时减去水平定位点的偏移\n    output_buffer.height = MAX(a_buffer.height - offset.dy, 0); // 同理\n    output_buffer.rowBytes = vImageByteAlign(output_buffer.width * 4, 64);\n    output_buffer.data = malloc(output_buffer.rowBytes * output_buffer.height);\n    if (!output_buffer.data) return NULL;\n    \n    Pixel_8888 clear_color = {0};\n    // 这里示例就用默认的重采样方法\n    ResamplingFilter resampling_filter = vImageNewResamplingFilter(scale, kvImageHighQualityResampling);\n    vImage_Error ret;\n    if (horizontal) {\n        // 水平错切\n        ret = vImageHorizontalShear_ARGB8888(&a_buffer, &output_buffer, offset.dx, offset.dy, translation, slope, resampling_filter, clear_color, kvImageBackgroundColorFill);\n    } else {\n        // 垂直错切\n        ret = vImageVerticalShear_ARGB8888(&a_buffer, &output_buffer, offset.dx, offset.dy, translation, slope, resampling_filter, clear_color, kvImageBackgroundColorFill);\n    }\n    vImageDestroyResamplingFilter(resampling_filter);\n```\n\n## 线性变换\n\n最后再来说通用的线性变换吧，这个其实在之前的功能中已经用到过了，vImage有兼容Core Graphics的`CGAffineTransform`的结构体`vImage_CGAffineTransform`，两个结构体对应的内存布局是一样的，直接强制转换过去就可以了，不需要单独赋一遍。关于通用线性变换的内容就不再赘述了，有兴趣可以查看相关资料，或者之前的教程：[Core Graphics仿射变换知识](http://dreampiggy.com/2016/09/27/core-graphicsfang-she-bian-huan/)\n\n示例代码：\n\n```objectivec\n    CGAffineTransform transform; // 输入的CG变换矩阵\n    vImage_CGAffineTransform cg_transform = *((vImage_CGAffineTransform *)&transform); // 结构一样，直接强转\n    Pixel_8888 clear_color = {0};\n    // 线性变换\n    vImage_Error ret = vImageAffineWarpCG_ARGB8888(&a_buffer, &output_buffer, NULL, &cg_transform, clear_color, kvImageBackgroundColorFill | kvImageHighQualityResampling);\n```\n\n\n# 总结\n\nvImage是一个比较底层的图像Bitmap处理的库，在这里介绍了关于色彩转换、Alpha合成、几何变换等基本知识。相比于简单的Core Graphics的处理，能够提供更为复杂的参数控制，并且带来较高的性能。对于很多图像密集处理软件处理来说，用Core Graphics显的比较低效，因此可以考虑vImage。\n\n但是vImage强大之处远不在这里，里面还包含了类似图像卷积，形态处理等，可以对复杂滤镜进行支持，类似于[GPUImage](https://github.com/BradLarson/GPUImage)。这些功能都需要数字图像处理相关知识，在这种教程系列就不会介绍了。\n\n对于这篇教程的示例代码，其实我写了个非常简单的库，放到GitHub上了：[vImageProcessor](https://github.com/dreampiggy/vImageProcessor)，有兴趣的可以去参考一下，希望能够用于自己的图片处理相关框架中。\n\n由于自己完全是业余兴趣，工作和图像处理基本不相关，并不打算深入学习数字图像处理的知识，因此这个教程可能就会暂时告一段落了。最后，之所以写这篇教程，是因为自己想要参考一下vImage的教程，却发现只会搜出来一堆互相抄袭的内容，而且大部分都是关于图像滤镜的，对于图像处理本身不会太多介绍。我希望这系列教程，能给同样对图像编解码、图像处理有一点兴趣的人，提供一个相对简单且清晰的入门概览吧。","categories":["iOS"],"tags":["iOS","Image"]},{"title":"iOS平台图片编解码入门教程（第三方编解码篇）","url":"/2017/10/30/iOS%E5%B9%B3%E5%8F%B0%E5%9B%BE%E7%89%87%E7%BC%96%E8%A7%A3%E7%A0%81%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%88%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BC%96%E8%A7%A3%E7%A0%81%E7%AF%87%EF%BC%89/","content":"> 这篇教程，是系列教程的第二篇，前篇名为《iOS平台图片编解码入门教程（Image/IO篇）》。这篇主要讲第三方解码器如何在iOS平台上处理（和Image/IO的几大要点一一对应），更会介绍一些基本的Bitmap概念，总结通用的处理方法，毕竟授人以鱼不如授人以渔\n\n# 第三方编解码\n对于图片编解码来说，Apple自带的Image/IO确实非常的易用，但是对于Image/IO不支持的图像格式就能无能为力了。截止到iOS 11，Image/IO不支持WebP，BPG，对于一些需要依赖WebP的业务就比较麻烦了（WebP的优点就不再介绍了）。不过我们可以自己集成第三方的图片解码器，去支持这些需要的的格式。\n\n一般来说，我们需要根据自己想要支持的图像格式，选择相对应的编解码器，进行编解码。这里我们以WebP的解码库[libwebp](https://developers.google.com/speed/webp/docs/api)为例子，其他解码器需要根据对应解码器的API处理，基本概念类似。\n\n# 解码\n不像Image/IO那样封装了整套流程，第三方解码的关键之处，就是在于获取到图像的[Bitmap](https://en.wikipedia.org/wiki/Raster_graphics)数据，通常情况就是[RGBA](https://en.wikipedia.org/wiki/RGBA_color_space)的矢量表示。\n\n简单解释一下，Bitmap可以理解为连续排列像素（Pixel）的二维数组，一个像素包括4个通道(Components)的点，每个点的位数叫做色深（常见的32位色，指的就是1个像素有4通道，每个通道8位），而像素的通道排列顺序按照对应的RGBA Mode顺序排列，比如说RGBA8888（大端序），就是这样一串连续的值：\n\n```text\n{uint8_t red, uint8_t green, uint8_t blue, uint8_t alpha, uint8_t red, uint8_t green, uint8_t blue, uint8_t alpha...}\n```\n\n这样的话，在内存中，一般就可以用`uint8_t bitmap[width * components * 8][height]`来表示。\n\n有了这样的知识，对照着就能看懂CGImage的BitmapInfo所表示的信息了。\n\n![Bitmap的表示](https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/colorformatrgba32.gif)\n\n## 静态图\n只要Bitmap数据到手，后面的过程其实都大同小异。第三方解码器主要处理图像编码数据到原始Bitmap的解码过程，后续就可以通过固定的方式来得到CGImage或者UIImage，用于上层UI组件的渲染。\n\n1. 第三方解码器获取图像Bitmap\n2. 通过Bitmap创建CGImage\n3. CGImage重绘（可选）\n4. 生成上层的UIImage，清理\n\n### 1. 第三方解码器获取图像Bitmap\n根据自己的需要，可以选择对应的编码器，来获取图像Bitmap。这里我们以WebP的解码库[libwebp](https://developers.google.com/speed/webp/docs/api)为例子，其他解码器需要根据对应解码器的API处理，基本概念类似。\n\n示例代码：\n\n```objectivec\nNSData *data; // 待解码的图像二进制数据\n\nWebPData webpData;\nWebPDataInit(&webpData);\nwebpData.bytes = data.bytes;\nwebpData.size = data.length;\n\n// 初始化Config，用于存储图像的Bitmap，大小等信息\nWebPDecoderConfig config;\nif (!WebPInitDecoderConfig(&config)) {\n    return nil;\n}\n\n// 判断是否能够解码\nif (WebPGetFeatures(webpData.bytes, webpData.size, &config.input) != VP8_STATUS_OK) {\n    return nil;\n}\n\n// 设定输出的Bitmap色彩空间，有Alpha通道选择RGBA，没有选择RGB \nbool has_alpha = config.input.has_alpha;\nconfig.output.colorspace = has_alpha ? MODE_rgbA : MODE_RGB;\nconfig.options.use_threads = 1;\n\n// 真正开始解码，输出RGBA数据到Config的output中\nif (WebPDecode(webpData.bytes, webpData.size, &config) != VP8_STATUS_OK) {\n    return nil;\n}\n\n// 获取图像的大小\nint width = config.input.width;\nint height = config.input.height;\nif (config.options.use_scaling) {\n    width = config.options.scaled_width;\n    height = config.options.scaled_height;\n}\n\n//RGBA矢量和对应的大小\nuint8_t *rgba = config.output.u.RGBA.rgb;\nsize_t rgbaSize = config.output.u.RGBA.size;\n```\n\n截止到这里，我们基本上调用通过第三方解码库的接口，就完成了获取Bitmap的工作。一般来说，以RGBA来说，最少需要知道以下信息：图像RGBA数组，数组大小，图像宽度、高度、是否含有Alpha通道这几个，以便开始下一步的创建CGImage的过程\n\n### 2. 通过Bitmap创建CGImage\n有了图像的Bitmap数据之后，可以通过`CGImageCreate`来生成CGImage。对于RGBA的输入，需要的参数基本比较固定，以下代码基本上可以参考来复用。（需要注意，iOS上只支持[premultiplied-alpha](https://segmentfault.com/a/1190000002990030)，macOS可以支持非premultiplied-alpha）\n\n示例代码：\n\n```objectivec\n// 通过RGBA数组，创建一个DataProvider。最后一个参数是一个函数指针，用来在创建完成后清理内存用的\nCGDataProviderRef provider = CGDataProviderCreateWithData(NULL, rgba, rgbaSize, FreeImageData);\n// 目标色彩空间，我们这里用的就是RGBA\nCGColorSpaceRef colorSpaceRef = CGColorSpaceCreateDeviceRGB();\n// Bitmap数据，如果含有Alpha通道，设置Premultiplied Alpha。没有就忽略Alpha通道\nCGBitmapInfo bitmapInfo = has_alpha ? kCGBitmapByteOrder32Big | kCGImageAlphaPremultipliedLast : kCGBitmapByteOrder32Big | kCGImageAlphaNoneSkipLast;\n// 通道数，有alpha就是4，没有就是3\nsize_t components = has_alpha ? 4 : 3;\n// 这个是用来做色彩空间变换的指示，如果超出色彩空间，比如P3转RGBA，默认会进行兼容转换\nCGColorRenderingIntent renderingIntent = kCGRenderingIntentDefault;\n// 每行字节数（RGBA数组就是连续排列的多维数组，一行就是宽度*通道数），又叫做stride，因为Bitmap本质就是Pixel(uint_8)的二维数组，需要知道何时分行\nsize_t bytesPerRow = components * width;\n// 创建CGImage，参数分别意义为：宽度，高度，每通道的Bit数（RGBA自然是256，对应8Bit），每行字节数，色彩空间，Bitmap信息，数据Provider，解码数组（这个传NULL即可，其他值的话，会将经过变换比如premultiplied-alpha之后的Bitmap写回这个数组），是否过滤插值（这个一般不用开，可以在专门的图像锐化里面搞），色彩空间变换指示\nCGImageRef imageRef = CGImageCreate(width, height, 8, components * 8, bytesPerRow, colorSpaceRef, bitmapInfo, provider, NULL, NO, renderingIntent);\n// 别忘了清理DataProvider，此时会调用之前传入的清理函数\nCGDataProviderRelease(provider);\n\nstatic void FreeImageData(void *info, const void *data, size_t size) {\n    free((void *)data);\n}\n```\n\n### 3. CGImage重绘\n这一步其实是可选的，但是建议都加上这一步骤。虽然我们之前通过RGBA创建了CGImage，但是实际上，CALayer和上层的UIImageView这些渲染的时候，要求的色彩是限定的，不然会有额外的内存和渲染消耗，我们解码出来的rgba的格式可能并不是按照这样的色彩空间排列，因此建议进行一次重绘，即将CGImage重绘到一个CGBitmapContext之上。这个代码比较简单。\n\n示例代码：\n\n```objectivec\nCGImageRef imageRef;\nsize_t canvasWidth = CGImageGetWidth(imageRef)\nsize_t canvasHeight = CGImageGetHeight(imageRef)\nCGBitmapInfo bitmapInfo;\nif (! has_alpha) {\n    bitmapInfo = kCGBitmapByteOrder32Big | kCGImageAlphaNoneSkipLast;\n} else {\n    bitmapInfo = kCGBitmapByteOrder32Big | kCGImageAlphaPremultipliedLast;\n}\n\n// 参数意思很简单，由于没有数据，对于RGBA可以自动计算bytesPerRow\nCGContextRef canvas = CGBitmapContextCreate(NULL, canvasWidth, canvasHeight, 8, 0, CGColorSpaceCreateDeviceRGB(), bitmapInfo);\nif (!canvas) {\n    return nil;\n}\n    \nCGImageRef imageRef = image.CGImage;\nsize_t width = CGImageGetWidth(imageRef);\nsize_t height = CGImageGetHeight(imageRef);\n// 画CGImage上去\nCGContextDrawImage(canvas, CGRectMake(0, 0, width, height), imageRef);\nCGImageRef newImageRef = CGBitmapContextCreateImage(canvas);\n```\n\n### 4. 生成上层的UIImage，清理\n有了最终的用于显示CGImage，那么我们就可以生成一个UIImage来给UI组件显示了。注意如果需要有特殊的scale，orientation处理（比如说图像可能有额外的EXIF Orientation信息），需要在这一步加上。\n由于是C接口，需要手动清理内存，除了CGImage相关的，也需要清理第三方库自己的内存分配。对于错误提前返回的清理内存，灵活运用`__attribute__((cleanup))`，设置一个返回函数前清理的Block，可以减少犯错的可能性\n\n示例代码：\n\n```objectivec\nUIImage *image = [UIImage imageWithCGImage:imageRef scale:1 orientation:UIImageOrientationUp];\n\n// 各种清理，省略\nCGImageRelease(newImageRef);\nCGContextRelease(canvas);\n```\n\n## 动态图\n动态图的解码过程，其实很直观的想，我们目标就是需要对所有动图帧，都拿到Bitmap，解码到CGImage和UIImage就行了。这样想的话，其实步骤就比较明确了。\n\n步骤：\n\n1. 第三方解码器生成每帧的Bitmap\n2. 重复静态图的2-3\n3. 生成动图UIImage（参考Image/IO）\n\n### 1. 第三方解码器生成每帧的Bitmap\n不同解码器可能对于动图有特殊的解码过程，拿libwebp举例来说，libwebp的动图，需要用到它的demux模块，其他解码器自行参考对应的API。\n\n同时，这里需要额外介绍一些概念。一般来说，动图格式的话不会直接将每帧原始的Bitmap都编码到文件中，这样得到的文件过于庞大（帧数 * 每帧Bitmap）。因此，会有Dispose Method的方式（可以参考WebP规范[Disposal method (D): 1 bit](https://developers.google.com/speed/webp/docs/riff_container)，[移动端图片格式调研](https://blog.ibireme.com/2015/11/02/mobile_image_benchmark/)）。简单点来说，对于动图来说，每一帧有一个参考画布，在前一帧画完以后，后一帧可以利用前一帧已画好的图像，仅仅改变前后变化的部分，从而减小整体大小。因此我们创建动图时，需要准备好一个CGBitmapContext当作画布，根据Disposal Method（如果为None，不清空canvas；如果为Background，清空为Background Color，一般就是直接清空成透明）\n\n有了所有帧的Bitmap后，转成CGImage，UIImage，最后生成动图UIImage，这个在系列前篇已经介绍过了，不再赘述\n\n示例代码：\n\n```objectivec\n- (void)decodeWebP {\n\t// 前期准备代码，直接略过，假设已经创建好canvas\n\tWebPDemuxer *demuxer;\n\tWebPIterator iter;\n\tif (!WebPDemuxGetFrame(demuxer, 1, &iter)) {\n\t    return nil;\n\t}\n\t    \n\tNSMutableArray<UIImage *> *images = [NSMutableArray array];\n\tdouble durations[frameCount];\n\t    \n\tdo {\n\t    @autoreleasepool {\n\t        UIImage *image = [self drawnWebpImageWithCanvas:canvas iterator:iter];\n\t        int duration = iter.duration;\n\t        [images addObject:image];\n\t        durations[frame_num] = duration;\n\t    }\n\t    \n\t} while (WebPDemuxNextFrame(&iter));\n\t\n\t// 创建UIImage动图，和Image/IO的相同，这里就直接封装成方法，略过\n\tUIImage *animatedImage = [self animatedImageWithImages:images durations:durations];\n\t    \n\t// 清理……略\n\tWebPDemuxReleaseIterator(&iter);\n}\n\n- (nullable UIImage *)drawnWebpImageWithCanvas:(CGContextRef)canvas iterator:(WebPIterator)iter {\n    // 这里是调用的前面静态图绘制的方法\n    UIImage *image = [self rawWebpImageWithData:iter.fragment];\n    if (!image) {\n        return nil;\n    }\n    \n    size_t canvasWidth = CGBitmapContextGetWidth(canvas);\n    size_t canvasHeight = CGBitmapContextGetHeight(canvas);\n    CGSize size = CGSizeMake(canvasWidth, canvasHeight);\n    CGFloat tmpX = iter.x_offset;\n    CGFloat tmpY = size.height - iter.height - iter.y_offset;\n    CGRect imageRect = CGRectMake(tmpX, tmpY, iter.width, iter.height);\n    // Blend\n    BOOL shouldBlend = iter.blend_method == WEBP_MUX_BLEND;\n    \n    // 如果BlendMode开启，该帧应当混合画画布上，否则，应该覆盖，也就是清空指定范围后再重画\n    if (!shouldBlend) {\n        CGContextClearRect(canvas, imageRect);\n    }\n    CGContextDrawImage(canvas, imageRect, image.CGImage);\n    CGImageRef newImageRef = CGBitmapContextCreateImage(canvas);\n    \n    image = [UIImage imageWithCGImage:newImageRef];\n    CGImageRelease(newImageRef);\n    \n    // Dispose如果是Background，表示解码下一帧需要清空画布\n    if (iter.dispose_method == WEBP_MUX_DISPOSE_BACKGROUND) {\n        CGContextClearRect(canvas, imageRect);\n    }\n    \n    return image;\n}\n```\n\n\n## 渐进式解码\n渐进式解码的概念，在系列前篇中已经介绍过了，一般来说，第三方解码器支持渐进式解码的接口都比较类似，通过提供二进制流不断进行Update，每次能够得到当前解码的部分的Bitmap，最后可以拿到完整的Bitmap。之后只需要参考静态图对应步骤即可。\n\n这里还是以libwebp的接口为例，libwebp需要使用它的WebPIDecoder接口，来专门进行渐进式解码。注意，libwebp渐进式解码出来的Bitmap不会将未解码的部分自动填空，会保留随机的内存地址置，要么手动清空，要么画的时候仅仅画解码出来的高度部分。\n\n示例代码：\n\n```objectivec\nNSData *data; // 输入的原始图像格式的二进制数据\nUIImage *image;\nWebPIDecoder *idec = WebPINewRGB(MODE_rgbA, NULL, 0, 0);\nif (!idec) {\n    return nil;\n}\n\n// 这里需要更新全部的数据，当然libwebp也有仅仅更新新增数据（非全部）的接口\nVP8StatusCode status = WebPIUpdate(idec, data.bytes, data.length);\nif (status != VP8_STATUS_OK && status != VP8_STATUS_SUSPENDED) {\n    return nil;\n}\n    \nint width = 0;\nint height = 0;\nint last_y = 0; // 已经解码出来的Bitmap数据的高度，即对应有效Bitmap的行数\nint stride = 0;\n// 然后可以拿到Bitmap数据和相应的图像信息了\nuint8_t *rgba = WebPIDecGetRGB(_idec, &last_y, &width, &height, &stride);\n\n// 和静图解码的过程类似，构造一个DataProvider，略过\nCGDataProviderRef provider;\nCGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Big | kCGImageAlphaPremultipliedLast;\nsize_t components = 4;\n\n//这里说一个坑，libwebp不能保证last_y以下的数据是全空的，所以一定注意，仅仅解码last_y范围内的Bitmap\nCGImageRef imageRef = CGImageCreate(width, last_y, 8, components * 8, components * width, CGColorSpaceCreateDeviceRGB(), bitmapInfo, provider, NULL, NO, kCGRenderingIntentDefault);\n\n// 为了能得到完整的图片高度，创建一个canvas来画图，不画的部分保持透明状态即可\nCGContextRef canvas = CGBitmapContextCreate(NULL, width, height, 8, 0, CGColorSpaceCreateDeviceRGB(), bitmapInfo);\n\n// 仅仅画last_y高度的图像（不是全部），注意CoreGraphics的坐标系统是右手系的，与UIKit的坐标相反\nCGContextDrawImage(canvas, CGRectMake(0, height - last_y, width, last_y), imageRef);\n\n// 拿到CGImage\nCGImageRef newImageRef = CGBitmapContextCreateImage(canvas);\n// 创建UIImage\nimage = [[UIImage alloc] initWithCGImage:newImageRef];\n// 各种清理，省略\n```\n\n# 编码\n\n编码过程其实比解码过程要简单得多，因为实际上，我们可以通过自带的接口，直接拿到当前UIImage的Bitmap数据，因此只要将Bitmap交给第三方编码库来进行编码，最后输出数据即可。\n\n## 静态图\n静态图的过程其实就可以直接分为两步：\n\n1. UIImage获取Bitmap\n2. 调用编码器进行编码\n\n### 1. UIImage获取Bitmap\nUIImage本身能够直接通过方法拿到对应的CGImage，这样只需要调用`CGImageGetDataProvider`就可以拿到对应的Bitmap数据的DataProvider了，直接上代码吧。\n\n示例代码：\n\n```objectivec\nUIImage *image;\nNSData *webpData; // Bitmap数据的容器\nCGImageRef imageRef = image.CGImage;\n    \nsize_t width = CGImageGetWidth(imageRef);\nsize_t height = CGImageGetHeight(imageRef);    \nsize_t bytesPerRow = CGImageGetBytesPerRow(imageRef); // 大部分编码器需要知道bytesPerRow，或者叫做stride\nCGDataProviderRef dataProvider = CGImageGetDataProvider(imageRef);\nCFDataRef dataRef = CGDataProviderCopyData(dataProvider);\nuint8_t *rgba = (uint8_t *)CFDataGetBytePtr(dataRef);\n```\n\n### 2. 调用编码器进行编码\n我们还是以libwebp来对WebP进行编码，libwebp对于静态图片的编码非常简单（动态图片需要调用另一套mux的API，在动图章节讲）\n\n示例代码：\n\n```objectivec\nuint8_t *data = NULL; //编码输出的二进制数据\nfloat quality = 100.0; // libwebp可以选择编码质量，影响输出文件大小和编码速度\nsize_t size = WebPEncodeRGBA(rgba, (int)width, (int)height, (int)bytesPerRow, quality, &data);\nCFRelease(dataRef); // 编码后清理Bitmap数据\nrgba = NULL;\n    \nif (size) {\n    // success\n    webpData = [NSData dataWithBytes:data length:size];\n}\nif (data) {\n    WebPFree(data);\n}\n```\n\n## 动态图\n\n对于动态图来说，也就是将多帧的Bitmap输入到编码器即可。对于libwebp的动态图编码，需要利用到它的mux模块，它能够将多个编码成WebP的二进制流，最后mux合并一次，最终得到了动态WebP。因此我们需要利用之前的静态图编码的步骤，只需要依次遍历取图并编码，最后使用mux处理即可。\n\n步骤：\n\n1. 遍历每帧Bitmap，编码\n\n### 1. 遍历每帧Bitmap，编码\n\n示例代码：\n\n```objectivec\nNSData *data;\nNSArray<UIImgae *> *images;\ndouble durations[frameCount];\nint loopCount;\n// 创建mux\nWebPMux *mux = WebPMuxNew();\nif (!mux) {\n    return nil;\n}\n// 遍历带编码的每帧\nfor (size_t i = 0; i < framesCount; i++) {\n    NSData *webpData = [self encodedWebpDataWithImage:images[i]]; // 单帧编码后数据\n    int duration = (int)durations[i] * 1000; // 单帧持续时长\n    // 设置WebP每帧属性，包括Data，Blend，Disposal等\n    WebPMuxFrameInfo frame = {.bitstream.bytes = webpData.bytes //省略}\n    if (WebPMuxPushFrame(mux, &frame, 0) != WEBP_MUX_OK) {\n        WebPMuxDelete(mux);\n        return nil;\n    }\n}\n\n// 设置动图本身的属性\nWebPMuxAnimParams params;\nparams.bgcolor = 0, params.loop_count = loopCount;\nWebPMuxSetAnimationParams(mux, &params);\n\nWebPData outputData;\n// 最后进行编码，拿到输出的二进制\nWebPMuxError error = WebPMuxAssemble(mux, &outputData);\nWebPMuxDelete(mux);\nif (error != WEBP_MUX_OK) {\n    return nil;\n}\ndata = [NSData dataWithBytes:outputData.bytes length:outputData.size];\nWebPDataClear(&outputData);\n```\n\n# 总结\n第三方编解码其实相对于Image/IO来说，主要难度其实在于需要获取的Bitmap。开发者需要一点基本的图像知识，再者就是要能会用第三方编解码器的接口（一般来说第三方编解码器就是C或者C++写的，与OC和Swift交互也非常方便，至少不用像Java JNI那样调用）。之后只要按照通用的步骤，去编码和解码即可。\n\n到这里的话，一般的大部分格式的编解码就基本没有问题了。当然，关于进阶的方面，比如图像的编解码性能优化，进阶的图像处理（Bitmap的几何变化，Alpha合成，位数转换等等）这就需要用到更低层的库vImage了，会在之后的系列教程中进行介绍。","categories":["iOS"],"tags":["iOS","Image"]},{"title":"iOS开发中使用Swift来完成异步事件","url":"/2016/03/30/iOS%E5%BC%80%E5%8F%91%E4%B8%AD%E4%BD%BF%E7%94%A8Swift%E6%9D%A5%E5%AE%8C%E6%88%90%E5%BC%82%E6%AD%A5%E4%BA%8B%E4%BB%B6/","content":"\n异步事件编程，其实并不是什么新东西了，基本所有涉及到GUI的，网络请求的，数据库读写的，都会有它的身影。\n\n异步事件，就是说这一个代码或者代码块，并不会阻塞程序的运行，程序会立即执行下一条语句，而这条语句，会在相应的方法调用结束之后，执行它自身的回调函数发送一些信号，来表明这个异步事件完成。就像你约会提前1小时到见面地点，先去买点东西踩点什么的（……），等GF/BF到了之后短信通知你，你就立即回来。而不是一直在原地等到对方过来（……）\n\n最早使用异步开发，是在使用JavaScript来开发Web前端的时候，**XMLHttpRequest**或者**jQuery**的**$.ajax**中，都会用到回调函数，来指明成功或者失败之后的处理方法。当对应的网络请求得到响应之后，会调用响应的成功或者失败的回调函数，然后执行里面相应的方法，这大大提升了前端的效率，不会在网络请求时整个页面卡住，而且也不需要一次次轮询看是否有响应，简化了代码的复杂性。\n\n这点Node.js中更为常见，不过也更能表现中滥用异步事件编程的问题。新人使用Node.js总会发现基本任何东西都是异步的，数据库是异步的，IO文件操作是异步的，Session读写是异步的，甚至获得Request对象都是异步的。这就导致很多人一直在嵌套回调函数，导致了著名的[Callback Hell][1]\n\n在Node.js中，解决方案有非常成熟的[Async][2]，更有号称能用同步思维写异步的[Promises][3]，都是非常棒的解决方案。前者的本质就是一个自动生成回调的封装……，后者则是一个真正意义上的全新的解决方案。\n\n而在Swift和iOS开发中，也有必须用到异步事件编程的地方。除了View层的简单UI和Controller之间的交互以外（这部分一般不需要手写代码处理异步交互或者顺序），其他很多地方需要这些知识。例如网络请求的异步调用，请求队列的处理（虽然可以一个网络请求就是一个线程，但这种方法的效率不高，而且容易导致线程间冲突），SQLite数据库大量数据的读写，本地存储的大量数据读写，复杂UI的渲染顺序等等……这些都是需要进行异步编程的，而不能让同步的代码阻塞住整个应用或者UI。\n\n举个例子，这里是一个UI顺序加载的动画……\n\n```swift\nfunc schoolLifeClicked()\n{\n    var mydrawerController = self.mm_drawerController //一个用TableView实现的应用侧边栏抽屉View\n    let schoolLifeViewController:SchoolLifeViewController = SchoolLifeViewController(nibName: \"SchoolLifeViewController\", bundle: nil)\n    let navSchoolLifeViewController = CommonNavViewController(rootViewController: schoolLifeViewController)\n\n    self.mm_drawerController.toggleDrawerSide(MMDrawerSide.Left, animated: true, completion:{(complete) in\n        if complete{//如果成功拉出抽屉\n            mydrawerController.setCenterViewController(navSchoolLifeViewController, withCloseAnimation: true, completion: nil)//设置主视图\n            mydrawerController.closeDrawerAnimated(true, completion:nil)//关闭抽屉\n        }\n    })//一个闭包，成功后调用\n}\n```\n\n可以看到，Swift很多时候也可以依靠回调函数，把一个闭包扔进去当参数，然后执行，从而控制这种异步事件的流程……\n\n但是，这种方法写起来，就会回到和JS那种匿名函数闭包扔进去当参数一样，小范围用还可以，一旦你要进行复杂的流程控制，比如一系列异步事件，AB同时执行，AB同时完成后执行C，C执行完成后执行D……这种控制下写出来的代码和JavaScript的callback hell是一样的，难以维护。\n\n怎么办呢？其实自己实现一个语法糖或者函数队列来执行也不难，不过这里可以推荐一下GitHub上非常厉害的库，大家有兴趣也要认真看看源码（虽然源码是Objective-C的……但是慢慢来） 链接： [Async][4]这个利用了OS X 10.10和iOS8的[GCD][5]技术，只能在这个平台以上 [Async.legacy][6]兼容OS X 10.9和iOS7\n\n怎么使用呢？参考人家的Readme，用语法糖可以很简单的使用：\n\n```swift\nAsync.userInitiated {\n    println(\"start\")\n}.main {\n    println(\"1\")\n}.background {\n    println(\"2\")\n}.background {\n    println(\"2 all the same\")\n}.main {\n    println(\"stop\")\n}\n```\n\n由于异步事件的特点，所以整个输出可能就会是\n\n```text\nstart\n1\n2\nstop\n2 all the same\n```\n\n不要大惊小怪哦。利用这个就可以从繁重的callback中解放出来，简单的处理异步事件的顺序，并且获得很高的性能，这也是网络请求和数据库访问等必须要考虑的地方……\n\n最后，我还是多看看关于异步事件，闭包的知识，对这些知识有了更深的了解，不仅对iOS开发，对Web开发，客户端开发，并行计算算法的实现等都会十分有帮助。\n\n [1]: http://www.tuicool.com/articles/Ur2EfmZ\n [2]: https://github.com/caolan/async\n [3]: https://github.com/then/promise\n [4]: https://github.com/duemunk/Async\n [5]: http://en.wikipedia.org/wiki/Grand_Central_Dispatch\n [6]: https://github.com/josephlord/Async.legacy","categories":["iOS"],"tags":["iOS","Swift"]},{"title":"iOS开发学习-用继承，静态类封装方法","url":"/2016/03/30/iOS%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0-%E7%94%A8%E7%BB%A7%E6%89%BF%EF%BC%8C%E9%9D%99%E6%80%81%E7%B1%BB%E5%B0%81%E8%A3%85%E6%96%B9%E6%B3%95/","content":"\niOS开发中，如果不进行适当的封装，使用协议或者继承类来进行开发，你就会遇到传说中的ViewController（以后简称VC） Hell的问题……\n\n比如说，我们先声网App中为了调用接口，做简单的判断，会有如下的垃圾代码（前辈遗留下来的）：\n\n```swift\noverride func viewDidLoad() {\n    super.viewDidLoad()\n\n    var color = UIColor(red: 153/255, green: 204/255, blue: 204/255, alpha: 1)\n    self.navigationController?.navigationBar.barTintColor = color\n\n    self.httpController.delegate = self\n\n    Config.shareInstance().isNetworkRunning = CheckNetwork.doesExistenceNetwork()\n\n    if Config.UUID == nil || Config.UUID!.isEmpty\n    {\n        Tool.showErrorHUD(\"去信息门户登录一下吧:)\")\n    }\n    else if !Config.shareInstance().isNetworkRunning\n    {\n        Tool.showErrorHUD(\"貌似你没有联网哦\")\n    }\n    else\n    {\n        Tool.showProgressHUD(\"正在更新校园网信息\")\n        sendNicAPI()\n    }\n    // Do any additional setup after loading the view.\n}\n\nfunc sendNicAPI(){\n    let nicURL = \"http://herald.seu.edu.cn/api/nic\"\n    let parameter:NSDictionary = [\"uuid\":Config.UUID!]\n\n    self.httpController.postToURLAF(nicURL, parameter: parameter, tag: \"nic\")\n}\n\nfunc didReceiveDicResults(results: NSDictionary, tag: String) {\n    if let content:NSDictionary = results[\"content\"] as? NSDictionary{\n        if tag == \"nic\"{\n            firstSend = false\n            Tool.showSuccessHUD(\"获取信息成功\")\n            println(content.allKeys)\n        }\n    }\n}\n```\n\n看到了吗，每个VC开头都得这样写一发，如果我们有20多个功能呢？会变成什么样子？\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/9/39/e8ffcb7a5101d2e7acd62c6d72e09.png)\n\n所以，这样下去是绝对不行的，必须对整个乱七八糟的初始化，发送请求，请求接受进行封装，这里就会用到Swift最有用的协议，代理，以及闭包了。\n\n这个首先通过协议和代理，闭包放在下一篇。\n\n协议，顾名思义，也就是其他语言里面的接口（C++的抽象类也差不多） 由于Swift不支持普通类型（Int之流）设置为Static，类方法如果是静态，必须加class关键字（我觉得这个很有槽点），只有Struct和Enum可以直接用Static（也有小Tip可以用Struct包裹一个普通类型，设为计算类型，然后充当一个Static成员，但是这里不讲了）\n\n我们首先可以这样封装简单的初始化方法……\n\n```swift\nclass func initNavigationAPI(VC:UIViewController,navBarColor:UIColor) -> HttpController?{\n    var httpController:HttpController = HttpController()\n    VC.navigationController?.navigationBar.barTintColor = navBarColor\n\n    Config.shareInstance().isNetworkRunning = CheckNetwork.doesExistenceNetwork()\n\n    if Config.UUID == nil || Config.UUID!.isEmpty{\n        Tool.showSuccessHUD(\"请在边栏的个人资料中补全您的信息\")\n    }\n    else if !Config.shareInstance().isNetworkRunning{\n        Tool.showErrorHUD(\"貌似你没有联网哦\")\n    }\n    else{\n        Tool.showProgressHUD(\"正在获取信息\")\n        return httpController\n    }\n    return nil\n}\n```\n\nOK？那个HttpController是另一个接口，来进行网络操作的，代理需要靠它，所以我们返回一个HttpController实例，如果失败就返回nil，在实际VC里面加一个解包判断即可。\n\n以后，想要初始化，就只需要这样了\n\n```swift\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    var color = UIColor(red: 153/255, green: 204/255, blue: 204/255, alpha: 1)\n    self.httpController = Tool.initNavigationAPI(self,navBarColor: color) ?? nil\n\n    if (self.httpController != nil){\n        self.httpController!.delegate = self\n        Tool.sendAPI(\"cardDetail\", httpController: self.httpController!)\n    }\n}\n```\n\n把一群乱七八糟的代码扔走。下一步就是如果用代理来代理我们所有的请求以及相应的结果了，下一篇文章补上……","categories":["iOS"],"tags":["iOS"]},{"title":"iOS开发面试面试知识合集","url":"/2016/09/25/iOS%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E5%90%88%E9%9B%86/","content":"\n> 最近一段时间到南京某公司实习之后，就一直没有更新博客，而校招季节到来，也是投了几家公司，之前不发面经是担心有泄题之类的风险，而且自己也需要调整一下心态。而现在，终于可以谈谈iOS开发的面试了\n\n# 面试技术栈\n\n技术岗位面试，基本上离不开这三方面的东西：\n\n+ 数据结构与算法\n+ 语言／框架方面基础知识\n+ 通用知识，项目\n\n所以今天专门整理了一些最近的面试中遇到的问题，对自己的能力也正确的评价一下\n\n#数据结构与算法\n\n对于国内的校招来说，《剑指offer》确实是一个特别好的书，同时也有用Web版的[在线答题](http://www.nowcoder.com/ta/coding-interviews?page=1)来做，里面的题基本上面试都会见到，而且并没有超出一般程序员的水平（ACMer请忽略），基本上是人人必备宝典，推荐认真读一遍，[LeetCode](https://leetcode.com/)的话，难度是Easy和Normal的题目尽量做（当然，一些特别复杂比如迷宫搜索，就不必强求了）\n\n常见的题目，基本上分两类：数据结构类（比如什么`反转链表`、`各种遍历`、`二叉搜索树插入删除`、`最大堆实现`）和算法类（`ATOI`、`2sum`、`TopK问题`（很常见）、DP问题如`最长公共子串`等），基本面试的题目不会特别难（要考虑手写出来的时间），保证基础功好一点，临场不断提出新的解题方法（暴力->递归->DP），总会有方法的\n\n数据结构：\n\n+ 链表（反转，合并，找环，排序）\n+ 二叉树（检查，遍历，高度，反转）\n+ 堆（最大堆，最小堆，TopK问题）\n+ 哈希表（再散列法，拉链法，冲突处理，简单Hash算法）\n+ 字典树（实现，配合TopK问题）\n\n算法：\n\n+ 排序（插入，选择，冒泡，归并，快排，堆排，基数，计数）\n+ 搜索（二分、二叉搜索树、DFS/BFS、图的最小生成树，最短路径（Dijkstra））\n+ 递归（树的各种问题，包括迭代求法（stack/queue实现），LCA之类）\n+ 贪心（出现的比较少，比如股票问题之类）\n+ 动态规划（楼梯、硬币、LCSequence、LCString、回文）\n\n#语言方面\n\niOS的话，基本上面试只会考虑Objective-C，毕竟是国内公司现状，产品线和项目基本都是纯Obejctive-C写的，短期无法改变。Swift可能会作为加分项目，但其实如果熟悉C或者C++的话加分的概率会更大（实际项目中，多是Objective-C和C结合用的）。对于不知道问题的方向的，可以先参考这篇[《招聘一个靠谱的 iOS》](https://github.com/ChenYilong/iOSInterviewQuestions)，权当自我检测一下\n\n对于Objective-C的语言知识，基本上下面的都问道过，建议应该打好基础，了解清楚：\n\n+ 内存管理（MRC，ARC，assign，weak，strong，copy，unsafe_unretain）\n+ Block（循环引用，\\_\\_block关键字，block类型，block_copy）\n+ 多线程（GCD，NSOperationQueue， NSThread），了解复杂同步异步混合逻辑如何处理，线程安全\n+ 消息转发机制（objc_msgSend），五个对应消息转发方法的顺序，isa指针，self/super，method swizzling\n+ RunLoop（Source，Observer，Timer，NSTimer滚动回调问题），AutoreleasePool在RunLoop作用，source源和UIKit事件\n+ Runtime（AssociatedType实现Category属性，消息，swizzling）\n+ AutoreleasePool（UI事件会隐式创建AutoreleasePool，循环体内手动创建避免内存峰值），autorelease消息，Pool drain的时机（Runloop一次周期的休眠前）\n+ KVC/KVO原理（isa_swizzling），和其他方式对比\n+ 属性观察（NSNotification、Delegate、KVO）的对比，线程安全\n+ 设计模式，观察者模式，代理模式，工厂模式等\n+ 响应者链，HitTest，第一响应者概念\n+ ViewController/View生命周期，依次调用方法，手动布局步骤\n+ 性能优化、离屏渲染（drawRect和UIBezierPath）\n+ UIView，CALayer的关系，动画处理（Core Animation）\n+ CoreData使用，SQLite对比优/缺点，managedObject跨线程问题\n+ MVC，MVP，MVVM区别\n\n#通用知识，项目\n\n通用知识，一般是本科的课程基础知识，基本上以下对于移动开发都是重要的，因此一定要注意。而且面试也会问到（以HTTP/TCP最多）：\n\n+ HTTP协议具体请求/响应格式，HTTPS原理\n+ TCP/UDP区别，TCP/UDP头，TCP三次握手四次挥手，滑动窗口机制\n+ 线程和进程的区别，调度方式\n+ 操作系统时间片法，多级队列，内存LRU，磁盘SCAN等\n+ 数据库范式、索引、数据库锁\n\n\n项目，基本上是你自己做的一些应用，你需要了解自己做的项目的大体架构，同时对一些组件、复用、网络层的功能实现要知晓，使用的开源库的源代码如果也看过或者了解过最好不过了，比如：\n\n+ 自动布局/手动布局，解释Constrains，手动布局步骤（initWithFrame:，addSubviews:，layoutSubviews:，sizeThatFits:等之类）\n+ 动态TableView高度，下拉刷新控件实现，进度条实现\n+ SDWebImage源码，NSCache原理简介\n+ AFNetworking对RunLoop的利用\n+ JSPatch/wxPatch之类的原理简介\n+ 异步请求回调，对象线程安全问题\n+ 优化问题，圆角图片等\n\n#其他问题\n\n其他问题，一般就是类似HR面的内容，可能会有一些对项目管理的看法，人际交往能力、对待加班态度。注意面试官问到你“你还有什么要问我的吗”一定要主动交谈，可以问一些关于对应事业部的环境、技术氛围、是否可以实习等等问题。但是不必谈薪资或者录用与否，毕竟这主要是最终企业还有多方共同决定的。到这一步的话，面试主要的目的就是一个双方互相了解的过程，所以你也应当主动去问各种问题，去了解公司、团队以及职位等相应内容。\n\n总体来说，基本上原则还是那句话：“真话挑着说，假话绝不说”，保持自信，主动提问，基本上就没问题。如果真到最后却还是失之交臂，一般都是自己前几面表现有些问题，毕竟招聘不是过关制度，最后决定是否录用的时候，前几面的面试官意见都会参考，所以只能说每一面都需要做好准备，尽量表现自己\n\n#学习福利\n对于我这种自学iOS开发的，很多基本知识都是后来才补的，在这过程中参考了很多资料，这里就列举出其中最有用的吧：\n\n[GitHub-必看面试问题](https://github.com/ChenYilong/iOSInterviewQuestions)\n\n[objc期刊-各种iOS进阶知识，架构](https://objccn.io/issues/)\n\n[NSHipster-包括KVC/KVO，Swizzling等，非常全面](http://nshipster.com/)\n\n[NSHipster-中文版](http://nshipster.cn/)\n\n[iOS设计模式](https://www.raywenderlich.com/46988/ios-design-patterns)\n\n[iOS多线程](http://www.jianshu.com/p/0b0d9b1f1f19)\n\n[Core Data教程](https://www.raywenderlich.com/115695/getting-started-with-core-data-tutorial)\n\n[ibireme博客-主要是Runtime，RunLoop](http://blog.ibireme.com)\n\n[sunnyxx博客-主要是高级iOS知识和优化](http://blog.sunnyxx.com)\n\n[唐巧的博客-主要是iOS开发工具](http://blog.devtang.com)\n\n[SDWebImage原理](http://www.jianshu.com/p/ba4cbf8dfe49)\n\n[AFNetworking原理](http://www.jianshu.com/p/358dc280fb33)\n\n[JSPatch原理](https://github.com/bang590/JSPatch/wiki/JSPatch-实现原理详解)\n\n#结语\n经历了某公司实习，还有一些面试的碰壁，也慢慢认清自己的实力，自己在iOS开发这个方向上自己还有很长很长的路要走，现在也应该继续努力提升自己。在祝愿自己的同时，也希望处于就职路途中的iOS程序猿们能够一起共勉，找到心仪的offer","categories":["iOS"],"tags":["iOS","Objective-C","面试"]},{"title":"iOS端矢量图解决方案汇总（SVG篇）","url":"/2020/03/30/iOS%E7%AB%AF%E7%9F%A2%E9%87%8F%E5%9B%BE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB%EF%BC%88SVG%E7%AF%87%EF%BC%89/","content":"\n# iOS端矢量图解决方案汇总（SVG篇）\n## 简介\n\n[矢量图](https://en.wikipedia.org/wiki/Vector_graphics)，指的是通过一系列数学描述，能够进行无损级别的变化和缩放的一种图像。相比于标量图（如JPEG等标量图压缩格式），能够在绘制时进行任意大小伸缩而不产生模糊，甚至能够实现动态着色，动画等等一系列交互。\n\n![intro_raster_to_vecto](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2020-03-30/image/intro_raster_to_vector.png)\n\n\n在当今移动端设备尺寸越来越复杂，各种操作系统级别的夜间主题（或者Dark Mode）越来越提倡的场景下，如果依旧使用标量图，我们需要针对不同的屏幕大小（如2x，3x），和对应主题场景（Light/Dark），提供NxM数量级的标量图，对于App大小开销是很大的。因此，使用矢量图是一个非常有效的解决方案。这个系列文章，就是主要侧重讲解iOS端上的矢量图解决方案。\n\n第一章是关于[SVG](https://en.wikipedia.org/wiki/Scalable_Vector_Graphics)及其相应衍生方案的解决方案，后续会有其他矢量图相关的PDF章节，Lottie等。他们各自有不同的细节场景区分和优缺点。\n\nSVG作为目前在Web上最流行的矢量格式，在iOS端的支持可以说是一言难尽。在这里，我从各个方向上总结了截至目前已有的实现（\u0010公开的方案，企业内部实现无从得知），方便对比选择最适合自己场景的选择。\n\n## Symbol Image\n\n[Symbol Image](https://developer.apple.com/videos/play/wwdc2019/206/)，是Apple在WWDC 2019和iOS 13上提供的矢量图解析方案。\n\n之所以名称叫做Symbol Image，源自于这个技术方案的实现细节，它最早诞生于SVG字体规范：[OpenType-SVG](https://helpx.adobe.com/fonts/using/ot-svg-color-fonts.html)。这个规范是Adobe提出的，并且得到了包括Microsoft在内的多家公司支持。Apple自己的CoreText字体框架，其实早早就在[iOS 11时代](https://developer.apple.com/documentation/coretext/1524658-anonymous/kctfonttablesvg?language=objc)内部支持了SVG类型的font table。\n\n### 制作Symbol Image\n\nSymbol Image的整体API设计，其实不像是图像，更像是一种字体（和Icon Font类似）。\n\n对于同一个Symbol Image，它可以看作是一个SVG Path的集合。前面提到，Symbol Image基于OpenType-SVG字体，对于字体来说，我们都知道字重的概念，用来决定渲染时候的线条粗细程度。\n\n因此Symbol Image也有9个字重：Ultralight，Thin，Light，Regular，Medium，Semibold，Bold，Heavy，Black。与此同时，Symbol Image对每一个字重，支持了3种大小，分别是Small，Medium和Large。这也就是说，一个Symbol Image最多可以有27种大小字重的样式选择。\n\n一般来说，从头构建一个Symbol Image会非常复杂，Apple推荐的方式，是通过使用[SF Symbols App](https://developer.apple.com/design/human-interface-guidelines/sf-symbols/overview/)，来导出一个SVG模版，再通过Sketch来进行图层编辑。\n\n![Sketch2](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2020-03-30/image/Sketch2.png)\n\n\n从原始的SVG数据来看，每一个Symbol Image包含的所有样式都是一个单独的Path节点，对应了图标的绘制。如果要新建一个Symbol Image，需要完全删除Path节点，重新绘制矢量路径。\n\n```xml\n<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"3300\" height=\"2200\">\n <!--glyph: \"uni100665.medium\", point size: 100.000000, font version: \"Version 15.0d7e11\", template writer version: \"5\"-->\n <g id=\"Notes\">\n </g>\n <g id=\"Guides\">\n  <g id=\"H-reference\" style=\"fill:#27AAE1;stroke:none;\" transform=\"matrix(1 0 0 1 339 696)\">\n<path d=\"M 54.9316 0 L 57.666 0 L 30.5664 -70.459 L 28.0762 -70.459 L 0.976562 0 L 3.66211 0 L 12.9395 -24.4629 L 45.7031 -24.4629 Z M 29.1992 -67.0898 L 29.4434 -67.0898 L 44.8242 -26.709 L 13.8184 -26.709 Z\"/>\n </g>\n <g id=\"Symbols\">\n  <g id=\"Medium-M\" transform=\"matrix(1 0 0 1 1682.22 1126)\">\n   <path d=\"M 64.3555 -18.6035 C 67.8223 -18.6035 69.9219 -20.752 70.0195 -24.3164 C 70.166 -40.2832 70.5078 -59.7656 70.6543 -75.1953 C 70.6543 -78.7598 67.9688 -81.3477 64.3555 -81.3477 C 60.6934 -81.3477 58.0078 -78.7598 58.0078 -75.1953 C 58.1543 -59.7656 58.4961 -40.2832 58.6914 -24.3164 C 58.7891 -20.752 60.8887 -18.6035 64.3555 -18.6035 Z M 17.1875 -41.0645 C 18.1641 -40.0391 19.7266 -40.0879 20.7031 -41.1621 C 29.2969 -50.2441 39.9414 -56.0547 51.8066 -58.3984 L 51.6113 -73.3398 C 34.8145 -70.4102 19.5801 -61.7676 10.498 -50.7812 C 9.76562 -49.9023 9.76562 -48.6816 10.6445 -47.7539 Z M 108.057 -41.1133 C 108.984 -40.1367 110.498 -40.1367 111.523 -41.2109 L 117.969 -47.7539 C 118.896 -48.6816 118.896 -49.9023 118.164 -50.7812 C 108.984 -61.6699 93.7988 -70.3613 77.0508 -73.291 L 76.9043 -58.3496 C 88.7695 -56.0059 99.3164 -50.0488 108.057 -41.1133 Z M 36.6699 -21.5332 C 37.793 -20.4102 39.2578 -20.5078 40.2832 -21.7285 C 43.457 -25.1465 47.7051 -28.0273 52.3926 -29.7852 L 51.9531 -45.4102 C 42.4805 -43.0664 34.375 -37.9883 29.1992 -31.8359 C 28.3691 -30.8594 28.4668 -29.6875 29.3457 -28.8086 Z M 88.5254 -21.5332 C 89.5508 -20.459 90.8691 -20.5078 91.9922 -21.582 L 99.2676 -28.8086 C 100.195 -29.6875 100.293 -30.8594 99.4629 -31.8359 C 94.2871 -37.9395 86.1816 -43.0176 76.709 -45.4102 L 76.3184 -29.6875 C 81.0547 -27.8809 85.3516 -24.9512 88.5254 -21.5332 Z M 64.3555 6.25 C 69.043 6.25 72.8516 2.53906 72.8516 -2.09961 C 72.8516 -6.73828 69.043 -10.4492 64.3555 -10.4492 C 59.668 -10.4492 55.8105 -6.73828 55.8105 -2.09961 C 55.8105 2.53906 59.668 6.25 64.3555 6.25 Z\"/>\n  </g>\n </g>\n</svg>\n```\n\n\n### 导入Symbol Image\n\n导入Symbol Image的方式非常简单，你只需要将制作好的Symbol Image，向Xcode的Asset Catalog窗口拖动，就可以集成。Xcode可以会展示对应的预览效果。\n\n![截屏2020-03-30下午6.08.56](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2020-03-30/image/%E6%88%AA%E5%B1%8F2020-03-30%E4%B8%8B%E5%8D%886.08.56.png)\n\n\n另外，实际上产生的文件夹后缀为`.symbolset`，这个不同于普通的Asset Image（后缀名`.imageset`），也就意味着你可以同时引入一个同名的Symbol Image和普通Image。\n\n![截屏2020-03-30下午6.09.18](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2020-03-30/image/%E6%88%AA%E5%B1%8F2020-03-30%E4%B8%8B%E5%8D%886.09.18.png)\n\n### 使用Symbol Image\n\n对于iOS 13系统提供的自带Symbol Image，UIKit提供了[init(systemName:)](https://developer.apple.com/documentation/uikit/uiimage/3294233-init)方法来获取，对于App自行提供的Symbol Image，我们使用[init(named:)](https://developer.apple.com/documentation/uikit/uiimage/1624146-init)方法。\n\n注意，你可以同时包含一个Symbol Image和普通的Asset Image，共享一个Name。这样设计的好处，在WWDC上有介绍，是为了兼容iOS 12等低系统版本，在iOS 13上，Symbol Image优先级永远高于普通Asset Image，在iOS 12会自动fallback。\n\n```swift\nlet imageView = UIImageView()\nlet symbolImage = UIImage(named: \"my.symbol.image\")\n// 默认配置下，这个symbol image是template的，意味着他不会含有颜色，颜色由UIView级别tintColor决定\nimageView.image = symbolImage\n\n// 如果确定要获取系统Symbol Image\nlet systemSymbolImage = UIImage(systemName: \"wifi.exclamationmark\")\n\n// 如果要指定颜色\nlet redSymbolImage = symbolImage.withTintColor(.red, renderingMode: .alwaysOrigin)\nimageView.image = redSymbolImage\n```\n\n对于Symbol Image来说，我们可以指定在运行时需要的字重\n\n```swift\nlet regularSymbolImage = UIImage(named: \"my.symbol.image\")\n// 指定你想要的字号，字重，这里是18号，Bold 字重，Large 大小\nlet symbolConfiguration = UImage.SymbolConfiguration(pointSize: 18, weight: .large, scale: .large)\nlet boldSymbolImage = regularSymbolImage.applyingSymbolConfiguration(symbolConfiguration)\nimageView.image = boldSymbolImage\n```\n\n另外，我们还可以配合AttributedString使用，只要使用TextAttachment传入对应的Symbol Image即可。\n\n```swift\nlet textView = UITextView()\n// 可以微调Symbol Image与文字的对齐\nlet baselineSymbolImage = symbolImage.withBaselineOffset(fromBottom: 1.0)\nlet imageAttachment = NSTextAttachment(image: baselineSymbolImage)\nlet imageString = NSAttributedString(attachment: imageAttachment)\ntextView.attributedText = imageString\n```\n\n### 优缺点\n\n优点：\n\n+ iOS原生支持，工具链完善\n+ SwiftUI原生支持，截止目前Image能唯一使用的矢量方案（排除UIViewRepresentable）\n+ 支持和AttributedString无缝混合，类似Icon Font\n\n缺点：\n\n+ iOS 13+ Only\n+ 通过字体属性控制大小，取决于UI场景，做到Pixel级别的拉伸会是一个问题\n+ 需要单独制作Symbol Image，跨平台，Web使用痛点\n\n## CoreSVG\n\nCoreSVG是iOS 13支持Symbol Image的背后的底层SVG渲染引擎，使用C++编写。\n\n截至目前，CoreSVG依然属于Private Framework，社区也有很多人向Apple提了反馈并建议开放出来，可能在之后的WWDC 2020我们能够得知更多的消息。\n\n注意！以下方法均为使用了CoreSVG的Private API，可能随着操作系统变动会有改变，并且有审核风险，如果需要线上使用，请自行进行代码混淆等方案。\n\n### 通过Asset Catalog使用SVG\n\n目前Xcode不支持直接拖动SVG文件来集成到Asset Catalog，因为拖动SVG默认会当作Symbol Image处理。\n\n但是我们可以通过一个取巧的方式来实现，Xcode支持PDF矢量图（从iOS 11与Xcode 9开始支持，PDF章会讲解）。因此，我们可以将SVG后缀改成PDF，然后拖动到Xcode中，最后再修改回SVG后缀名，并且同步`.imageset/Contents.json`里面的文件名即可，如下：\n\n![EUR_hKSUwAA1-65](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2020-03-30/image/EUR_hKSUwAA1-65.png)\n\n当你添加好SVG图像后，可以通过Name，以和PDF矢量图一样的方式来引入和使用，如下\n\n```objectivec\nUIImageView *imageView = [UIImageView new];\nUIImage *svgImage = [UIImage imageNamed:@\"my_svg\"];\nimageView.image = svgImage;\n// 然后我们可以自由缩放ImageView的大小，会自动触发矢量绘制\nimageView.frame = CGRectMake(0, 0, 1000, 1000);\n```\n\n从运行时来看，加入Asset Catalog的SVG矢量图的UIImage，含有对应的CGSVGDocumentRef对象，并且也包含了一个标量图的缩略图，可以供缩略图或者其他系统API来调用。并且在Xcode的Interface Builder上也会有明显的SVG标识（类似PDF）\n\n![EUU_DLPU8AM5KHD](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2020-03-30/image/EUU_DLPU8AM5KHD.jpeg)\n\n\n### 加载任意SVG数据（网络）\n\n除了能够通过Asset Catalog添加SVG图像，通过CoreSVG，我们可以在运行时去解析网络数据下载得到的SVG数据，为此能提供更为广阔的应用场景。\n\n```objectivec\nUIImageView *imageView = [UIImageView new];\nNSData *data;\nCGSVGDocumentRef document = CGSVGDocumentCreateFromData((__bridge CFDataRef)data, NULL);\nUIImage *svgImage = [UIImage _imageWithCGSVGDocument:document];\nimageView.image = svgImage;\n```\n\n### 渲染SVG矢量图到标量图\n\n一些UIKit的视图，或者一些图像处理，对矢量图支持并没有考虑，或者是我们在做性能优化时，需要将矢量图光栅化得到对应的标量图。CoreSVG提供了和CoreGraphics的PDF类似的接口，允许你去绘制得到对应的标量图。\n\n```objectivec\nCGSVGDocumentRef document; // 原始SVG Document\nCGSize targetSize; // 指定标量图大小\nBOOL preserveAspectRatio; // 是否保持宽高比\n\n// 获取SVG的canvas大小，本质上是按照SVG规范，将viewPort和viewBox计算得出的\nCGSize size = CGSVGDocumentGetCanvasSize(document);\n// 计算Transform\nCGFloat xRatio = targetSize.width / size.width;\nCGFloat yRatio = targetSize.height / size.height;\nCGFloat xScale = preserveAspectRatio ? MIN(xRatio, yRatio) : xRatio;\nCGFloat yScale = preserveAspectRatio ? MIN(xRatio, yRatio) : yRatio;\n    \nCGAffineTransform scaleTransform = CGAffineTransformMakeScale(xScale, yScale);\nCGSize scaledSize = CGSizeApplyAffineTransform(size, scaleTransform);\nCGAffineTransform translationTransform = CGAffineTransformMakeTranslation(targetSize.width / 2 - scaledSize.width / 2, targetSize.height / 2 - scaledSize.height / 2);\n// 开始CGContext绘制\nUIGraphicsBeginImageContextWithOptions(targetSize, NO, 0);\nCGContextRef context = UIGraphicsGetCurrentContext();\n// UIKit坐标系和CG坐标系转换\nCGContextTranslateCTM(context, 0, targetSize.height);\nCGContextScaleCTM(context, 1, -1);\n// 应用Transform   \nCGContextConcatCTM(context, translationTransform);\nCGContextConcatCTM(context, scaleTransform);\n// 绘制SVG Document\nCGContextDrawSVGDocument(context, document);\n// 获取标量图\nimage = UIGraphicsGetImageFromCurrentImageContext();\nUIGraphicsEndImageContext();\n```\n\n### SVG导出\n\n目前，CoreSVG没有提供类似于PDF的修改元素的接口，我们只能直接对SVGDocument进行导出。或许随着未来框架的开放，会有类似于目前CoreGraphics对PDF进行编辑的高级接口。\n\n```objectivec\n// 获取SVG Document\nUIImage *svgImage;\nCGSVGDocumentRef document = [svgImage _CGSVGDocument];\nNSURL *url = [NSURL fileURLWithPath:@\"/tmp/output.svg\"];\nNSMutableData *data = [NSMutableData data];\n// 导出到Data\nCGSVGDocumentWriteToData(document, (__bridge CFMutableDataRef)data, NULL);\n// 或者文件\nCGSVGDocumentWriteToURL(document, (__bridge CFURLRef)url, NULL);\n```\n\n### 优缺点 \n\n优点\n\n+ 能够支持目前已有的大量SVG，在Android和Web端复用\n+ Apple原生支持，稳定性有一定保证，并且随系统升级会持续优化\n+ 性能高，CoreSVG利用了CoreGraphics系统库和内部的SPI做矢量绘制，目前性能最好\n\n缺点\n+ 目前是私有Framework，有审核和使用风险\n+ 可能存在一些SVG元素兼容问题，需要不断摸索\n+ SwiftUI不支持，需要使用UIViewRepresentable\n\n## 三方SVG库\n\n### [SVGKit](https://github.com/SVGKit/SVGKit)\n\nSVGKit是最早的iOS上开源SVG渲染方案，已经有8年之久。SVGKit内部支持两种渲染模式，一种是通过CPU渲染（CoreGraphics重绘制），一种是通过GPU渲染（CALayer树组合）。有着不同的兼容性和性能。\n\n示例\n\n```objectivec\n// CPU渲染\nSVGKImageView *imageView = [SVGKFastImageView new];\n// GPU渲染\nimageView = [SVGKLayeredImageView new];\nSVGKImage *svgImage = [[SVGKImage alloc] initWithData:data];\nimageView.image = svgImage;\n```\n\n优点\n\n+ 支持纯Objective-C\n+ 如果是支持的图像，性能相对较高（1000个级别的Path可在1秒内渲染）\n\n缺点\n\n+ 社区不再维护，大量Issue无人跟进解决\n+ 不遵循语义版本号，用分支发布更新，下游无法依赖\n+ 部分SVG特性虽然声明支持，但存在问题，如Gradient等，缺少单测\n+ 不支持SVG动画\n\n### [Macaw](https://github.com/exyte/Macaw)\n\nMacaw是一个矢量绘制框架，提供了非常简单的DSL语法来描述矢量路径绘制的场景。它本身不是和SVG强绑定的，但是对SVG格式提供了兼容和支持\n\n示例\n\n```swift\nlet node = try! SVGParser.parse(path: \"/path/to/svg\")\nlet imageView = SVGView()\nimageView.node = node\n```\n\n优点\n\n+ 目前最活跃和成熟的iOS端SVG开源框架（在GitHub上）\n+ 支持DSL去直接生成矢量图，修改节点等，非常强大\n+ 支持SVG动画（部分特性）\n\n缺点\n\n+ 部分SVG特性特性声明不支持\n+ SVG性能渲染差（相对于SVGKit），依赖大量的的CPU绘制操作（非CALayer组合），可能需要结合异步绘制框架\n\n### [SwiftSVG](https://github.com/mchoe/SwiftSVG)\n\nSwiftSVG是一个专门针对SVG Path等常见特性的矢量图解析框架，他不侧重于完整的SVG/1.1规范支持，而是保证了基本的绘制实现的正确性，并且支持导出SVG的Path到UIBezierPath\n\n示例\n\n```swift\nlet svgURL = URL(string: \"https://openclipart.org/download/181651/manhammock.svg\")!\nlet hammock = UIView(SVGURL: svgURL) { (svgLayer) in\n    svgLayer.fillColor = UIColor(red:0.52, green:0.16, blue:0.32, alpha:1.00).cgColor\n    svgLayer.resizeToFit(self.view.bounds)\n}\nself.view.addSubview(hammock)\n```\n\n优点\n\n+ 性能相对MacPaw较好\n+ 对Path，Circle等常见元素，有着良好的兼容性和完整单测，基本上只用这些特性的SVG不存在问题\n+ 支持导出UIBezierPath，可以用作一些描边的交互\n+ 提供了便携方法，能直接读取Xcode的Data Asset，URL等\n\n缺点\n\n+ 基本上只针对Path，Circle等元素有良好的支持，其他的Gradient，Text等均不支持\n+ 不支持SVG动画\n\n## VectorDrawable\n\n[VectorDrawable](https://developer.android.com/guide/topics/graphics/vector-drawable-resources)是Android平台上官方提供的一套矢量图解决方案，他是以一个类似SVG的XML表达形式，来描述矢量图的绘制方式。\n\n![截屏2020-03-30下午5.44.59](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2020-03-30/image/%E6%88%AA%E5%B1%8F2020-03-30%E4%B8%8B%E5%8D%885.44.59.png)\n\n\n从整体设计上看，VectorDrawable基本上是对SVG的精简和二次改造，大部分的元素在SVG中都有对应的概念，并且样式属性也一一对应。甚至，Android Studio支持直接将SVG导出成VectorDrawable文件并直接集成。\n\n在iOS上平台上，Uber内部开源了一套自己在用的VectorDrawable实现：[Cyborg](https://github.com/uber/cyborg)，通过利用CoreGraphics和CoreAnimation来渲染VectorDrawable文件。\n\n### 使用VectorDrawable渲染\n\nVectorDrawable提供了一个专门用于矢量图的View，并且能够制定对应的Theme（Theme是用来支持不同资源的Dark Mode切换的）。\n\n```swift\n// Bundle加载\nlet vectorView = VectorView(theme: myTheme)\nvectorView.drawable = VectorDrawable.named(\"MyDrawable\")\n\n// Data加载\nvectorView.drawable = VectorDrawable.create(from: data)\n```\n\n如果这个不满足，你也可以通过CALayer来做渲染，做更为细致的调节。并且VectorDrawable也提供了一些定制项（如设置tintColor）\n\n### 优缺点\n\n优点\n\n+ 能够和Android端复用，并且由于可由SVG生成，意味着Web端也可复用设计资源\n+ 性能良好，无论官方还是Example测试，除去CoreSVG外都是最快的渲染速度\n\n缺点\n\n+ 目前iOS实现不支持动画（AnimatedVectorDrawable）\n+ 部分SVG实现VectorDrawable不支持，需要设计资源修改\n+ Uber内部开源，可能存在未来持续社区建设和维护成本，需要评估\n\n## SVG-Native\n\n[SVG-Native](https://svgwg.org/specs/svg-native/)是由Adobe主导提出的一个W3C规范，目前处于Draft Stage，不过由于Apple，Google的赞同，大概率会在2020年内通过，并且正式规范定稿。\n\nSVG-Native基于目前的SVG/1.1版本，是SVG/1.1的真子集（即一个SVG-Native图一定可以被浏览器正确渲染）。\n\n注：曾经W3C有一个SVG Tiny的规范，但是它是针对移动浏览器场景的，和SVG-Native解决的问题是不一样的。\n\n它针对移动平台，桌面平台等非浏览器场景做了针对性定制，废弃了一些Native端非常困难实现的功能，包括：\n\n+ scripting: 不依赖JavaScript环境\n+ animations: 不支持动画\n+ filters: 不支持滤镜，部分效果（如文字滤镜）依赖实现复杂\n+ masks: 不支持蒙层\n+ patterns: 不支持仿制图章，Color Pattern\n+ texts: 不内嵌文字，文字使用Path绘制\n+ events: 点击事件等，因为没有Script交互自然不需要\n+ CSS3：CSS3是一个完整布局系统，大量属性远远超过SVG的功能，如Flexbox，Media-Query，都是不必要的，只有基本的渲染属性\n\n可以看出，这些剥离的功能都是和浏览器场景完全绑定的，不适用于通用的App内渲染矢量图的用途。SVG-Native更适合桌面/移动的App，渲染器实现也会精简很多，容易单元测试，并且可供操作系统内嵌集成。\n\n### 使用\n\nAdobe提供了一个目前Draft规范的渲染实现[SVG Native Viewer](https://github.com/adobe/svg-native-viewer)，目前提供了多种渲染引擎的桥接，包括我们熟悉的CoreGraphics和Skia。\n\nSVG-Native解码器，能够以标量图的方式，渲染SVG到一个指定大小的CGContext上，性能目前看足够快（和CoreSVG对比）。目前一般是通过重写drawRect来让View大小变化时进行重绘。\n\n```objectivec\n- (void)drawRect:(NSRect)dirtyRect {\n    [super drawRect:dirtyRect];\n    \n    Document* d = [[[self window] windowController] document];\n    SVGNative::SVGDocument* doc = [d getSVGDocument];\n    if (!doc)\n        return;\n    NSGraphicsContext* nsGraphicsContext = [NSGraphicsContext currentContext];\n    CGContextRef ctx = (CGContextRef) [nsGraphicsContext CGContext];\n    SVGNative::CGSVGRenderer* renderer = static_cast<SVGNative::CGSVGRenderer*>(doc->Renderer());\n    CGRect r(dirtyRect);\n    CGAffineTransform m = {1.0, 0.0, 0.0, -1.0, 0.0, r.size.height};\n    CGContextConcatCTM(ctx, m);\n    renderer->SetGraphicsContext(ctx);\n    doc->Render(r.size.width, r.size.height);\n    renderer->ReleaseGraphicsContext();\n}\n```\n\n### 优缺点\n\n优点\n\n+ W3C规范，可以确保未来规范的准确性，并且操作系统提供商，如Apple更容易集成\n+ SVG-Native是SVG1.1的真子集，意味者可以复用到Web上\n+ SVG-Native会是未来的OpenType-SVG实现，意味着Adobe字体或者设计师群体更容易接受\n\n缺点\n\n+ SVG-Native是SVG真子集，意味着目前的SVG设计资源，需要适配修改才可支持\n+ 截至目前，SVG-Native依然处于Draft阶段，稳定，推广普及需要较长时间\n+ SVG-Native目前只有Adobe的解析器实现，部分特性在CoreGraphics上工作并不良好\n+ 目前没有看到动画的支持\n\n## 总结\n\n总结一下关于SVG的相关解决方案，可以看出，没有一种Case能够涵盖所有场景，当然，这和Apple本身对矢量图支持的建设有一定关系，大部分建设依赖于开源社区。因此，通常情况下需要根据自己具体的实际需要来选择，比如：\n\n+ 只考虑Path，Circle等矢量路径：使用SwiftSVG、Macaw即可\n+ 考虑和Android复用：使用VectorDrawable\n+ 不考虑iOS 13以下兼容：优先用Symbol Image和CoreSVG\n+ 考虑SVG动画：Macaw\n+ 面向未来：SVG-Native\n\n## 参考资料\n\n+ [解读 WWDC19 - SF Symbols 内置图标库](https://swiftcafe.io/post/sf-symbol)\n+ [SF Symbols: The benefits and how to use them guide](https://www.avanderlee.com/swift/sf-symbols-guide/)\n+ [SVG: Scalable Vector Graphics](https://developer.mozilla.org/en-US/docs/Web/SVG)\n+ [SDWebImageSVGCoder](https://github.com/SDWebImage/SDWebImageSVGCoder)\n+ [Vector drawables overview](https://developer.android.com/guide/topics/graphics/vector-drawable-resources)\n+ [Introducing Cyborg, an Open Source iOS Implementation of Android VectorDrawable](https://eng.uber.com/cyborg/)\n+ [OpenType-SVG color fonts](https://helpx.adobe.com/fonts/using/ot-svg-color-fonts.html)\n+ [SVG Native: Open Sourcing SVG Native Viewer](https://medium.com/adobetech/svg-native-open-sourcing-svg-native-viewer-988125328a07)","categories":["iOS"],"tags":["iOS","Swift","Image","SVG"]},{"title":"iOS逆向&iOS字体Fallback&游戏汉化","url":"/2016/06/05/iOS%E9%80%86%E5%90%91-iOS%E5%AD%97%E4%BD%93Fallback-%E6%B8%B8%E6%88%8F%E6%B1%89%E5%8C%96/","content":"\n> 最近偶然间发现《命运石之门：线形拘束的表征图》(STEINS;GATE 线形拘束のフェノグラム)iOS版的汉化基本完成，只缺测试，于是加入帮忙汉化组……在这中间偶然间学到一些关于iOS逆向和字体相关内容\n\n# 字体问题\n\n游戏是基于iOS UIKit以及Cocos游戏引擎写的（动画效果是Cocos的，文本框是定制的UITextField，而Backlog就是个UIScrollView……）本身支持UTF-8，覆盖汉化脚本后运行，却发现字体渲染不正常，出现了两种字体渲染（看图，\"喵\"明显是黑体-简，即iOS9之前默认的简体中文字体），更会有很多汉字变为日文汉字（\"变\" -> \"変\"，\"归\" -> \"帰\")\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/8/2e/d2b034dd2baab3fa03776f8ec9988.jpg)\n\n起初并没有理解问题，最后查资料才认识到这是iOS字体Fallback所导致的。在查阅资料时候也发现一个异常好用的iOS字体对比渲染网页：[iosfonts](http://iosfonts.com)，直接输入文字，即可查看各种当前固件各种font family的效果（最好用Safari访问，OS X访问的话，相当于查看当前OS X的font family）\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/1/c5/a3c3555692a29541f2a45c8799323.png)\n\n经过对比以及反编译搜索，发现渲染正常的是HiraKakuProN-W6，而其它字体会被Fallback到STHeitiSC-Light(黑体-简,细体)，原因自然的，因为HiraKakuProN并不是中文字体，只是支持部分日文汉字的显示，剩下的中文汉字将被Fallback（这是iOS UIKit的自动处理，不会出现[?][?]这种空白字块的效果）（这一些列支持中文的字体也有，就是大名鼎鼎的冬青黑体(Hiragino Sans)，在iOS 9和OS X 10.10.6之后加入）\n\n同时，做过iOS国际化的也知道，在iOS Bundle的info.pilst里面，有一个键`CFBundleDevelopmentRegion`，这个键将决定所有文字默认字体，假如你设置为\"en\"，那么所有英文文字都将Fallback到Helvetica Light(iOS 9之后为San Francisco)，而不是黑体-简的英文字体（参考：[iOS Developer Library](https://developer.apple.com/library/ios/documentation/General/Reference/InfoPlistKeyReference/Articles/CoreFoundationKeys.html#//apple_ref/doc/uid/20001431-130430)）\n\n所以汉化的时候，我们最好确认该值设置为`zh_CN`（大部分日文游戏会是`ja_JP`），防止未手动设置的字体Fallback到日文字体\n\n这样的话，我们的目标就是逆向把字体设置为黑体-简了。\n\n# 逆向\n\niOS逆向入门，大家可以参考[Reverse Engineering iOS Apps](https://www.whitehack.com.au/reverse-engineering-ios-apps/)，讲述了关于各种类型的逆向，命令行工具，Hopper Disassembler（最好的iOS(ARM)/OS X(x86)逆向工具，支持反编译Objective-C伪代码），同时，[GitHub](https://github.com/iosre/iOSAppReverseEngineering)上有个非常好的电子书，对逆向入门很有帮助。\n\n我们的目标，自然是想办法替换字体名，大家应该都知道，二进制的Hex值你可以替换部分为0x00来无效化，但绝不能随便中间添加插入。因为一旦加入或者删除Hex，后续所有的地址跳转都将挂掉……\n\n通过Hopper静态分析，能发现游戏将我们想要替换的字体名`HiraKakuProN-W6`写死到一个const NSString中去（实际上，Objective-C会编译为`_CFConstantStringClassReference`），遗憾的是，`STHeitiSC-Medium`是16个Byte，而前者只有15个Byte，意味着暴力Hex替换是不可能的。\n\n那么，就没有办法了吗？不是的，就以我不懂逆向来看，也知道至少有两种办法：\n\n### 调用过程前插入指令\n对所有引用这个常量地址的过程，手动插入ARM汇编指令，暴力将目标字符串放入寄存器。同时，在调用外过程的时候，把这个寄存器传进去，相当于动态创建了新的字符串并传参……\n\n对于ARM汇编来说，与8086汇编最大的差距就是ARM指令是三地址码(`mov r0,#0x00`)，而且旧版iOS SDK编译的的Mach-O文件更是包含了ARM32(32位指令)和ARM Thumb(16位指令)，需要单独区别。不过熟悉的pc寄存器还是在的，比如这就是进入和函数返回的指令\n\n```nasm\npush { r4, r5, r6, r7, lr }\npop { r4, r5, r6, r7, pc }\n```\n\n当然，真要做逆向工程师，需要学习大量ARM汇编知识，对我这种基本不懂的人，一般也不会采取这种方式。\n\n### 修改常量段和地址引用\n想办法把常量段(__DATA)前面不需要的常量（一般是一些Log的字符串之类）字串缩减，同时对后续所有引用的地址全部修改(减去缩短的字节数)，这样就有了更多空间来修改目标字串。\n\n当然，对于我这种不懂的人，还是选择2方法更好……\n\n通过Hopper全局搜索，发现一个地址为0x002fc50的字串\"Not interleaved!\"，再通过地址引用，找到调用过程，用伪代码分析一看，是用来做Log的，没有意义，决定用它开刀。\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/d/a6/20b6c740e08b4ce50c7726931039d.png)\n\n既然我们目标是把16Byte替换15Byte，那么只需要删除一个Byte(也就选\"!\")了，之后，把从该地址开始，到目标地址的所有地址配合Hex Editor，把所有字符串向前一个Byte，然后更新这些常量的被引用地址值（这步骤手工很麻烦，幸好Hopper支持脚本，大工程可以脚本跑）\n\n替换修改后的常量段：\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/f/b8/2fd8b75defcd753005347e05e3994.png)\n\n检查没问题，导出可执行文件，测试，结果非常满意，全部被替换为黑体-简(粗体)，相关功能也不受影响（真要说影响，可能就是用户看不到的控制台的Log会输出少个\"!\"罢了2333）\n\n最终成果（漂亮的黑体-简)：\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/5/6b/ba2950239095f36f16e57cd593b21.jpg)\n\n# 感想\n\n从中，也可以看出iOS开发的时候，对于常量值，比如一些密码，Key之类的，任何静态分析工具都能轻易找到，并且替换。因此，对敏感的信息，一定要做好相应的安全反逆向。\n\n单纯的宏定义，虽然编译后会展开，但是还是会有一个随机分配标签的常量存在，也容易通过长度和相关函数签名（比如encrypt，key之类名称）的传入参数发现。简单处理，可以加密函数起名A_Function，通过宏定义`#define A_Function ENCRYPT_FUN`，这样将不会反编译后将不会知道标签，更进一步可以通过宏定义直接封装加密函数和解密函数，减少静态分析工具发现的可能性。\n\n不过对于动态分析工具以及Hook系统调用来说，这些都是没有用的……归根结底还是建议要确保iOS客户端，尽量少保留敏感信息，对服务端API设置Auth，SSL验证等手段，才能减少被逆向者获取信息的可能性。\n\n好了，也扯完了，愉快地去(tui)测(you)试(xi)《命运石之门：线形拘束的表征图》了……这作品是《命运石之门》的剧情补完和外传，而妄想科学ADV系列基本一直是我的最爱，大家有兴趣可以去[贴吧](http://tieba.baidu.com/p/4260615784)关注进度。\n\n*El psy congroo*\n","categories":["iOS"],"tags":["iOS","逆向","Game"]},{"title":"一步步带你开发macOS QuickLook Plugin","url":"/2019/04/16/%E4%B8%80%E6%AD%A5%E6%AD%A5%E5%B8%A6%E4%BD%A0%E5%BC%80%E5%8F%91macOS-QuickLook-Plugin/","content":"\n## QuickLook简介\n\nQuickLook 是macOS上提供的一项快速展示文档预览的功能，只需要按下空格就可以快速查看各种文件格式的信息，包括文本，代码，图片，音频，视频等等。\n\n由于QuickLook需要支持不断扩展的文件格式，因此macOS专门提供了一个QuickLook Plugin，能让开发者对自己的文件格式提供一个自定义的完整的UI显示，不必依赖macOS系统更新来支持缤纷复杂的格式。\n\n之前一段时间，出于兴趣做了一个[AVIF (AV1 Image File Format)](https://aomediacodec.github.io/av1-avif/)的解码器封装，AV1作为现在流行的HEVC(H.265)潜在未来竞争者，有着开源，无专利限制，更高的压缩比等等优势，比起HEVC晚诞生了5年。\n\n目前AVIF虽然发布了第一版规范，但是缺少相应的周边工具链的支持，在macOS上想要找一个简单的Image Viewer都没找到，调试起来异常困难，因此抽空顺便做了一个简单的Quick Look Plugin，来让自己能直接空格预览AVIF图像。\n\n在做QuickLook Plugin的过程中，感觉有一些小坑需要记下来，因此这篇文章，目标就是一个简单的入门教程，讲解如何做一个QuickLook Plugin，来对自己喜爱但又不被系统支持的文件格式，提供更好的用户体验支持。\n\n## QuickLook Plugin工程\n\n虽然苹果提供了完善的QuickLook Plugin开发文档，参考：[Quick Look Programming Guide](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/Quicklook_Programming_Guide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40005020-CH1-SW1)\n\n但是文档已经稍显过时，遇到的一个坑点也没有提示，因此这里更详细直观的介绍一下QuickLook开发的流程。\n\n\n+ 新建Xcode工程，选择这个`Quick Look Plug-In`模板\n\n![屏幕快照 2019-04-16 上午11.45.25](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/2019/04/16/屏幕快照 2019-04-16 上午11.45.25.png)\n\n\n+ 打开你的模版，你会发现如下的结构\n\n```\nProject\n- GenerateThumbnailForURL.c // 用来提供Finder缩略图的代码\n- GeneratePreviewForURL.c // 用来生成Preview用的绘制代码\n- main.c // 插件入口文件，不要修改它\n- Info.plist // 描述插件支持的UTI类型的，后面会讲\n```\n\nQuickLook Plugin支持两种情形的功能展示：一个是对文件，按下空格来展示的窗口预览，在使用Option+空格进行全屏预览时候也会展示，后面都称作Preview\n\n另一个是用来给Finder，来提供一个缩略图展示，这样一些图像格式，视频格式，在Finder中就能直接看到对应的缩略图，而不是一个僵硬的默认图标。后文都称作Thumbnail\n\n由于QuickLook的核心，是希望对**指定的文件格式**，提供一个展示的UI和缩略图。那么在继续进一步写代码之前，我们必须得首先清楚自己需要的文件格式是什么，并了解UTI的概念。如果这一步骤处理的有问题，你的QuickLook Plugin是无法按预期的想法，被调用的。\n\n## 绑定文件格式和UTI\n\n在继续下一步之前，你需要对你想支持的文件格式，选择一个UTI ([Uniform Type Identifiers](https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/understanding_utis/understand_utis_intro/understand_utis_intro.html#//apple_ref/doc/uid/TP40001319)).\n\nQuickLook，在用户按下空格开始Preview的时候，会根据每个QuickLook Plugin注册的UTI，依次去询问，直到找到第一个返回成功的，最后来判定选择哪个Plugin进行展示。\n\n建立好模版之后，打开`Info.plist`，在顶层的`LSItemContentTypes`项里面，添加你的Plugin所能支持的UTI，是一个数组，会按照先后顺序匹配，一般建议只写自己能准确识别的UTI，如果是一个通配的Plugin（如通用图片预览，通用代码预览），可以使用UTI继承关系的父级(`public.image`, `public.source-code`等）\n\n```xml\n<key>CFBundleDocumentTypes</key>\n<array>\n\t<dict>\n\t\t<key>CFBundleTypeRole</key>\n\t\t<string>QLGenerator</string>\n\t\t<key>LSItemContentTypes</key>\n\t\t<array>\n\t\t\t<string>public.avif</string> <!--Here!-->\n\t\t</array>\n\t</dict>\n</array>\n```\n\n在配置好Plugin支持的UTI之后，你还需要根据具体UTI的分配来源，来使用导入或者导出。\n\n### 找出已有的UTI\n\n你可以通过使用如下命令，查看一个文件对应的UTL\n\n```\nmdls test.avif\n```\n\n查看输出的`kMDItemContentType`，如果是以`dyn`开头，表明没有被注册过，而是系统分配的一个动态UTI（用于任意不支持的类型和代码兼容，参考[Dynamic Type Identifiers](https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/understanding_utis/understand_utis_conc/understand_utis_conc.html#//apple_ref/doc/uid/TP40001319-CH202-BCGCDHIJ)）\n\n否则，形如`public.png`这种，标示是一个已有的UTI，可以导入来直接使用\n\n```\nkMDItemContentType =\"dyn.ah62d4rv4ge80c7xmq2\"\n```\n\n如果你是一个比较执着的人，想了解具体的每一个UTI，是由系统或者还是某个第三方App注册的，你可以使用如下命令，导出完整的系统UTI报表，来进行搜索。\n\n```\n/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/LaunchServices.framework/Versions/A/Support/lsregister -dump\n```\n\n### UTI定义\n\n一个UTI对应一段XML的定义，其中声明了它的类型（继承关系），UTI字符串，简介名称，扩展名，标准链接等等，基本的格式如下，很容易理解。这里是自己定义的一个AVIF格式的描述\n\n```xml\n<dict>\n    <key>UTTypeConformsTo</key>\n    <array>\n        <string>public.image</string>\n    </array>\n    <key>UTTypeDescription</key>\n    <string>AVIF image</string>\n    <key>UTTypeIdentifier</key>\n    <string>public.avif</string>\n    <key>UTTypeReferenceURL</key>\n    <string>https://aomediacodec.github.io/av1-avif/</string>\n    <key>UTTypeTagSpecification</key>\n    <dict>\n        <key>public.filename-extension</key>\n        <array>\n            <string>avif</string>\n        </array>\n        <key>public.mime-type</key>\n        <string>image/avif</string>\n    </dict>\n</dict>\n```\n\n### 导入UTI\n\n如果你想支持QuickLook的文件格式，已经有了系统分配的UTI，或者第三方App定义好的UTI，那么你要做的，就是导入一个UTI。\n\n如果要导入UTI，你需要在`Info.plist`中，使用`UTImportedTypeDeclarations`这个项，来导入对应的UTI描述内容，值是一个数组，数组每项都是上面提到的UTI定义。\n\nPS：对于导入UTI来说，你其实并不需要完整的把别人的声明抄过来，只要存在`UTTypeIdentifier`项即可，但是这样写能更清晰了解对应的格式描述。\n\n```xml\n<key>UTImportedTypeDeclarations</key>\n<array>\n    <dict>\n    \t<key>UTTypeIdentifier</key>\n    \t<string>public.png</string>\n    \t<!--...-->\n    </dict>\n</array>\n```\n\n### 导出UTI\n\n反之，如果你想支持的QuickLook的文件格式，不存在已有的UTI，那么你需要新增一个并导出。\n\n如果要导出UTI，你需要在`Info.plist`中，使用`UTExportedTypeDeclarations`这个项，来导出对应的UTI描述内容，值是一个数组，数组每项都是上面提到的UTI定义。\n\n```xml\n<key>UTExportedTypeDeclarations</key>\n<array>\n    <dict>\n    \t<key>UTTypeIdentifier</key>\n    \t<string>public.avif</string>\n    \t<!--...-->\n    </dict>\n</array>\n```\n\n### QuickLook Plugin和导出UTI\n\n值得注意的一个坑点，macOS系统注册UTI规则，会注册当前硬盘上所有的`.app`后缀的App包，里面所含有的导出UTI，而遗憾的是，作为QuickLook Plugin，最后编译得到的产物，不是以`.app`为后缀名的，而是一个`.qlgenerator`。\n\n因此，这就导致，如果你新增了一个UTI，但是你的QuickLook Plugin，没有任何宿主App来提供导出UTI，最终macOS会不认这个UTI，因此你的QuickLook Plugin不会被调用。这可能是苹果早期认为，QuickLook Plugin是和一个App绑定的（如Keynote和Keynote QuickLook插件的关系），独立存在的QuickLook Plugin并没有特别处理……\n\n这个坑花费了一些时间，经过一番StackOverflow和GitHub搜索，最终找到了一个非常聪明（Trick）的解决方案：\n\n构造一个临时占位的`Dummy.app`包，专门用于导出UTI，在打包的时候直接将这个`Dummy.app`拷贝到对应QuickLook Plugin的包中即可\n\n我们可以使用macOS自带的`Script Editor.app`，来创建一个空壳App：\n\n1. 打开`Script Editor`，创建一个新文档\n2. 直接Save，类型选择`Application`，名称随便写一个`Dummy.app`，导出\n3. 用文本编辑器，打开`Dummy.app/Contents/Info.plist`\n4. 参考上文提到的UTI导出方式，添加对应的`UTExportedTypeDeclarations`项目\n5. 将这个`Dummy.app`，放到工程下，直接拖进来当作资源，添加到`Copy Bundle Resource`过程中\n\n\n![未命名3](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/2019/04/16/未命名3.png)\n\n这样一波操作以后，你最后构建得到的QuickLook Plugin，就能自带一个导出的UTI，然后被系统识别，最终被真正加载。\n\n\n## 用于Preview的代码绘制实现\n\n准备好上述UTI的配置后，现在再来看看代码。首先我们侧重看一下用于提供Preview的UI的代码。\n\n对应的文件是`GeneratePreviewForURL.c`。如果要使用Objective-C，或者C++代码，你可以更改对应的文件名为`.m`或者`.cpp`即可，以下示例是以Objective-C代码为主\n\n入口调用函数原型为下：\n\n```c\nGeneratePreviewForURL(void *thisInterface, QLPreviewRequestRef preview, CFURLRef url, CFStringRef contentTypeUTI, CFDictionaryRef options)\n```\n\n其实对于大多数QuickLook插件，我们关注的基本上只有这个`url`参数，他对应的是文件的File URL，可以拿到对应被选中的文件Data Buffer。\n\n```objectivec\nNSString *path = [(__bridge NSURL *)url path];\nNSData *data = [NSData dataWithContentsOfFile:path];\n```\n\n下一步就是绘制和渲染我们的UI，QuickLook支持两种方式渲染：\n\n+ 使用Core Graphics自定义绘制\n+ 使用预置支持的数据格式，动态生成Data\n\n### 使用Core Graphics绘制\n\n这里假设已经了解Core Graphics绘制的基本知识，如果有不了解请提前查阅苹果的教程：[Quartz 2D Programming Guide](https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Introduction/Introduction.html).\n\n在拿到Data以后，该怎么绘制取决于你的QuickLook插件的功能，比如说，我想做的一个AVIF图像预览Quick Look插件，那么就希望触发解码，以拿到CGImage和Bitmap Buffer来绘制。\n\n```objectivec\nCGImageRef cgImgRef = [AVIFDecoder createAVIFImageWithData:data];\n```\n\n下一步，我们需要获取一个CGContext来绘制，使用[QLPreviewRequestCreateContext](https://developer.apple.com/documentation/quicklook/1402613-qlpreviewrequestcreatecontext?language=objc)，传入入口函数透传进来的`preview`，会得到一个CGContext，来作为上下文进行绘制。同时，还需要了解绘制的大小，标题等等选项，来提供合适的渲染UI。\n\n```objectivec\nCGFloat width = CGImageGetWidth(cgImgRef);\nCGFloat height = CGImageGetHeight(cgImgRef);\n\n// Add image dimensions to title\nNSString *newTitle = [NSString stringWithFormat:@\"%@ (%d x %d)\", [path lastPathComponent], (int)width, (int)height];\n    \nNSDictionary *newOpt = @{(NSString *)kQLPreviewPropertyDisplayNameKey : newTitle,\n    (NSString *)kQLPreviewPropertyWidthKey : @(width),\n    (NSString *)kQLPreviewPropertyHeightKey : @(height)};\n\n// Draw image\nCGContextRef ctx = QLPreviewRequestCreateContext(preview, CGSizeMake(width, height), YES, NULL);\nCGContextDrawImage(ctx, CGRectMake(0,0,width,height), cgImgRef);\nQLPreviewRequestFlushContext(preview, ctx);\n\n// Cleanup\nCGImageRelease(cgImgRef);\nCGContextRelease(ctx);\n```\n\n这样基本就完成了，我们绘制了一个完整的图像到CGContext上，QuickLook会渲染到屏幕上，大小是我们指定的图像大小。\n\n![](https://raw.githubusercontent.com/dreampiggy/AVIFQuickLook/master/Screenshot/Preview.png)\n\n如果你的QuickLook插件，需要有一个异步的处理和等待，同时可以实现这个取消的入口函数，来减少CPU占用，优化一下用户体验\n\n```\nvoid CancelPreviewGeneration(void *thisInterface, QLPreviewRequestRef preview)\n```\n\n比如说，对于大图像解吗，可以中断解码提前释放内存。\n\n### 使用预置类型生成数据渲染\n\nQuickLook Preview还有另一种渲染方式，就是使用QuickLook预置的文件类型支持，来提供相应的数据。对应文档：[Dynamically Generating Previews](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/Quicklook_Programming_Guide/Articles/QLDynamicGeneration.html#//apple_ref/doc/uid/TP40005020-CH15-SW5)\n\n\n我们需要使用[QLPreviewRequestSetDataRepresentation](https://developer.apple.com/documentation/quicklook/1402661-qlpreviewrequestsetdatarepresent?language=objc)，来提供一个预置支持格式的Data Buffer给QuickLook。\n\n支持的格式有：\n\n+ Image: 系统Image/IO解码库支持的图像压缩格式\n+ PDF：PDF数据\n+ HTML：WebKit支持的HTML字符串，注意如果有本地的CSS，需要使用`kQLPreviewPropertyAttachmentDataKey`带上CSS的数据\n+ XML：WebKit支持的XML字符串\n+ RTF：macOS支持的富文本格式（NSAttributedString可以转换的到）\n+ Text：纯文本字符串\n+ Movie：系统CoreVideo库支持的视频压缩格式\n+ Audio：系统CoreAudio库支持的音频压缩格式\n\n```objectivec\nNSImage *image;\nNSData *imageData = [image TIFFRepresentation];\nQLPreviewRequestSetDataRepresentation(preview, (__bridge CFDataRef)data, kUTTypeImage, NULL);\n```\n\n### 在其他App中使用Preview\n\n值得一提的是，得益于macOS完整的软件生态，你的QuickLook Plugin的Preview UI，不仅仅会出现在Finder中空格弹出的预览，甚至于Xcode和一些第三方App内置的预览（即用到了[QLPreviewPanel](https://developer.apple.com/documentation/quartz/qlpreviewpanel)来展示UI的地方），都能触发你的插件，所以可以说是非常舒服。\n\n在Xcode中缩略图如下：\n\n![屏幕快照 2019-04-16 下午1.49.04](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/2019/04/16/屏幕快照 2019-04-16 下午1.49.04.png)\n\n## 用于Thumbnail的代码绘制实现\n\n说完了关于Preview的实现代码，现在再来看看关于如何生成Finder用到的文件缩略图\n\nThumbnail也支持两种模式\n\n1. 使用同Preview的，基于Core Graphics绘制逻辑\n2. 更为简单的API，使用CGImage或者Image Data\n\n第一种方式，和上文一模一样，这里就不再赘述了。我们可以看看第二种方式。我们只需要提供一个CGImage，或者一个Image/IO支持的图像格式的Image Data即可\n\n```objectivec\n// 如果是原生支持的格式，使用QLThumbnailRequestSetImageWithData\n\n// 否则，自己解码器输出一个CGImage，然后传进去\nCGImageRef cgImgRef;\nif (cgImgRef) {\n    QLThumbnailRequestSetImage(thumbnail, cgImgRef, nil);\n    CGImageRelease(cgImgRef);\n} else {\n    QLThumbnailRequestSetImageAtURL(thumbnail, url, nil);\n}\n```\n\n对应在Finder中缩略图如下：\n\n![](https://raw.githubusercontent.com/dreampiggy/AVIFQuickLook/master/Screenshot/Thumbnails.png)\n\n\n## 调试QuickLook插件\n\n作为一个插件，要调试起来比起一般的App要麻烦一些。不过好在macOS提供了一个专门的QuickLook调试命令，苹果也有专门文档介绍\n\n我们可以使用如下的命令，以`public.avif`的UTI，对`test.avif`文件，触发一次Quick Look的Preview，来查看渲染是否正确。\n\n```\nqlmanage -d2 -p test.avif -c public.avif\n```\n\n同时，为了能够Debug单步调试，我们使用Xcode的Debug Scheme，通过将`Execulable`改成`/usr/bin/qlmanage`，在Arguments中填写成上述的参数。\n\n![未命名](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/2019/04/16/未命名.png)\n\n![未命名2](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/2019/04/16/未命名2.png)\n\n这样，你可以给你的对应代码下上断点，当你再次点击Run来运行时，会自动触发单步调试，检查存在的问题。\n\n## 总结\n\n整体看下来，QuickLook Plugin的开发流程并没有多么复杂，其实你要做的就是用已有的Core Graphics绘制知识，并不涉及到AppKit相关概念，对于iOS开发者也能快速上手。\n\n其中的坑，主要在于没有文档说明新增UTI，需要绑定一个App，而不是QuickLook Plugin本身能够声明的，对应也介绍了一个聪明的方式绕过这一限制。希望能帮助到有同样需求的人。\n\n自己的AVIF QuickLook Plugin也终于完工，欢迎有兴趣的人尝试，并且给一点Star：\n\n+ [AVIFQuickLook](https://github.com/dreampiggy/AVIFQuickLook)：预览AVIF图像\n\n这里还有一些推荐和自己用到的QuickLook Plugin，也列举出来，能大大提升日常使用效率哦\n\n+ [qlImageSize](https://github.com/Nyx0uf/qlImageSize)：预览WebP和BPG图像，显示图像元信息\n+ [qlmarkdown](https://github.com/toland/qlmarkdown)：预览Markdown\n+ [ProvisionQL](https://github.com/ealeksandrov/ProvisionQL)：预览ipa包，以及mobileprovision证书信息\n\n","tags":["macOS","QuickLook","AVIF"]},{"title":"一段简单逆向之旅-绕开Xcode 13.3最低macOS 12.0限制","url":"/2022/03/25/%E4%B8%80%E6%AE%B5%E7%AE%80%E5%8D%95%E9%80%86%E5%90%91%E4%B9%8B%E6%97%85-%E7%BB%95%E5%BC%80Xcode-13-3%E6%9C%80%E4%BD%8EmacOS-12-0%E9%99%90%E5%88%B6/","content":"\n> 因为众所周知的原因，苹果的Xcode版本会不断提高自己的最低安装版本，在Xcode 13.0-13.2.1上，这个最低安装版本是macOS 11\n>\n> 而随着Xcode 13.3正式版放出，这个最低部署版本在最后关头被提升到了macOS 12\n\n# Why？\n\n一般来说，各位开发者或者众多基建，总有各种各样的原因需要暂时留在老版本的macOS系统上，但是又希望使用新Xcode版本自带的Toolchain进行一些工作开发调试，有些是主观问题，有些是客观限制：\n\n举例子：\n\n1. macOS 12禁止了`sudo /usr/libexec/ApplicationFirewall/socketfilterfw --setglobalstate off`绕过GUI配置，导致一些公司采取Apple Device Management管理的电脑，无法正常关闭TCP拦截，会导致一些服务异常\n2. macOS 12加强了Kernel Extension的安全性，导致GitHub Action和Circle CI截止2022年3月底，迟迟无法更新他们的虚拟化集群到macOS 12，只有11.6的最新版本\n\n这些都是闲聊，进入正题。那么有没有办法能够绕开，或者从原理上来讲，是否这个系统绑定的最低部署版本限制是必要的？\n\n# 先放结论\n\n1. 可以绕过这个macOS 12的最低安装版本限制运行\n2. 这个限制是非必要的，绕过以后所有功能正常可用（构建，独立工具集，调试，连接iPhone）\n\n下面来说明具体的逆向流程，和进行绕过的简单Step-by-step手法\n\n# 安装Xcode\n\n先说明测试机器Mac环境和Xcode环境：\n\n1. macOS 11.4 (20F71)\n2. Xcode Version 13.2 (13C90)：需要保留一份以防万一\n3. Xcode Version 13.3 (13E113)：目标安装的版本\n\n首先，作为iOS/macOS开发者，我们肯定会使用dmg的格式，或者使用[Xcodes.app](https://github.com/RobotsAndPencils/xcodes)来安装我们的Xcode 13.3了（App Store安装Xcode曾经出的坑：[App Store version of Xcode 13.2 causing problems for developers](https://appleinsider.com/articles/21/12/14/app-store-version-of-xcode-132-causing-problems-for-developers)，我是不会再用了）\n\n安装完毕后，我们在Finder中看到的Xcode.app是一个画着❎的样子，直接打开会提示如下：\n\n![1648210752406_af87e2021743b9639d35f86714f127c7](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-03-25/image/1648210752406_af87e2021743b9639d35f86714f127c7.png)\n\n\n# 绕过GUI部分的限制\n\n## 修改`LSMinimumSystemVersion`\n\n作为iOS/macOS开发者，我们第一想到的就是，是否是Xcode.app对应的Info.plist中，设置了和最低部署版本相关的字段导致拒绝载入呢？\n\n我们用另一个Xcode（或者plistutil）打开`Xcode.app/Contents/Info.plist`，果然发现了对应的字段：\n\n![1648210752770_b314e1b23bdd01fe803ede1383e29491](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-03-25/image/1648210752770_b314e1b23bdd01fe803ede1383e29491.png)\n\n这个[LSMinimumSystemVersion](https://developer.apple.com/documentation/bundleresources/information_property_list/lsminimumsystemversion)是Mac应用标准的声明最低部署版本的方式，修改为你的机器当前OS版本之后保存，执行\n\n```\ntouch /Applications/Xcode-13.3.0.app\nkillall Finder\n```\n\n重新尝试双击。不错，这次我们打开了，初看起来不错（直到我们正式开始编译）！\n\n![1648210752322_3d4e9ae78eaab94de9cfc7d1f8eaecf0](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-03-25/image/1648210752322_3d4e9ae78eaab94de9cfc7d1f8eaecf0.png)\n\n\n# 绕过CLI部分的限制\n\n## 神奇的xcrun\n\n但是只要创建一下工程并执行编译，就会发现，各种命令行工具的调用是有问题的，比如我们先通过xcode-select设置为当前的Xcode 13.2，尝试执行：\n\n![1648210752844_f21e111a081ff5dfc61dab7137109a39](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-03-25/image/1648210752844_f21e111a081ff5dfc61dab7137109a39.png)\n![1648210752266_e83287242af496cbbec7817b4b60f9f0](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-03-25/image/1648210752266_e83287242af496cbbec7817b4b60f9f0.png)\n\n但是我们如果直接找到，执行对应绝对路径的clang，是可以执行的\n\n![1648210752227_fd8cd9f89407475fe62c0489dc61a232](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-03-25/image/1648210752227_fd8cd9f89407475fe62c0489dc61a232.png)\n\n并且，我们可以直接检查clang这个二进制，是否链接时设置了target，这部分可以使用otool -l读取machO Header查看到：\n\n![1648210752133_02c1257232efb1e2adebcb51ea25ceb0](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-03-25/image/1648210752133_02c1257232efb1e2adebcb51ea25ceb0.png)\n\n好，最低部署版本是macOS 10.14.6；那现在我们有充分的证据说明，一定可以在我当前的电脑运行clang，而上述提示应该是xcrun这个调度器，添加了额外的判断。\n\n通过搜索关键词，可以在Xcode的strings输出中找到这句“Executable requires at least”的关键字：参考仓库：[Xcode.app-strings](https://github.com/keith/Xcode.app-strings/blob/11e15fd3cd8446f2a966746caefcef5beebc8929/Xcode.app/Contents/Frameworks/libxcodebuildLoader.dylib)\n\n## 反编译`libxcodebuildLoader`\n\n我们定位到这个`libxcodebuildLoader.dylib`，拖进Hopper尝试反编译理解他检查的原理\b，伪代码如下：\n\n```c\nvoid _checkMinimumOSVersion(int arg0) {\n    var_2C = 0x0;\n    rbx = 0x0;\n    rax = _NSGetExecutablePath(0x0, &var_2C);\n    rdi = var_2C;\n    if (rdi != 0x0) {\n            rbx = malloc(rdi);\n    }\n    rax = _NSGetExecutablePath(rbx, &var_2C);\n    if (rax != 0x0) goto loc_282c;\n\nloc_26fc:\n    rax = [NSString stringWithUTF8String:rbx];\n    rax = [rax retain];\n    r14 = rax;\n    r15 = [[NSURL fileURLWithPath:rax] retain];\n    if (rbx != 0x0) {\n            free(rbx);\n    }\n    rbx = CFBundleCopyInfoDictionaryForURL(r15);\n    CFRelease(r15);\n    if (rbx == 0x0) goto loc_2867;\n\nloc_276a:\n    r13 = [CFDictionaryGetValue(rbx, @ DVTMinimumSystemVersion ) retain];\n    CFRelease(rbx);\n    if ((r13 == 0x0) || ([r13 length] == 0x0)) goto loc_280c;\n\nloc_27a6:\n    r12 = *_objc_msgSend;\n    r15 = [[DVTVersion versionWithStringValue:r13] retain];\n    rax = [DVTVersion currentSystemVersion];\n    rax = [rax retain];\n    rbx = r12;\n    r12 = rax;\n    rdx = r15;\n    if ([rax isEqualToOrNewerThanVersion:rdx] == 0x0) goto loc_288c;\n\nloc_27fb:\n    [r12 release];\n    [r15 release];\n    goto loc_280c;\n\nloc_280c:\n    [r13 release];\n    [r14 release];\n    return;\n\nloc_288c:\n    r15 = [(rbx)(r15, @selector(stringValue), rdx) retain];\n    rax = (rbx)(r12, @selector(stringValue), rdx);\n    rax = [rax retain];\n    r14 = [(rbx)(@class(NSString), @selector(stringWithFormat:), @ Executable requires at least macOS %@, but is being run on macOS %@, and so is exiting. , r15, rax) retain];\n    [rax release];\n    [r15 release];\n    fprintf(**___stderrp,  %s\\n , (rbx)(objc_retainAutorelease(r14), @selector(UTF8String), @ Executable requires at least macOS %@, but is being run on macOS %@, and so is exiting. ));\n    goto loc_292b;\n\nloc_292b:\n    exit(0x1);\n    return;\n\nloc_2867:\n    fwrite( Unable to open executable info dictionary; xcodebuild may be corrupt and should be reinstalled.\\n , 0x60, 0x1, **___stderrp);\n    goto loc_292b;\n\nloc_282c:\n    _DVTAssertionFailureHandler(*_self, *__cmd,  void checkMinimumOSVersion() ,  /Library/Caches/com.apple.xbs/Sources/IDETools/IDETools-20008/xcodebuildLoader/xcodebuildLoader.m , 0x69, @ 0 , @ Couldn't get executable path to self! );\n    return;\n}\n```\n\n好，阅读伪代码以及查阅资料可知：\n\n`xcrun`会先一步调用到`xcodebuild`，检查`DVTMinimumSystemVersion`这个变量的值是否和当前OS版本匹配。\n\n而这个变量，竟然是通过[CFBundleCopyInfoDictionaryForURL](https://developer.apple.com/documentation/corefoundation/1537134-cfbundlecopyinfodictionaryforurl)打开的。\n\n参考苹果的函数说明，它除了常规的打开一个.bundle的文件夹，解析为NSBundle.infoDictionary以外，竟然能打开存在于二进制`__TEXT,__info_plist`中的数据来解析为一个字典。所以我们接下来去找`xcodebuild`的二进制看看。\n\n![1648210752247_62087827de34d7b56eea1e48208b261e](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-03-25/image/1648210752247_62087827de34d7b56eea1e48208b261e.png)\n\n参考：\n\n1.  `_NSGetExecutablePath`：[函数说明](https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/dyld.3.html)，大概理解获取当前程序的可执行路径\n\n## 反编译`xcodebuild`\n\n同时，出于好奇，我们可以再把`xcodebuild`拖进Hopper去尝试理解，发现它整个程序竟然只有一个main函数，逻辑其实都在`libxcodebuildLoader.dylib`中\n\n```c\nvoid _main(int arg0, int arg1) {\n    r14 = arg1;\n    rbx = arg0;\n    rax = dlopen( @rpath/libxcodebuildLoader.dylib , 0x1);\n    if (rax == 0x0) goto loc_100002b7f;\n\nloc_100002b5c:\n    rax = dlsym(rax,  XcodeBuildMain );\n    if (rax == 0x0) goto loc_100002bd8;\n\nloc_100002b70:\n    (rax)(rbx, r14);\n    return;\n\nloc_100002bd8:\n    rax = dlerror();\n    rax = [NSString stringWithUTF8String:rax];\n    rax = [rax retain];\n    rax = objc_retainAutorelease(rax);\n    r15 = rax;\n    rax = [rax UTF8String];\n    rsi =  Error loading symbol: %s\\n ;\n    goto loc_100002c2f;\n\nloc_100002c2f:\n    fprintf(**___stderrp, rsi);\n    rbx = [_prunedErrorMessage() retain];\n    [r15 release];\n    if (rbx != 0x0) {\n            _main.cold.1(rbx, @selector(UTF8String));\n    }\n    return;\n\nloc_100002b7f:\n    rax = dlerror();\n    rax = [NSString stringWithUTF8String:rax];\n    rax = [rax retain];\n    rax = objc_retainAutorelease(rax);\n    r15 = rax;\n    rax = [rax UTF8String];\n    rsi =  Error loading required libraries. If there is an ongoing installation please wait for it to complete. Otherwise reinstall. (%s)\\n ;\n    goto loc_100002c2f;\n}\n```\n\n## 修改`DVTMinimumSystemVersion`\n\n其实大家也发现了，`xcodebuild`二进制本身竟然内嵌了一段XML！我使用`llvm-objdump`把它直接提取了出来：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n<key>BuildMachineOSBuild</key>\n<string>21E160</string>\n<key>CFBundleDevelopmentRegion</key>\n<string>English</string>\n<key>CFBundleDisplayName</key>\n<string>xcodebuild</string>\n<key>CFBundleIdentifier</key>\n<string>com.apple.dt.xcodebuild</string>\n<key>CFBundleInfoDictionaryVersion</key>\n<string>6.0</string>\n<key>CFBundleName</key>\n<string>xcodebuild</string>\n<key>CFBundleShortVersionString</key>\n<string>13.3</string>\n<key>CFBundleSupportedPlatforms</key>\n<array>\n<string>MacOSX</string>\n</array>\n<key>CFBundleVersion</key>\n<string>20008</string>\n<key>DTCompiler</key>\n<string>com.apple.compilers.llvm.clang.1_0</string>\n<key>DTPlatformBuild</key>\n<string>21E185d</string>\n<key>DTPlatformName</key>\n<string>macosx</string>\n<key>DTPlatformVersion</key>\n<string>12.3</string>\n<key>DTSDKBuild</key>\n<string>21E185d</string>\n<key>DTSDKName</key>\n<string>macosx12.3.internal</string>\n<key>DTXcode</key>\n<string>1330</string>\n<key>DTXcodeBuild</key>\n<string>13E112a</string>\n<key>DVTMinimumSystemVersion</key>\n<string>12.0</string>\n<key>LSMinimumSystemVersion</key>\n<string>11.0</string>\n</dict>\n</plist>\n```\n\n看到我们关心的`DVTMinimumSystemVersion`和`LSMinimumSystemVersion`都在里面。其实也侧面证明了，真正的最低部署版本是macOS 11.0，而不是macOS 12.0（12.0只是苹果为了间接Push Developer去频繁更新macOS的阴谋罢了😂）\n\n那下一步，要做的事情就是用魔改`xcodebuild`并重新codesign。修改的方式多种多样，你暴力使用Hex Editor也是最简单。但是我更好奇的是这个`__TEXT,__info_plist`的machO段和节的相关说明。\n\n在网上搜索了一下相关资料，很容易就找到了感兴趣的资料：\n\n1. [The Power Of Plist](https://redsweater.com/blog/2083/the-power-of-plist)：解释Info.plist可以内嵌在二进制中\n2. [Gimmedebugah: how to embedded a Info.plist into arbitrary binaries](https://reverse.put.as/2013/05/28/gimmedebugah-how-to-embedded-a-info-plist-into-arbitrary-binaries)：对任意已有二进制注入Info.plist\n3. [llvm-objcopy](https://llvm.org/docs/CommandGuide/llvm-objcopy.html)：拷贝修改machO结构到新machO\n\n基本解释得很明确清晰，如果你有源码，可以直接利用ld64的参数`  --sectcreate __TEXT,__info_plist path_to/Info.plist `来注入你的Info.plist信息。没有源码可以手动修改machO结构并签名即可。\n\n对于我此次跑Xcode 13.3来说，我选择最傻瓜最直观的Hex Editor修改（我用的是开源小工具[HexFiend](https://github.com/HexFiend/HexFiend)），只需要把`12.0`修改为`11.0`即可满足我的需要，并重新codesign一波。\n\n![1648210752222_811d0d800592f601f309e48b732f1194](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-03-25/image/1648210752222_811d0d800592f601f309e48b732f1194.png)\n\ncodesign：\n\n```\ncodesign --remove-signature /Applications/Xcode-13.3.0.app/Contents/Developer/usr/bin/xcodebuild\nsudo /Applications/Xcode-13.3.0.app/Contents/Developer/usr/bin/xcodebuild -license\n```\n\n测试一下CLI，很正常\n\n![1648210752374_0a5d6ef92b0e270d6164a05153565572](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-03-25/image/1648210752374_0a5d6ef92b0e270d6164a05153565572.png)\n\n# 最终替换步骤\n\n1. 修改`Xcode-13.3.0.app/Contents/Info.plist`中的`LSMinimumSystemVersion`的值为`11.0`\n2. 替换`Xcode-13.3.0.app/Contents/Developer/usr/bin/xcodebuild`中的`DVTMinimumSystemVersion`的二进制为`11.0`，或者使用我这个已经替换好的（建议还是手动参考上面步骤[修改DVTMinimumSystemVersion]替换，授人以渔而不是授人以鱼）","tags":["Xcode","逆向","macOS"]},{"title":"个人笔记-《并发编程》","url":"/2016/03/30/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0-%E3%80%8A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%8B/","content":"\n1.  线程和锁\n    \n    *   线程锁的的问题:\n    \n    > 时序问题\n    > \n    > 原子操作问题(Java内存读写机制->读.改.写)\n    > \n    > 竞态条件(操作取决于线程执行的先后顺序)\n    > \n    > JVM优化导致的问题（编译器静态优化，JVM动态优化，硬件指令的乱序执行）\n    > \n    > 两把锁：死锁问题\n    > \n    > 外部方法或者对象的线程安全问题\n    > \n    > 效率问题synchronized()\n    > \n    > ThreadLocal额外讲解，线程级别的局部变量，适用于数据库连接，网络请求\n    \n    *   使用concurrency\n    \n    > ReetrantLock的手动加锁解锁\n    > \n    > 死锁也能中断(不推荐的方式lockInterruptibly())\n    > \n    > tryLock()虽然能设定超时自动解锁，但是缺点明显：活锁（同时死锁再同时超时）\n    > \n    > 条件锁：Condition类\n    > \n    > 原子操作：Atomic 简单的解决方法，坑和缺点\n    > \n    > 线程池 内置的Exeutors.newFixedThreadPool()\n\n2.  函数式方法\n    \n    *   变量与可变状态导致的并发难题的终极解决方法->去掉变量\n    \n    > 函数式基础概念：顺序无关 map reduce 无穷序列和惰性求值 尾递归\n    > \n    > Clojure简单方法：pmap\n    > \n    > 两种Clojure并发模型：Future(给定一个函数在新线程跑，返回一个future对象) Promise（立即返回，惰性，调用deliver才会执行）\n    > \n    > 原子变量(atom)，代理(deref @)，由引用(ref)构成的软件事务内存(STM)。对任何多个并发事务进行修改发生冲突，将会导致重试\n\n3.  actor的魔力（略）\n    \n    *   纯粹的消息式的交流，几乎没有限制的进程数，随时加入和进行任务，任由错误发生，集中处理\n    \n    > actor：真正的消息传递，轻量级的进程开销\n    > \n    > 分布式map，每个进程分配子map","categories":["Code"],"tags":["笔记","并发"]},{"title":"个人笔记-《高级数据结构》","url":"/2016/03/30/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0-%E3%80%8A%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/","content":"\n# 内容\n\n1.  Why and how O(log n) access time?\n2.  Dynamic data structure and Analysis\n3.  Randomized Data Structure\n4.  Augmented Data Structure\n5.  Data Structures in Distributed Environments\n6.  Data Structures in Frontiers of Research\n7.  Exam\n\n* * *\n\n# 逆序对\n\n1.  随即序列 逆序对为 n(n-1)/4 \n    1.  证明:全逆序序列 ,如 5,4,3,2,1，则总计4+3+2+1，共Cn(2)个，即n(n-1)/2\n    2.  交换相邻元素的本质：消除一对逆序\n\n* * *\n\n# 跳表\n\n1.  跳表(Skip List) \n2.  说明：[wiki][1]\n3.  图解：![跳表图解][2]\n4.  参考代码： [链接][3] [链接][4]\n\n查找：\n```cpp\np=top\nWhile(1){\n    while (p->next->key < x ) p=p->next;\n    If (p->down == NULL ) return p->next\n    p=p->down ;\n}\n```\n\n插入：\n```cpp\nint insert(val x){\n\n    int i;\n    int j = n; //n是当前表所拥有的level数\n\n    cell *p[k]; //指针数组，用来保存每一层要插入元素的前驱\n\n    cell *p1;\n    p1 = top->next;\n\n    while(p1){\n        while(p1->next->val < x) p1=p1->next;\n        if(j <= k){\n            p[j-1] = p1; //保存每一层的指针\n            p1 = p1->down; //指向下一层\n            j--;\n        }\n    }\n\n    //下面的代码是将x插入到各层\n    for (i = 0; i<k; i++){\n        if(p[i]==NULL){//k>n的情况，需要创建一个层\n            //创建层的第一个元素，并将top指向它\n            cell *elementhead = (cell *) malloc(sizeof(cell));\n            element->val = -1;\n            element->down = top;\n            top = elementhead; \n\n            //创建最后一个元素\n            cell *elementtail = (cell *) malloc(sizeof(cell));\n            elementtail->val = 1;\n            elementtail->next = elementtail->down = NULL;\n\n            //在该层中创建并插入x\n            cell *element = (cell *) malloc(sizeof(cell));\n            element->val = x;\n            elementhead->next = element;\n            element->next = elementtail;\n            element->down = p[i-1]->next;\n        }\n\n        //正常插入一个元素\n        cell *element = (cell *) malloc(sizeof(cell));\n        element->val = x;\n        element->next = p[i]->next;\n        element->down = (i=0?NULL:(p[i-1]->next));\n        p[i]->next = element;\n    }\n\n    return 0;\n}\n```\n删除：\n\n```cpp\nint delete(val x){\n\n    int i = n; //n表示当前总层数\n    cell *p, *p1;\n    p = top;\n\n    while(n>0){\n        while(p->next->val < x) p=p->next;\n        if(p->next->val == x){//假如当前层存在节点x,删除\n            if(p = top && p->next->next->val == INT_MAX){//该层之存在一个节点\n                top = p->down;\n                free(p->next->next);\n                free(p->next);\n                free(p);\n                p = top;\n            }\n            else{\n                p1 = p->next;\n                p->next = p1->next;\n                free(p1);\n            }\n        }\n        p = p->down;\n        n--;\n    }\n}\n```\n    \n\n* * *\n\n# 一致哈希表\n\n1.  定义：按照常用的hash算法来将对应的key哈希到一个具有2^32次方个桶的空间中，即0~(2^32)-1的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的环形。\n2.  图解：![图解][5]\n3.  代码\n```java\nimport java.util.Collection;  \nimport java.util.SortedMap;  \nimport java.util.TreeMap;  \n\npublic class ConsistentHash<T> {  \n\n private final HashFunction hashFunction;  \n private final int numberOfReplicas;  \n private final SortedMap<Integer, T> circle = new TreeMap<Integer, T>();  \n\n public ConsistentHash(HashFunction hashFunction, int numberOfReplicas,  \n     Collection<T> nodes) {  \n   this.hashFunction = hashFunction;  \n   this.numberOfReplicas = numberOfReplicas;  \n\n   for (T node : nodes) {  \n     add(node);  \n   }  \n }  \n\n public void add(T node) {  \n   for (int i = 0; i < numberOfReplicas; i++) {  \n     circle.put(hashFunction.hash(node.toString() + i), node);  \n   }  \n }  \n\n public void remove(T node) {  \n   for (int i = 0; i < numberOfReplicas; i++) {  \n     circle.remove(hashFunction.hash(node.toString() + i));  \n   }  \n }  \n\n public T get(Object key) {  \n   if (circle.isEmpty()) {  \n     return null;  \n   }  \n   int hash = hashFunction.hash(key);  \n   if (!circle.containsKey(hash)) {  \n     SortedMap<Integer, T> tailMap = circle.tailMap(hash);  \n     hash = tailMap.isEmpty() ? circle.firstKey() : tailMap.firstKey();  \n   }  \n   return circle.get(hash);  \n }  \n} \n```\n\n4.  目标：\n    \n    1.  可扩展，快速添加，删除结点\n    2.  平衡性，对数据分布（尤其是一个结点被删除后，如何快速把这个空结点分配）\n    3.  虚拟结点：虚拟结点分布在两个真实结点之间，加速查询，所有落在虚拟结点上的，会直接指向真实结点\n\n* * *\n\n# 排序\n\n1.  左出序：记录Ri的关键字值为Ki，Ri是左出序当且仅当Ki < max{Kj}(0<=j<i)，既这个关键字左边的值至少有一个比它大。有几个比它大叫做几个左出序。\n\n2.  插入排序，时间为O((k+1)*n)，k为左出序记录个数，故左出序越少性能越好\n\n3.  冒泡排序，每次交换消除一对逆序，算法平均O(n^2)\n\n4.  希尔排序，在插入排序基础上，将总记录划分为多个子记录，每个记录相隔incr个元素。算法交换非相邻元素，故可能一次交换消除多对逆序，鉴于非相邻交换时消除逆序对数量随机，在统计上计算，可知算法复杂度在O(n^1.2 ~ n^2)之间（唯一一个无法纯理论计算出复杂度的排序算法）\n\n5.  希尔排序改进，数学归纳法:1) 定义hk = 2^k -1,若hk 已经排序，则h(k-1)也排序，不会打乱之前的排序（不创造新逆序，只消除逆序），可最终导致h(1)排序。 2) 如果hk 和 h(k-1)已经排序，则可知h(k)和h(k-1)的公倍数序列也排序，则h(k-2)排序的时候不用考虑该序列 3)使用递归\n\n6.  快速排序改进了希尔排序，将基准记录放在一个位置，分为左右两个记录表，左边所有元素都小于右边的最小的，然后递归地对两个左右记录表进行排序（这个过程可以独立），最终合并。相对稳定，平均O(nlogn)，最差O(n^2)\n\n7.  归并排序需要辅助空间O(n-l+1)，对左右任意分配的（一般是长度相同或者-1）的两表直接归并（站队归并），可以通过循环或者递归归并来进行排序。也是O(nlogn)，稳定排序\n\n8.  堆排序：利用最大堆，通过插入和删除操作，得出排序序列。为了优化构建最大堆的效率，可以采用优化的adjust方法来使堆成为最大堆。\n\n9.  基数排序：在关键字值为0到n-1的整数范围内饰，可以直接装箱。箱子个数取决于排序元素，对于数字可以2进制的2个箱子，也可以10进制10个箱子，对于字母可以26个箱子。比如说用十进制为基数排序，按照个位，十位，百位……依次构成链表的节点（即每层链表10个节点），然后存储所有满足位数的元素。  \n    每次扫描时，首先从个位开始，按照0-9的顺序排过去，结果链表保留下来，进行下一轮。下一轮从十位开始，从结果链表选出，用十位排序，更新结果链表…………直到最终扫描结束（扫描次数就是关键字长度，比如0-999就是3次）  \n    效率为O(n)，缺点是占用空间较大\n\n* * *\n\n# 查找\n\n1.  二叉查找树\n    \n    1.  定义：（1）是二叉树 （2）关键字不重 （3）左孩子小于根节点，右孩子大于根节点（如果有的话）（4）左右子树也为二叉查找树（如果有的话） \n    2.  查找：与根节点比较，小于走左，大于走右，等于返回，找不到null\n    3.  插入：先查找，如果有重合的返回false，如果不重，在搜索的结束位置加入新的节点\n    4.  删除：先查找，找到就删除，找不到返回。\n\n2.  AVL树：见书上，理解4种旋转。\n\n3.  红黑树：\n    \n    1.  定义： \n        1.  节点是红色或黑色。\n        2.  根是黑色。\n        3.  所有叶子都是黑色（叶子是NIL节点）。\n        4.  每个红色节点必须有两个黑色的子节点。(从每个叶子到根的所有路径上不能有两个连续的红色节点。)\n        5.  从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。\n    2.  查找：因为红黑树也是二叉查找树，因此红黑树上的查找操作与普通二叉查找树上的查找操作相同。即递归下去比较，等于根节点返回，小于向左走，大于向右走。\n    3.  插入：(1) 查找要插入的位置，时间复杂度为：O(N) (2) 将新节点的color赋为红色 (3) 自下而上重新调整该树为红黑树\n    4.  删除：(1) 查找要删除位置，时间复杂度为：O(N) (2) 用删除节点后继或者节点替换该节点（只进行数据替换即可，不必调整指针，后继节点是中序遍历中紧挨着该节点的节点，即：右孩子的最左孩子节点） (3) 如果删除节点的替换节点为黑色，则需重新调整该树为红黑树\n    5.  旋转：复杂，保证规则不变的情况下，在插入和删除下各有3种情况\n    6.  应用：`快速搜索`，`字典`\n    7.  图片：![][6]\n\n4.  Splay树：见书，每次插入删除可能不平衡，会造成旋转。4种旋转LL,RR,LR,RL，只需要2类旋转函数即可。\n\n5.  B-树：\n    \n    1.  定义： B-树结构特性：一棵m阶B-树，或为空树，或为满足下列特性的m叉树：(m≥3) \n        1.  根结点只有1个，关键字字数的范围[1,m-1]，分支数量范围[2,m]；\n        2.  除根以外的非叶结点，每个结点包含分支数范围[[m/2],m]，即关键字字数的范围是[[m/2]-1,m-1]，其中[m/2]表示取大于等于m/2的最小整数；\n        3.  叶结点是由非叶结点分裂而来的，所以叶结点关键字个数也满足[[m/2]-1,m-1]；\n        4.  所有的非终端结点包含信息：(n，A0，K1，A1，K2，A2，……，Kn，An)，其中Ki为关键字，Ai为指向子树根结点的指针，并且Ai-1所指子树中的关键字均小于Ki，而Ai所指的关键字均大于Ki（i=1，2，……，n）。n+1表示B-树的阶，n表示关键字个数；\n        5.  所有叶子结点都在同一层，并且指针域为空，具有如下性质： 根据B树定义，第一层为根有一个结点，至少两个分支，第二层至少2个结点，i≥3时，每一层至少有2乘以([m/2])的i-2次方个结点([m/2]表示取大于m/2的最小整数)。若m阶树中共有N个结点，那么可以推导出N必然满足N≥2*(([m/2])的h-1次方)-1 (h≥1)，因此若查找成功，则高度`h≤1+log[m/2](N+1)/2`，h也是磁盘访问次数(h≥1)，保证了查找算法的高效率。\n    2.  查找：首先从根结点开始重复如下过程： 若比结点的第一个关键字小，则查找在该结点第一个指针指向的结点进行；若等于结点中某个关键字，则查找成功；若在两个关键字之间，则查找在它们之间的指针指向的结点进行；若比该结点所有关键字大，则查找在该结点最后一个指针指向的结点进行；若查找已经到达某个叶结点，则说明给定值对应的数据记录不存在，查找失败。\n    3.  插入： \n        1.  B-树的生成从空树开始，逐个插入关键字而得。关键字的个数必须至少为[m/2]-1，每次插入总在最底层某个终端结点添加一个关键字，如果该结点关键字个数小于m-1则直接插入，如果发现新插入关键字后，关键字总数超过m-1个则结点需要分裂，做法如下：\n        2.  假设结点p中已经含有m-1个关键字，再插入一个关键字之后(插入总要保持关键字数组的大小有序，从小到大排好序)，可以将p分裂为p和p’，其中p含有的信息为[m/2]-1([m]表示大于m的最小整数)，p’含有的信息为`m-[m/2]` ([m]表示大于m的最小整数)。然后将关键字K[m/2]和指向p’的指针则一起插入到p的双亲结点中去。\n        3.  检查双亲结点，如果双亲结点出现(a)的情况，则回到步骤a继续执行。直到插入满足条件为止，树的深度增加过程是随着插入而自下而上生长的过程。\n    4.  删除： \n        1.  B-树删除算法分析，分以下5种情况讨论：\n        2.  被删除关键字所在的结点为叶结点，关键字数目大于或等于[m/2]，则只需要直接删去Ai和Ki即可；\n        3.  被删除关键字所在的结点为叶结点，关键字数目等于[m/2]-1，相邻的左右兄弟关键字数目至少有一方大于或者等于[m/2]，此时，如果右兄弟关键字数目大于或者等于[m/2]，则将右兄弟中最小的关键字上移到双亲结点中，然后将其中紧靠在上移关键字左边的一个关键字移动到被删除关键字所在的结点的最右边；否则，如果左兄弟的关键字数目大于或者等于[m/2]，则左兄弟中最大的关键字上移到双亲结点中，将紧靠在该上移关键字右边的一个关键字移动到被删除关键字所在的结点的最左边。这些做法类似于减法的借位运算。\n        *   被删除关键字所在的结点为叶结点，关键字数目等于[m/2]-1，相邻的左右兄弟关键字数目均等于[m/2]-1，则从双亲借关键字补充，然后算法进入非叶结点的删除判断；\n        *   被删除关键字所在的结点为非叶结点，并且关键字数目大于或等于[m/2]，则删去Ai和Ki后，原来关键字的左右孩子进行合并，若合并后的结点的关键字数目满足B-树性质，则结束，而对于关键字数目大于m-1，则进行一次分裂，将其中一个结点移到当前结点中。\n        *   被删除关键字所在的结点为非叶结点，关键字数目等于[m/2]-1，相邻的左右兄弟关键字数目均等于[m/2]-1，则删除该关键字之后优先判断能否从被删除的关键字的左右孩子中寻找关键字补充，如果左右孩子的关键字数目均为[m/2]-1，如果此结点已经是树的根，则直接将被删除关键字的左右孩子结点合并即可，如果不是树的根，则从自己的双亲补充关键字，然后重复上述判断算法(d)或者(e)。\n        *   应用：`数据库搜索`\n        *   图片：![][7]\n\n6.  B+树：\n    \n    1.  定义： B+树是应文件系统所需而出的一种B-树的变型树。一棵m阶的B+树和m阶的B-树的差异在于： \n        1.  有n棵子树的结点中含有n个关键字，每个关键字不保存数据，只用来索引，所有数据都保存在叶子节点。\n        2.  所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。\n        3.  所有的非终端结点可以看成是索引部分，结点中仅含其子树（根结点）中的最大（或最小）关键字。 通常在B+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点。\n    2.  查找： \n        1.  从最小关键字起顺序查找；\n        2.  从根结点开始，进行随机查找。 在查找时，若非终端结点上的关键值等于给定值，并不终止，而是继续向下直到叶子结点。因此，在B+树中，不管查找成功与否，每次查找都是走了一条从根到叶子结点的路径。其余同B-树的查找类似。\n    3.  插入： m阶B树的插入操作在叶子结点上进行，假设要插入关键值a，找到叶子结点后插入a，做如下算法判别： \n        1.  如果当前结点是根结点并且插入后结点关键字数目小于等于m，则算法结束；\n        2.  如果当前结点是非根结点并且插入后结点关键字数目小于等于m，则判断若a是新索引值时转步骤④后结束，若a不是新索引值则直接结束；\n        3.  如果插入后关键字数目大于m(阶数)，则结点先分裂成两个结点X和Y，并且他们各自所含的关键字个数分别为：u=大于(m+1)/2的最小整数，v=小于(m+1)/2的最大整数； 由于索引值位于结点的最左端或者最右端，不妨假设索引值位于结点最右端，有如下操作： 如果当前分裂成的X和Y结点原来所属的结点是根结点，则从X和Y中取出索引的关键字，将这两个关键字组成新的根结点，并且这个根结点指向X和Y，算法结束； 如果当前分裂成的X和Y结点原来所属的结点是非根结点，依据假设条件判断，如果a成为Y的新索引值，则转步骤④得到Y的双亲结点P，如果a不是Y结点的新索引值，则求出X和Y结点的双亲结点P；然后提取X结点中的新索引值a’，在P中插入关键字a’，从P开始，继续进行插入算法；\n        4.  提取结点原来的索引值b，自顶向下，先判断根是否含有b，是则需要先将b替换为a，然后从根结点开始，记录结点地址P，判断P的孩子是否含有索引值b而不含有索引值a，是则先将孩子结点中的b替换为a，然后将P的孩子的地址赋值给P，继续搜索，直到发现P的孩子中已经含有a值时，停止搜索，返回地址P。\n    4.  删除：B+树的删除也仅在叶子结点进行，当叶子结点中的最大关键字被删除时，其在非终端结点中的值可以作为一个“分界关键字”存在。若因删除而使结点中关键字的个数少于m/2 （m/2结果取上界，如5/2结果为3）时，其和兄弟结点的合并过程亦和B-树类似。\n    5.  应用：`文件系统`\n    6.  图片：![][8]\n\n7.  R树：多维空间中的搜索树\n    \n    1.  定义： \n        1.  除非它是根结点之外，所有叶子结点包含有m至M个记录索引（条目）。作为根结点的叶子结点所具有的记录个数可以少于m。通常，m=M/2。\n        2.  对于所有在叶子中存储的记录（条目），I是最小的可以在空间中完全覆盖这些记录所代表的点的矩形（注意：此处所说的“矩形”是可以扩展到高维空间的）。\n        3.  每一个非叶子结点拥有m至M个孩子结点，除非它是根结点。\n        4.  对于在非叶子结点上的每一个条目，i是最小的可以在空间上完全覆盖这些条目所代表的店的矩形（同性质2）。\n        5.  所有叶子结点都位于同一层，因此R树为平衡树。\n    2.  搜索：R树的插入操作也同B树的插入操作类似。当新的数据记录需要被添加入叶子结点时，若叶子结点溢出，那么我们需要对叶子结点进行分裂操作。显然，叶子结点的插入操作会比搜索操作要复杂。插入操作需要一些辅助方法才能够完成。\n    3.  插入：R树的插入操作也同B树的插入操作类似。当新的数据记录需要被添加入叶子结点时，若叶子结点溢出，那么我们需要对叶子结点进行分裂操作。显然，叶子结点的插入操作会比搜索操作要复杂。插入操作需要一些辅助方法才能够完成。\n    4.  删除：R树的删除操作与B树的删除操作会有所不同，不过同B树一样，会涉及到压缩等操作。相信读者看完以下的伪代码之后会有所体会。R树的删除同样是比较复杂的，需要用到一些辅助函数来完成整个操作。\n    5.  应用：`空间搜索`，`地图定位`，`图片查找` \n    6.  图片：![][9]\n\n* * *\n\n# 时间/空间复杂度表\n\n<div class=\"p-entry\">\n  <span data-rel=\"content\"></p> <p>\n    常用算法和数据结构的复杂度速查表\n  </p>\n  \n  <p>\n  </p></p> \n  \n  <h2 id=\"searching\">\n    搜索\n  </h2>\n  \n  <table border=\"1\">\n    <thead>\n      <tr>\n        <th>\n          算法\n        </th>\n        \n        <th>\n          数据结构\n        </th>\n        \n        <th colspan=\"2\">\n          时间复杂度\n        </th>\n        \n        <th colspan=\"3\">\n          空间复杂度\n        </th>\n      </tr>\n      \n      <tr>\n        <th>\n        </th>\n        \n        <th>\n        </th>\n        \n        <th>\n          平均\n        </th>\n        \n        <th>\n          最差\n        </th>\n        \n        <th>\n          最差\n        </th>\n      </tr>\n    </thead>\n    \n    <tbody>\n      <tr>\n        <td>\n          <a href=\"http://en.wikipedia.org/wiki/Depth-first_search\">深度优先搜索 (DFS)</a>\n        </td>\n        \n        <td>\n          Graph of |V| vertices and |E| edges\n        </td>\n        \n        <td>\n          <code>-</code>\n        </td>\n        \n        <td>\n          <code>O(|E| + |V|)</code>\n        </td>\n        \n        <td>\n          <code>O(|V|)</code>\n        </td>\n      </tr>\n      \n      <tr>\n        <td>\n          <a href=\"http://en.wikipedia.org/wiki/Breadth-first_search\">广度优先搜索 (BFS)</a>\n        </td>\n        \n        <td>\n          Graph of |V| vertices and |E| edges\n        </td>\n        \n        <td>\n          <code>-</code>\n        </td>\n        \n        <td>\n          <code>O(|E| + |V|)</code>\n        </td>\n        \n        <td>\n          <code>O(|V|)</code>\n        </td>\n      </tr>\n      \n      <tr>\n        <td>\n          <a href=\"http://en.wikipedia.org/wiki/Binary_search_algorithm\">二分查找</a>\n        </td>\n        \n        <td>\n          Sorted array of n elements\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(1)</code>\n        </td>\n      </tr>\n      \n      <tr>\n        <td>\n          <a href=\"http://en.wikipedia.org/wiki/Brute-force_search\">穷举</a>查找\n        </td>\n        \n        <td>\n          Array\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n        \n        <td>\n          <code>O(1)</code>\n        </td>\n      </tr>\n      \n      <tr>\n        <td>\n          <a href=\"http://en.wikipedia.org/wiki/Dijkstra's_algorithm\">最短路径-Dijkstra，用小根堆作为优先队列</a>\n        </td>\n        \n        <td>\n          Graph with |V| vertices and |E| edges\n        </td>\n        \n        <td>\n          <code>O((|V| + |E|) log |V|)</code>\n        </td>\n        \n        <td>\n          <code>O((|V| + |E|) log |V|)</code>\n        </td>\n        \n        <td>\n          <code>O(|V|)</code>\n        </td>\n      </tr>\n      \n      <tr>\n        <td>\n          <a href=\"http://en.wikipedia.org/wiki/Dijkstra's_algorithm\">最短路径-Dijkstra，用无序数组作为优先队列</a>\n        </td>\n        \n        <td>\n          Graph with |V| vertices and |E| edges\n        </td>\n        \n        <td>\n          <code>O(|V|^2)</code>\n        </td>\n        \n        <td>\n          <code>O(|V|^2)</code>\n        </td>\n        \n        <td>\n          <code>O(|V|)</code>\n        </td>\n      </tr>\n      \n      <tr>\n        <td>\n          <a href=\"http://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm\">最短路径-Bellman-Ford</a>\n        </td>\n        \n        <td>\n          Graph with |V| vertices and |E| edges\n        </td>\n        \n        <td>\n          <code>O(|V||E|)</code>\n        </td>\n        \n        <td>\n          <code>O(|V||E|)</code>\n        </td>\n        \n        <td>\n          <code>O(|V|)</code>\n        </td>\n      </tr>\n    </tbody>\n  </table>\n  \n  <h2 id=\"sorting\">\n    排序\n  </h2>\n  \n  <table border=\"1\">\n    <thead>\n      <tr>\n        <th>\n          算法\n        </th>\n        \n        <th>\n          数据结构\n        </th>\n        \n        <th colspan=\"3\">\n          时间复杂度\n        </th>\n        \n        <th colspan=\"3\">\n          最坏情况下的辅助空间复杂度\n        </th>\n      </tr>\n      \n      <tr>\n        <th>\n        </th>\n        \n        <th>\n        </th>\n        \n        <th>\n          最佳\n        </th>\n        \n        <th>\n          平均\n        </th>\n        \n        <th>\n          最差\n        </th>\n        \n        <th>\n          最差\n        </th>\n      </tr>\n    </thead>\n    \n    <tbody>\n      <tr>\n        <td>\n          <a href=\"http://en.wikipedia.org/wiki/Quicksort\">快速排序</a>\n        </td>\n        \n        <td>\n          数组\n        </td>\n        \n        <td>\n          <code>O(n log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(n log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(n^2)</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n      </tr>\n      \n      <tr>\n        <td>\n          <a href=\"http://en.wikipedia.org/wiki/Merge_sort\">归并排序</a>\n        </td>\n        \n        <td>\n          数组\n        </td>\n        \n        <td>\n          <code>O(n log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(n log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(n log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n      </tr>\n      \n      <tr>\n        <td>\n          <a href=\"http://en.wikipedia.org/wiki/Heapsort\">堆排序</a>\n        </td>\n        \n        <td>\n          数组\n        </td>\n        \n        <td>\n          <code>O(n log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(n log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(n log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(1)</code>\n        </td>\n      </tr>\n      \n      <tr>\n        <td>\n          <a href=\"http://en.wikipedia.org/wiki/Bubble_sort\">冒泡排序</a>\n        </td>\n        \n        <td>\n          数组\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n        \n        <td>\n          <code>O(n^2)</code>\n        </td>\n        \n        <td>\n          <code>O(n^2)</code>\n        </td>\n        \n        <td>\n          <code>O(1)</code>\n        </td>\n      </tr>\n      \n      <tr>\n        <td>\n          <a href=\"http://en.wikipedia.org/wiki/Insertion_sort\">插入排序</a>\n        </td>\n        \n        <td>\n          数组\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n        \n        <td>\n          <code>O(n^2)</code>\n        </td>\n        \n        <td>\n          <code>O(n^2)</code>\n        </td>\n        \n        <td>\n          <code>O(1)</code>\n        </td>\n      </tr>\n      \n      <tr>\n        <td>\n          <a href=\"http://en.wikipedia.org/wiki/Selection_sort\">选择排序</a>\n        </td>\n        \n        <td>\n          数组\n        </td>\n        \n        <td>\n          <code>O(n^2)</code>\n        </td>\n        \n        <td>\n          <code>O(n^2)</code>\n        </td>\n        \n        <td>\n          <code>O(n^2)</code>\n        </td>\n        \n        <td>\n          <code>O(1)</code>\n        </td>\n      </tr>\n      \n      <tr>\n        <td>\n          <a href=\"http://en.wikipedia.org/wiki/Bucket_sort\" rel=\"tooltip\" data-original-title=\"Only for integers with range k\">桶排序</a>\n        </td>\n        \n        <td>\n          数组\n        </td>\n        \n        <td>\n          <code>O(n+k)</code>\n        </td>\n        \n        <td>\n          <code>O(n+k)</code>\n        </td>\n        \n        <td>\n          <code>O(n^2)</code>\n        </td>\n        \n        <td>\n          <code>O(nk)</code>\n        </td>\n      </tr>\n      \n      <tr>\n        <td>\n          <a href=\"http://en.wikipedia.org/wiki/Radix_sort\" rel=\"tooltip\" data-original-title=\"Constant number of digits 'k'\">基数排序</a>\n        </td>\n        \n        <td>\n          数组\n        </td>\n        \n        <td>\n          <code>O(nk)</code>\n        </td>\n        \n        <td>\n          <code>O(nk)</code>\n        </td>\n        \n        <td>\n          <code>O(nk)</code>\n        </td>\n        \n        <td>\n          <code>O(n+k)</code>\n        </td>\n      </tr>\n    </tbody>\n  </table>\n  \n  <h2 id=\"data-structures\">\n    数据结构\n  </h2>\n  \n  <table border=\"1\">\n    <thead>\n      <tr>\n        <th>\n          数据结构\n        </th>\n        \n        <th colspan=\"8\">\n          时间复杂度\n        </th>\n        \n        <th>\n          空间复杂度\n        </th>\n      </tr>\n      \n      <tr>\n        <th>\n        </th>\n        \n        <th colspan=\"4\">\n          平均\n        </th>\n        \n        <th colspan=\"4\">\n          最差\n        </th>\n        \n        <th>\n          最差\n        </th>\n      </tr>\n      \n      <tr>\n        <th>\n        </th>\n        \n        <th>\n          索引\n        </th>\n        \n        <th>\n          查找\n        </th>\n        \n        <th>\n          插入\n        </th>\n        \n        <th>\n          删除\n        </th>\n        \n        <th>\n          索引\n        </th>\n        \n        <th>\n          查找\n        </th>\n        \n        <th>\n          插入\n        </th>\n        \n        <th>\n          删除\n        </th>\n        \n        <th>\n        </th>\n      </tr>\n    </thead>\n    \n    <tbody>\n      <tr>\n        <td>\n          <a href=\"http://en.wikipedia.org/wiki/Array_data_structure\">基本数组</a>\n        </td>\n        \n        <td>\n          <code>O(1)</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n        \n        <td>\n          <code>-</code>\n        </td>\n        \n        <td>\n          <code>-</code>\n        </td>\n        \n        <td>\n          <code>O(1)</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n        \n        <td>\n          <code>-</code>\n        </td>\n        \n        <td>\n          <code>-</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n      </tr>\n      \n      <tr>\n        <td>\n          <a href=\"http://en.wikipedia.org/wiki/Dynamic_array\">动态数组</a>\n        </td>\n        \n        <td>\n          <code>O(1)</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n        \n        <td>\n          <code>O(1)</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n      </tr>\n      \n      <tr>\n        <td>\n          <a href=\"http://en.wikipedia.org/wiki/Singly_linked_list#Singly_linked_lists\">单链表</a>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n        \n        <td>\n          <code>O(1)</code>\n        </td>\n        \n        <td>\n          <code>O(1)</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n        \n        <td>\n          <code>O(1)</code>\n        </td>\n        \n        <td>\n          <code>O(1)</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n      </tr>\n      \n      <tr>\n        <td>\n          <a href=\"http://en.wikipedia.org/wiki/Doubly_linked_list\">双链表</a>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n        \n        <td>\n          <code>O(1)</code>\n        </td>\n        \n        <td>\n          <code>O(1)</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n        \n        <td>\n          <code>O(1)</code>\n        </td>\n        \n        <td>\n          <code>O(1)</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n      </tr>\n      \n      <tr>\n        <td>\n          <a href=\"http://en.wikipedia.org/wiki/Skip_list\">跳表</a>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n        \n        <td>\n          <code>O(n log(n))</code>\n        </td>\n      </tr>\n      \n      <tr>\n        <td>\n          <a href=\"http://en.wikipedia.org/wiki/Hash_table\">哈希表</a>\n        </td>\n        \n        <td>\n          <code>-</code>\n        </td>\n        \n        <td>\n          <code>O(1)</code>\n        </td>\n        \n        <td>\n          <code>O(1)</code>\n        </td>\n        \n        <td>\n          <code>O(1)</code>\n        </td>\n        \n        <td>\n          <code>-</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n      </tr>\n      \n      <tr>\n        <td>\n          <a href=\"http://en.wikipedia.org/wiki/Binary_search_tree\">二叉搜索树</a>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n      </tr>\n      \n      <tr>\n        <td>\n          <a href=\"https://en.wikipedia.org/wiki/Cartesian_tree\">笛卡尔树</a>\n        </td>\n        \n        <td>\n          <code>-</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>-</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n      </tr>\n      \n      <tr>\n        <td>\n          <a href=\"http://en.wikipedia.org/wiki/B_tree\">B-树</a>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n      </tr>\n      \n      <tr>\n        <td>\n          <a href=\"http://en.wikipedia.org/wiki/Red-black_tree\">红黑树</a>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n      </tr>\n      \n      <tr>\n        <td>\n          <a href=\"https://en.wikipedia.org/wiki/Splay_tree\">伸展树</a>\n        </td>\n        \n        <td>\n          <code>-</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>-</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n      </tr>\n      \n      <tr>\n        <td>\n          <a href=\"http://en.wikipedia.org/wiki/AVL_tree\">AVL 树</a>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n      </tr>\n    </tbody>\n  </table>\n  \n  <h2 id=\"heaps\">\n    堆\n  </h2>\n  \n  <table border=\"1\">\n    <thead>\n      <tr>\n        <th>\n          Heaps\n        </th>\n        \n        <th colspan=\"7\">\n          时间复杂度\n        </th>\n      </tr>\n      \n      <tr>\n        <th>\n        </th>\n        \n        <th>\n          建堆\n        </th>\n        \n        <th>\n          查找最大值\n        </th>\n        \n        <th>\n          提取最大值\n        </th>\n        \n        <th>\n          Increase Key\n        </th>\n        \n        <th>\n          插入\n        </th>\n        \n        <th>\n          删除\n        </th>\n        \n        <th>\n          合并\n        </th>\n        \n        <th>\n        </th>\n      </tr>\n    </thead>\n    \n    <tbody>\n      <tr>\n        <td>\n          <a href=\"http://en.wikipedia.org/wiki/Linked_list\">链表（已排序）</a>\n        </td>\n        \n        <td>\n          <code>-</code>\n        </td>\n        \n        <td>\n          <code>O(1)</code>\n        </td>\n        \n        <td>\n          <code>O(1)</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n        \n        <td>\n          <code>O(1)</code>\n        </td>\n        \n        <td>\n          <code>O(m+n)</code>\n        </td>\n      </tr>\n      \n      <tr>\n        <td>\n          <a href=\"http://en.wikipedia.org/wiki/Linked_list\">链表（未排序）</a>\n        </td>\n        \n        <td>\n          <code>-</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n        \n        <td>\n          <code>O(1)</code>\n        </td>\n        \n        <td>\n          <code>O(1)</code>\n        </td>\n        \n        <td>\n          <code>O(1)</code>\n        </td>\n        \n        <td>\n          <code>O(1)</code>\n        </td>\n      </tr>\n      \n      <tr>\n        <td>\n          <a href=\"http://en.wikipedia.org/wiki/Binary_heap\">二叉堆</a>\n        </td>\n        \n        <td>\n          <code>O(n)</code>\n        </td>\n        \n        <td>\n          <code>O(1)</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(m+n)</code>\n        </td>\n      </tr>\n      \n      <tr>\n        <td>\n          <a href=\"http://en.wikipedia.org/wiki/Binomial_heap\">二项堆</a>\n        </td>\n        \n        <td>\n          <code>-</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n        \n        <td>\n          <code>O(log(n))</code>\n        </td>\n      </tr>\n      \n      <tr>\n        <td>\n          <a href=\"http://en.wikipedia.org/wiki/Fibonacci_heap\">斐波那契堆</a>\n        </td>\n        \n        <td>\n          <code>-</code>\n        </td>\n        \n        <td>\n          <code>O(1)</code>\n        </td>\n        \n        <td>\n          <code data-original-title=\"Amortized\">O(log(n))*</code>\n        </td>\n        \n        <td>\n          <code data-original-title=\"Amortized\">O(1)*</code>\n        </td>\n        \n        <td>\n          <code>O(1)</code>\n        </td>\n        \n        <td>\n          <code data-original-title=\"Amortized\">O(log(n))*</code>\n        </td>\n        \n        <td>\n          <code>O(1)</code>\n        </td>\n      </tr>\n    </tbody>\n  </table>\n  \n  <h2 id=\"graphs\">\n    图\n  </h2>\n  \n  <table border=\"1\">\n    <tbody>\n      <tr>\n        <th>\n          节点 / 边 管理\n        </th>\n        \n        <th>\n          Storage\n        </th>\n        \n        <th>\n          Add Vertex\n        </th>\n        \n        <th>\n          Add Edge\n        </th>\n        \n        <th>\n          Remove Vertex\n        </th>\n        \n        <th>\n          Remove Edge\n        </th>\n        \n        <th>\n          Query\n        </th>\n      </tr>\n      \n      <tr>\n        <td>\n          <a href=\"http://en.wikipedia.org/wiki/Adjacency_list\">邻接表</a>\n        </td>\n        \n        <td>\n          <code>O(|V|+|E|)</code>\n        </td>\n        \n        <td>\n          <code>O(1)</code>\n        </td>\n        \n        <td>\n          <code>O(1)</code>\n        </td>\n        \n        <td>\n          <code>O(|V| + |E|)</code>\n        </td>\n        \n        <td>\n          <code>O(|E|)</code>\n        </td>\n        \n        <td>\n          <code>O(|V|)</code>\n        </td>\n      </tr>\n      \n      <tr>\n        <td>\n          <a href=\"http://en.wikipedia.org/wiki/Incidence_list\">关联表</a>\n        </td>\n        \n        <td>\n          <code>O(|V|+|E|)</code>\n        </td>\n        \n        <td>\n          <code>O(1)</code>\n        </td>\n        \n        <td>\n          <code>O(1)</code>\n        </td>\n        \n        <td>\n          <code>O(|E|)</code>\n        </td>\n        \n        <td>\n          <code>O(|E|)</code>\n        </td>\n        \n        <td>\n          <code>O(|E|)</code>\n        </td>\n      </tr>\n      \n      <tr>\n        <td>\n          <a href=\"http://en.wikipedia.org/wiki/Adjacency_matrix\">邻接矩阵</a>\n        </td>\n        \n        <td>\n          <code>O(|V|^2)</code>\n        </td>\n        \n        <td>\n          <code>O(|V|^2)</code>\n        </td>\n        \n        <td>\n          <code>O(1)</code>\n        </td>\n        \n        <td>\n          <code>O(|V|^2)</code>\n        </td>\n        \n        <td>\n          <code>O(1)</code>\n        </td>\n        \n        <td>\n          <code>O(1)</code>\n        </td>\n      </tr>\n      \n      <tr>\n        <td>\n          <a href=\"http://en.wikipedia.org/wiki/Incidence_matrix\">关联矩阵</a>\n        </td>\n        \n        <td>\n          <code>O(|V| ⋅ |E|)</code>\n        </td>\n        \n        <td>\n          <code>O(|V| ⋅ |E|)</code>\n        </td>\n        \n        <td>\n          <code>O(|V| ⋅ |E|)</code>\n        </td>\n        \n        <td>\n          <code>O(|V| ⋅ |E|)</code>\n        </td>\n        \n        <td>\n          <code>O(|V| ⋅ |E|)</code>\n        </td>\n        \n        <td>\n          <code>O(|E|)</code>\n        </td>\n      </tr>\n    </tbody>\n  </table>\n\n\n  <h1>\n    应用（转自博客）：\n  </h1>\n  \n  <div id=\"article_content\" class=\"article_content\">\n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(57,57,57); font-family:verdana,'ms song',Arial,Helvetica,sans-serif; line-height:16.7999992370605px\">\n      <span style=\"margin:0px; padding:0px; background-color:rgb(255,255,255)\"><span style=\"font-size:14px\"><strong>BST<span style=\"margin:0px; padding:0px; font-family:宋体\">树</span></strong></span></span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(57,57,57); font-family:verdana,'ms song',Arial,Helvetica,sans-serif; font-size:14.3999996185303px; line-height:16.7999992370605px\">\n      <span style=\"background-color:rgb(255,255,255)\"><span style=\"margin:0px; padding:0px\">       </span><span style=\"margin:0px; padding:0px; font-family:宋体\">即二叉搜索树：</span></span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(57,57,57); font-family:verdana,'ms song',Arial,Helvetica,sans-serif; font-size:14.3999996185303px; line-height:16.7999992370605px\">\n      <span style=\"background-color:rgb(255,255,255)\"><span style=\"margin:0px; padding:0px\">       1.</span><span style=\"margin:0px; padding:0px; font-family:宋体\">所有非叶子结点至多拥有两个儿子（</span>Left<span style=\"margin:0px; padding:0px; font-family:宋体\">和</span>Right<span style=\"margin:0px; padding:0px; font-family:宋体\">）；</span></span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(57,57,57); font-family:verdana,'ms song',Arial,Helvetica,sans-serif; font-size:14.3999996185303px; line-height:16.7999992370605px\">\n      <span style=\"background-color:rgb(255,255,255)\"><span style=\"margin:0px; padding:0px\">       2.</span><span style=\"margin:0px; padding:0px; font-family:宋体\">所有结点存储一个关键字；</span></span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(57,57,57); font-family:verdana,'ms song',Arial,Helvetica,sans-serif; font-size:14.3999996185303px; line-height:16.7999992370605px\">\n      <span style=\"margin:0px; padding:0px; background-color:rgb(255,255,255)\">       3.</span><span style=\"margin:0px; padding:0px; font-family:宋体; background-color:rgb(255,255,255)\">非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树；</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(57,57,57); font-family:verdana,'ms song',Arial,Helvetica,sans-serif; font-size:14.3999996185303px; line-height:16.7999992370605px\">\n      <span style=\"background-color:rgb(255,255,255)\"><span style=\"margin:0px; padding:0px\">       </span><span style=\"margin:0px; padding:0px; font-family:宋体\">如：</span></span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(57,57,57); font-family:verdana,'ms song',Arial,Helvetica,sans-serif; font-size:14.3999996185303px; line-height:16.7999992370605px\">\n      <span style=\"background-color:rgb(255,255,255)\">       </span>\n    </p>\n    \n    <p align=\"center\" style=\"margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(57,57,57); font-family:verdana,'ms song',Arial,Helvetica,sans-serif; font-size:14.3999996185303px; line-height:16.7999992370605px\">\n      <span style=\"background-color:rgb(255,255,255)\"><img alt=\"\" src=\"http://p.blog.csdn.net/images/p_blog_csdn_net/manesking/1.JPG\" style=\"margin:0px; padding:0px; border:0px\" /></span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(57,57,57); font-family:verdana,'ms song',Arial,Helvetica,sans-serif; font-size:14.3999996185303px; line-height:16.7999992370605px\">\n      <span style=\"background-color:rgb(255,255,255)\">       <span style=\"color:rgb(57,57,57); font-family:verdana,'ms song',Arial,Helvetica,sans-serif; font-size:14px; line-height:16.7999992370605px\"> BST</span><span style=\"margin:0px; padding:0px; font-family:宋体\">树的搜索，从根结点开始，如果查询的关键字与结点的关键字相等，那么就命中；</span></span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(57,57,57); font-family:verdana,'ms song',Arial,Helvetica,sans-serif; font-size:14.3999996185303px; line-height:16.7999992370605px\">\n      <span style=\"margin:0px; padding:0px; font-family:宋体; background-color:rgb(255,255,255)\">否则，如果查询关键字比结点关键字小，就进入左儿子；如果比结点关键字大，就进入</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(57,57,57); font-family:verdana,'ms song',Arial,Helvetica,sans-serif; font-size:14.3999996185303px; line-height:16.7999992370605px\">\n      <span style=\"margin:0px; padding:0px; font-family:宋体; background-color:rgb(255,255,255)\">右儿子；如果左儿子或右儿子的指针为空，则报告找不到相应的关键字；</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(57,57,57); font-family:verdana,'ms song',Arial,Helvetica,sans-serif; font-size:14.3999996185303px; line-height:16.7999992370605px\">\n      <span style=\"background-color:rgb(255,255,255)\"><span style=\"margin:0px; padding:0px\">       </span><span style=\"margin:0px; padding:0px; font-family:宋体\">如果</span><span style=\"color:rgb(57,57,57); font-family:verdana,'ms song',Arial,Helvetica,sans-serif; font-size:14px; line-height:16.7999992370605px\">BST</span><span style=\"margin:0px; padding:0px; font-family:宋体\">树的所有非叶子结点的左右子树的结点数目均保持差不多（平衡），那么</span>B<span style=\"margin:0px; padding:0px; font-family:宋体\">树</span></span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(57,57,57); font-family:verdana,'ms song',Arial,Helvetica,sans-serif; font-size:14.3999996185303px; line-height:16.7999992370605px\">\n      <span style=\"background-color:rgb(255,255,255)\"><span style=\"margin:0px; padding:0px; font-family:宋体\">的搜索性能逼近二分查找；但它比连续内存空间的二分查找的优点是，改变</span><span style=\"color:rgb(57,57,57); font-family:verdana,'ms song',Arial,Helvetica,sans-serif; font-size:14px; line-height:16.7999992370605px\">BST</span><span style=\"margin:0px; padding:0px; font-family:宋体\">树结构</span></span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(57,57,57); font-family:verdana,'ms song',Arial,Helvetica,sans-serif; font-size:14.3999996185303px; line-height:16.7999992370605px\">\n      <span style=\"margin:0px; padding:0px; font-family:宋体; background-color:rgb(255,255,255)\">（</span><span style=\"margin:0px; padding:0px; font-family:宋体; background-color:rgb(255,255,255)\">插入与删除结点）不需要移动大段的内存数据，甚至通常是常数开销；</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(57,57,57); font-family:verdana,'ms song',Arial,Helvetica,sans-serif; font-size:14.3999996185303px; line-height:16.7999992370605px\">\n      <span style=\"background-color:rgb(255,255,255)\"><span style=\"margin:0px; padding:0px\">       </span><span style=\"margin:0px; padding:0px; font-family:宋体\">如：</span></span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(57,57,57); font-family:verdana,'ms song',Arial,Helvetica,sans-serif; font-size:14.3999996185303px; line-height:16.7999992370605px\">\n      <span style=\"margin:0px; padding:0px; background-color:rgb(255,255,255)\">      </span>\n    </p>\n    \n    <p align=\"center\" style=\"margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(57,57,57); font-family:verdana,'ms song',Arial,Helvetica,sans-serif; font-size:14.3999996185303px; line-height:16.7999992370605px\">\n      <span style=\"background-color:rgb(255,255,255)\"><img alt=\"\" src=\"http://p.blog.csdn.net/images/p_blog_csdn_net/manesking/2.JPG\" style=\"margin:0px; padding:0px; border:0px\" /></span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(57,57,57); font-family:verdana,'ms song',Arial,Helvetica,sans-serif; font-size:14.3999996185303px; line-height:16.7999992370605px\">\n      <span style=\"margin:0px; padding:0px; font-family:宋体\"><span style=\"background-color:rgb(250,247,239)\">   </span><span style=\"background-color:rgb(255,255,255)\">但</span></span><span style=\"background-color:rgb(255,255,255)\"><span style=\"color:rgb(57,57,57); font-family:verdana,'ms song',Arial,Helvetica,sans-serif; font-size:14px; line-height:16.7999992370605px\">BST</span><span style=\"margin:0px; padding:0px; font-family:宋体\">树在经过多次插入与删除后，有可能导致不同的结构：</span></span>\n    </p>\n    \n    <p align=\"center\" style=\"margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(57,57,57); font-family:verdana,'ms song',Arial,Helvetica,sans-serif; font-size:14.3999996185303px; line-height:16.7999992370605px\">\n      <span style=\"margin:0px; padding:0px; font-family:宋体; background-color:rgb(255,255,255)\"><img alt=\"\" src=\"http://p.blog.csdn.net/images/p_blog_csdn_net/manesking/31.JPG\" style=\"margin:0px; padding:0px; border:0px\" /></span>\n    </p>\n    \n    <span style=\"margin:0px; padding:0px; color:rgb(57,57,57); font-family:verdana,'ms song',Arial,Helvetica,sans-serif; font-size:14.3999996185303px; line-height:16.7999992370605px; background-color:rgb(255,255,255)\"></span> <p align=\"left\" style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n    </p>\n    \n    <p align=\"left\" style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px; font-family:宋体; background-color:rgb(255,255,255)\">   右边也是一个BST<span style=\"margin:0px; padding:0px\">树，但它的搜索性能已经是线性的了；同样的关键字集合有可能导致不同的</span></span>\n    </p>\n    \n    <p align=\"left\" style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px; font-family:宋体; background-color:rgb(255,255,255)\"><span style=\"margin:0px; padding:0px\">树结构索引；所以，使用</span>BST<span style=\"margin:0px; padding:0px\">树还要考虑尽可能让</span>BST<span style=\"margin:0px; padding:0px\">树保持左图的结构，和避免右图的结构，也就</span></span>\n    </p>\n    \n    <p align=\"left\" style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px; font-family:宋体; background-color:rgb(255,255,255)\"><span style=\"margin:0px; padding:0px\">是所谓的“平衡”问题；</span>      </span>\n    </p>\n    \n    <p align=\"left\" style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\"><span style=\"background-color:rgb(255,255,255)\">       </span><br /> <strong><span style=\"font-size:14px\">AVL平衡二叉搜索树</span></strong><br /> 定义：平衡二叉树或为空树,或为如下性质的二叉排序树:<br />   （1）左右子树深度之差的绝对值不超过1;<br />   （2）左右子树仍然为平衡二叉树.<br /> 平衡因子BF=左子树深度－右子树深度.<br /> 平衡二叉树每个结点的平衡因子只能是1，0，-1。若其绝对值超过1，则该二叉排序树就是不平衡的。<br /> 如图所示为平衡树和非平衡树示意图：</span>\n    </p>\n    \n    <p align=\"left\" style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\"><img src=\"\" alt=\"\" /><br /> </span>\n    </p>\n    \n    <p align=\"left\" style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\"><img src=\"http://images.cnitblog.com/blog/695961/201412/132035360718832.png\" alt=\"\" /><br /> </span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n       <img src=\"\" alt=\"\" />\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <strong><span style=\"font-size:14px\">RBT 红黑树</span></strong>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多；<br /> 红黑是弱平衡的，用非严格的平衡来换取增删节点时候旋转次数的降低；<br /> 所以简单说，搜索的次数远远大于插入和删除，那么选择AVL树，如果搜索，插入删除次数几乎差不多，应该选择RB树。\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      红黑树上每个结点内含五个域，color，key，left，right，p。如果相应的指针域没有，则设为NIL。<br /> 一般的，红黑树，满足以下性质，即只有满足以下全部性质的树，我们才称之为红黑树：<br /> 1）每个结点要么是红的，要么是黑的。<br /> 2）根结点是黑的。<br /> 3）每个叶结点，即空结点（NIL）是黑的。<br /> 4）如果一个结点是红的，那么它的俩个儿子都是黑的。<br /> 5）对每个结点，从该结点到其子孙结点的所有路径上包含相同数目的黑结点。<br /> 下图所示，即是一颗红黑树：\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <br /> <br /> <img src=\"http://hi.csdn.net/attachment/201012/29/8394323_1293613306CGzE.jpg\" alt=\"\" width=\"835\" height=\"242\" style=\"word-wrap:break-word; border:none; color:rgb(51,51,51); font-family:Arial; font-size:17px; line-height:37px\" /><br />\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <br />\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <br />\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n       \n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\"><span style=\"font-size:14px\"><strong>B-<span style=\"margin:0px; padding:0px; font-family:宋体\">树</span></strong></span></span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\">       </span><span style=\"margin:0px; padding:0px; font-family:宋体\">是一种平衡多路搜索树（并不是二叉的）：</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\">       1.</span><span style=\"margin:0px; padding:0px; font-family:宋体\">定义任意非叶子结点最多只有</span>M<span style=\"margin:0px; padding:0px; font-family:宋体\">个儿子；且</span>M>2<span style=\"margin:0px; padding:0px; font-family:宋体\">；</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\">       2.</span><span style=\"margin:0px; padding:0px; font-family:宋体\">根结点的儿子数为</span>[2, M]<span style=\"margin:0px; padding:0px; font-family:宋体\">；</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\">       3.</span><span style=\"margin:0px; padding:0px; font-family:宋体\">除根结点以外的非叶子结点的儿子数为</span>[M/2, M]<span style=\"margin:0px; padding:0px; font-family:宋体\">；</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\">       4.</span><span style=\"margin:0px; padding:0px; font-family:宋体\">每个结点存放至少</span>M/2-1<span style=\"margin:0px; padding:0px; font-family:宋体\">（取上整）和至多</span>M-1<span style=\"margin:0px; padding:0px; font-family:宋体\">个关键字；（至少</span>2<span style=\"margin:0px; padding:0px; font-family:宋体\">个关键字）</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\">       5.</span><span style=\"margin:0px; padding:0px; font-family:宋体\">非叶子结点的关键字个数</span>=<span style=\"margin:0px; padding:0px; font-family:宋体\">指向儿子的指针个数</span>-1<span style=\"margin:0px; padding:0px; font-family:宋体\">；</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\">       6.</span><span style=\"margin:0px; padding:0px; font-family:宋体\">非叶子结点的关键字：</span>K[1], K[2], …, K[M-1]<span style=\"margin:0px; padding:0px; font-family:宋体\">；且</span>K[i] < K[i+1]<span style=\"margin:0px; padding:0px; font-family:宋体\">；</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\">       7.</span><span style=\"margin:0px; padding:0px; font-family:宋体\">非叶子结点的指针：</span>P[1], P[2], …, P[M]<span style=\"margin:0px; padding:0px; font-family:宋体\">；其中</span>P[1]<span style=\"margin:0px; padding:0px; font-family:宋体\">指向关键字小于</span>K[1]<span style=\"margin:0px; padding:0px; font-family:宋体\">的</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px; font-family:宋体\">子树，</span>P[M]<span style=\"margin:0px; padding:0px; font-family:宋体\">指向关键字大于</span>K[M-1]<span style=\"margin:0px; padding:0px; font-family:宋体\">的子树，其它</span>P[i]<span style=\"margin:0px; padding:0px; font-family:宋体\">指向关键字属于</span>(K[i-1], K[i])<span style=\"margin:0px; padding:0px; font-family:宋体\">的子树；</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\">       8.</span><span style=\"margin:0px; padding:0px; font-family:宋体\">所有叶子结点位于同一层；</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\">       </span><span style=\"margin:0px; padding:0px; font-family:宋体\">如：（</span><strong>M=3</strong><span style=\"margin:0px; padding:0px; font-family:宋体\">）</span>\n    </p>\n    \n    <p align=\"center\" style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px; font-family:宋体\"><img alt=\"\" src=\"http://p.blog.csdn.net/images/p_blog_csdn_net/manesking/4.JPG\" style=\"margin:0px; padding:0px; border:0px\" /></span>\n    </p>\n    \n    <p align=\"left\" style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\">       B-<span style=\"margin:0px; padding:0px; font-family:宋体\">树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果</span></span>\n    </p>\n    \n    <p align=\"left\" style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px; font-family:宋体\">命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为</span>\n    </p>\n    \n    <p align=\"left\" style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px; font-family:宋体\">空，或已经是叶子结点；</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px; text-indent:21pt\">\n      B-<span style=\"margin:0px; padding:0px; font-family:宋体\">树的特性：</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\">       1.</span><span style=\"margin:0px; padding:0px; font-family:宋体\">关键字集合分布在整颗树中；</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\">       2.</span><span style=\"margin:0px; padding:0px; font-family:宋体\">任何一个关键字出现且只出现在一个结点中；</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\">       3.</span><span style=\"margin:0px; padding:0px; font-family:宋体\">搜索有可能在非叶子结点结束；</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\">       4.</span><span style=\"margin:0px; padding:0px; font-family:宋体\">其搜索性能等价于在关键字全集内做一次二分查找；</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\">       5.</span><span style=\"margin:0px; padding:0px; font-family:宋体\">自动层次控制；</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\">       </span><span style=\"margin:0px; padding:0px; font-family:宋体\">由于限制了除根结点以外的非叶子结点，至少含有</span>M/2<span style=\"margin:0px; padding:0px; font-family:宋体\">个儿子，确保了结点的至少</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px; font-family:宋体\">利用率，其最底搜索性能为：</span>\n    </p>\n    \n    <p align=\"center\" style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\"><img alt=\"\" src=\"http://p.blog.csdn.net/images/p_blog_csdn_net/manesking/0.JPG\" style=\"margin:0px; padding:0px; border:0px\" /></span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n          \n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\">       </span><span style=\"margin:0px; padding:0px; font-family:宋体\">其中，</span>M<span style=\"margin:0px; padding:0px; font-family:宋体\">为设定的非叶子结点最多子树个数，</span>N<span style=\"margin:0px; padding:0px; font-family:宋体\">为关键字总数；</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\">       </span><span style=\"margin:0px; padding:0px; font-family:宋体\">所以</span>B-<span style=\"margin:0px; padding:0px; font-family:宋体\">树的性能总是等价于二分查找（与</span>M<span style=\"margin:0px; padding:0px; font-family:宋体\">值无关），也就没有</span>B<span style=\"margin:0px; padding:0px; font-family:宋体\">树平衡的问题；</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\">       </span><span style=\"margin:0px; padding:0px; font-family:宋体\">由于</span>M/2<span style=\"margin:0px; padding:0px; font-family:宋体\">的限制，在插入结点时，如果结点已满，需要将结点分裂为两个各占</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px; font-family:宋体\"></span>M/2<span style=\"margin:0px; padding:0px; font-family:宋体\">的结点；删除结点时，需将两个不足</span>M/2<span style=\"margin:0px; padding:0px; font-family:宋体\">的兄弟结点合并；</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n       \n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n       \n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\"><strong><span style=\"font-size:14px\">B+<span style=\"margin:0px; padding:0px; font-family:宋体\">树</span></span></strong></span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\">       B+</span><span style=\"margin:0px; padding:0px; font-family:宋体\">树是</span>B-<span style=\"margin:0px; padding:0px; font-family:宋体\">树的变体，也是一种多路搜索树：</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\">       1.</span><span style=\"margin:0px; padding:0px; font-family:宋体\">其定义基本与</span>B-<span style=\"margin:0px; padding:0px; font-family:宋体\">树同，除了：</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\">       2.</span><span style=\"margin:0px; padding:0px; font-family:宋体\">非叶子结点的子树指针与关键字个数相同；</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\">       3.</span><span style=\"margin:0px; padding:0px; font-family:宋体\">非叶子结点的子树指针</span>P[i]<span style=\"margin:0px; padding:0px; font-family:宋体\">，指向关键字值属于</span>[K[i], K[i+1])<span style=\"margin:0px; padding:0px; font-family:宋体\">的子树</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px; font-family:宋体\">（</span>B-<span style=\"margin:0px; padding:0px; font-family:宋体\">树是开区间）；</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\">       5.</span><span style=\"margin:0px; padding:0px; font-family:宋体\">为所有叶子结点增加一个链指针；</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\">       6.</span><span style=\"margin:0px; padding:0px; font-family:宋体\">所有关键字都在叶子结点出现；</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\">       </span><span style=\"margin:0px; padding:0px; font-family:宋体\">如：（</span>M=3<span style=\"margin:0px; padding:0px; font-family:宋体\">）</span>\n    </p>\n    \n    <p align=\"center\" style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px; font-family:宋体\"><img alt=\"\" src=\"http://p.blog.csdn.net/images/p_blog_csdn_net/manesking/5.JPG\" style=\"margin:0px; padding:0px; border:0px\" /></span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px; font-family:宋体\">   </span>B+<span style=\"margin:0px; padding:0px; font-family:宋体\">的搜索与</span>B-<span style=\"margin:0px; padding:0px; font-family:宋体\">树也基本相同，区别是</span>B+<span style=\"margin:0px; padding:0px; font-family:宋体\">树只有达到叶子结点才命中（</span>B-<span style=\"margin:0px; padding:0px; font-family:宋体\">树可以在</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px; font-family:宋体\">非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\">       B+</span><span style=\"margin:0px; padding:0px; font-family:宋体\">的特性：</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\">       1.</span><span style=\"margin:0px; padding:0px; font-family:宋体\">所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px; font-family:宋体\">是有序的；</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\">       2.</span><span style=\"margin:0px; padding:0px; font-family:宋体\">不可能在非叶子结点命中；</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\">       3.</span><span style=\"margin:0px; padding:0px; font-family:宋体\">非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px; font-family:宋体\">（关键字）数据的数据层；</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\">       4.</span><span style=\"margin:0px; padding:0px; font-family:宋体\">更适合文件索引系统；比如对已经建立索引的数据库记录，查找10<=id<=20，那么只要通过根节点搜索到id=10的叶节点，之后只要根据叶节点的链表找到第一个大于20的就行了，比B-树在查找10到20内的每一个时每次都从根节点出发查找提高了不少效率。</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n        \n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\"><strong><span style=\"font-size:14px\">B*<span style=\"margin:0px; padding:0px; font-family:宋体\">树</span></span></strong></span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\">       </span><span style=\"margin:0px; padding:0px; font-family:宋体\">是</span>B+<span style=\"margin:0px; padding:0px; font-family:宋体\">树的变体，在</span>B+<span style=\"margin:0px; padding:0px; font-family:宋体\">树的非根和非叶子结点再增加指向兄弟的指针；</span>\n    </p>\n    \n    <p align=\"center\" style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px; font-family:宋体\"><img alt=\"\" src=\"http://p.blog.csdn.net/images/p_blog_csdn_net/manesking/6.JPG\" style=\"margin:0px; padding:0px; border:0px\" /></span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px; font-family:宋体\">   </span>B*<span style=\"margin:0px; padding:0px; font-family:宋体\">树定义了非叶子结点关键字个数至少为</span>(2/3)xM<span style=\"margin:0px; padding:0px; font-family:宋体\">，即块的最低使用率为</span>2/3\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px; font-family:宋体\">（代替</span>B+<span style=\"margin:0px; padding:0px; font-family:宋体\">树的</span>1/2<span style=\"margin:0px; padding:0px; font-family:宋体\">）；</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\">       B+</span><span style=\"margin:0px; padding:0px; font-family:宋体\">树的分裂：当一个结点满时，分配一个新的结点，并将原结点中</span>1/2<span style=\"margin:0px; padding:0px; font-family:宋体\">的数据</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px; font-family:宋体\">复制到新结点，最后在父结点中增加新结点的指针；</span>B+<span style=\"margin:0px; padding:0px; font-family:宋体\">树的分裂只影响原结点和父</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px; font-family:宋体\">结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\">       B*</span><span style=\"margin:0px; padding:0px; font-family:宋体\">树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px; font-family:宋体\">数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px; font-family:宋体\">（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px; font-family:宋体\">间增加新结点，并各复制</span>1/3<span style=\"margin:0px; padding:0px; font-family:宋体\">的数据到新结点，最后在父结点增加新结点的指针；</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\">       </span><span style=\"margin:0px; padding:0px; font-family:宋体\">所以，</span>B*<span style=\"margin:0px; padding:0px; font-family:宋体\">树分配新结点的概率比</span>B+<span style=\"margin:0px; padding:0px; font-family:宋体\">树要低，空间使用率更高；</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n        \n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px; font-family:宋体\"><span style=\"margin:0px; padding:0px\"><strong><span style=\"font-size:14px\">小结</span></strong></span></span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\">       B</span><span style=\"margin:0px; padding:0px; font-family:宋体\">树：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px; font-family:宋体\">走右结点；</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\">       B-</span><span style=\"margin:0px; padding:0px; font-family:宋体\">树：多路搜索树，每个结点存储</span>M/2<span style=\"margin:0px; padding:0px; font-family:宋体\">到</span>M<span style=\"margin:0px; padding:0px; font-family:宋体\">个关键字，非叶子结点存储指向关键</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px; font-family:宋体\">字范围的子结点；</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\">       </span><span style=\"margin:0px; padding:0px; font-family:宋体\">所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\">       B+</span><span style=\"margin:0px; padding:0px; font-family:宋体\">树：在</span>B-<span style=\"margin:0px; padding:0px; font-family:宋体\">树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px; font-family:宋体\">中出现，非叶子结点作为叶子结点的索引；</span>B+<span style=\"margin:0px; padding:0px; font-family:宋体\">树总是到叶子结点才命中；</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px\">       B*</span><span style=\"margin:0px; padding:0px; font-family:宋体\">树：在</span>B+<span style=\"margin:0px; padding:0px; font-family:宋体\">树基础上，为非叶子结点也增加链表指针，将结点的最低利用率</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px; font-family:宋体\">从</span>1/2<span style=\"margin:0px; padding:0px; font-family:宋体\">提高到</span>2/3<span style=\"margin:0px; padding:0px; font-family:宋体\">；</span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px; font-family:宋体\"><br /> </span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px; font-family:宋体\"><strong><span style=\"font-size:14px\">B+/B*<span style=\"color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px\">Tree</span>应用</span></strong></span>\n    </p>\n    \n    <p style=\"margin:10px auto; padding-top:0px; padding-bottom:0px\">\n      <span style=\"margin:0px; padding:0px; font-family:宋体\"></span>\n    </p>\n    \n    <p style=\"color:rgb(51,51,51); font-family:Arial; font-size:14.3999996185303px; line-height:26px\">\n      数据库索引--<span style=\"color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px\">索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。</span>\n    </p>\n    \n    <p style=\"color:rgb(51,51,51); font-family:Arial; font-size:14.3999996185303px; line-height:26px\">\n      <span style=\"color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px\">数据库索引--</span><span style=\"color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px\"><span style=\"color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px\">表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键。</span></span><br />\n    </p>\n    \n    <p style=\"color:rgb(51,51,51); font-family:Arial; font-size:14.3999996185303px; line-height:26px\">\n      倒排索引--也可以由<span style=\"color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px\">B树及其变种实现但</span>不一定非要<span style=\"color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px\">B树及其变种实现</span>，如<span style=\"font-family:verdana; font-size:14.3999996185303px; line-height:17.9200000762939px\">lucene没有使用B树结构，因此lucene可以用二分搜索算法快速定位关键词</span><span style=\"font-family:verdana; font-size:14.3999996185303px; line-height:17.9200000762939px\">。</span><span style=\"font-family:verdana; font-size:14.3999996185303px; line-height:17.9200000762939px\">实现时，lucene将下面三列分别作为词典文件（Term Dictionary）、频率文件(frequencies)、位置文件 (positions)保存。其中词典文件不仅保存有每个关键词，还保留了指向频率文件和位置文件的指针，通过指针可以找到该关键字的频率信息和位置信息。 　　</span>\n    </p>\n    \n    <p style=\"color:rgb(51,51,51); font-family:Arial; font-size:14.3999996185303px; line-height:26px\">\n    </p>\n  </div>\n </div>\n\n [1]: http://en.wikipedia.org/wiki/Skip_list\n [2]: http://dl2.iteye.com/upload/attachment/0056/5664/f4c149bd-d8ea-39ff-813f-93d809c90966.jpg\n [3]: http://m.blog.csdn.net/blog/duheaven/30970839\n [4]: http://www.spongeliu.com/63.html\n [5]: http://images.51cto.com/files/uploadimg/20110408/1620170.png\n [6]: http://pic002.cnblogs.com/images/2011/330710/2011120115382993.png\n [7]: http://p.blog.csdn.net/images/p_blog_csdn_net/manesking/4.JPG\n [8]: http://p.blog.csdn.net/images/p_blog_csdn_net/manesking/5.JPG\n [9]: http://hi.csdn.net/attachment/201106/8/8394323_1307512429kp03.jpg","categories":["Code"],"tags":["数据结构","笔记"]},{"title":"主流图片加载库所使用的预解码究竟干了什么","url":"/2019/01/18/%E4%B8%BB%E6%B5%81%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%BA%93%E6%89%80%E4%BD%BF%E7%94%A8%E7%9A%84%E9%A2%84%E8%A7%A3%E7%A0%81%E7%A9%B6%E7%AB%9F%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88/","content":"\n# 主流图片加载库所使用的预解码究竟干了什么\n\n> 很多图片库，都会有一个类似叫做Force-Decode，Decode For Display之类的感念，很多人可能对这个过程到底是为了解决什么问题不清楚，这里写一个文章来说明它。\n\n这里列举了各个图片库各自的说法，其实讲的都是完全相同的一个概念。\n\n+ [SDWebImage](https://github.com/SDWebImage/SDWebImage/)：使用了`forceDecode`, `decompressImages`的概念\n+ [YYWebImage](https://github.com/ibireme/YYWebImage)：使用了`decodeForDisplay`的概念\n+ [Kingfisher](https://github.com/onevcat/Kingfisher)：使用了`backgroundDecode`的概念\n\n# 为什么需要这个过程，解决了什么问题\n\n为了解释这个过程具体的解决问题，需要至少了解苹果的系统解码器的工作流程。\n\n## Image/IO和惰性解码\n\n[Image/IO库](https://developer.apple.com/documentation/imageio)是苹果提供的，跨所有Apple平台的系统解码器，支持常见的各种图像格式（JPEG/PNG/TIFF/GIF/HEIF/BMP等）的编码和解码。同时，有丰富的接口来和诸如Core Graphics库协作。\n\n常见的网络图像解码，由于拿到的是一个压缩格式，肯定需要想办法转换到对应的UIImage。UIImage可以分为CGImage-based和CIImage-based，后者相对开销大一些，主要是用作滤镜等处理，不推荐使用。所以基本上各种图片库解码，为了解码压缩格式，得到一个CGImage，都是用了Image/IO的这个API：\n\n[CGImageSourceCreateImageAtIndex](https://developer.apple.com/documentation/imageio/1465011-cgimagesourcecreateimageatindex?language=objc)\n\n实际上，Image/IO，除了调用具体的解码器产生图像的Bitmap以外，为了和Core Graphics库协作，也直接以CGImage这个数据结构来传递，但是他采取了一种惰性解码的创建方式。因此这里首先要了解CGImage初始化的接口和对应的行为：\n\n[CGImageCreate](https://developer.apple.com/documentation/coregraphics/1455149-cgimagecreate?language=objc)\n\n这里面其他参数都好理解，具体看一个`provider`参数，这里面需要传入一个`CGDataProviderRef`，它是一个关于描述怎么样去获取这个Bitmap Buffer二进制数据的结构。再来看看CGDataProvider的初始化方法，这时候发现它有多种初始化方式，决定了后面的行为。\n\n+ [CGDataProviderCreate](https://developer.apple.com/documentation/coregraphics/cgdataprovider/1805224-cgdataprovidercreate)\n\n这个方法，允许接受一个`CGDataProviderCallbacks`参数，看说明，可以知道，这个callbacks是一系列函数指针回调，目的是提供一个sequential-access的访问模式，同时Data Buffer会被copy出去。同时，由于传入的是callbacks，可以做到不立即提供Data Buffer，而是在未来需要的时候再触发。\n\n+ [CGDataProviderCreateDirect](https://developer.apple.com/documentation/coregraphics/1408282-cgdataprovidercreatedirect?language=objc)\n\n这个方法，类似于`CGDataProviderCreate`，但是注明了这个callbacks生成的Data Buffer不会被Copy，Core Graphics只会直接访问返回的Data Buffer指针，需要自己管理好内存。\n\n+ [CGDataProviderCreateWithData](https://developer.apple.com/documentation/coregraphics/1408288-cgdataprovidercreatewithdata?language=objc)\n\n这个方法，需要提供一个CFData，同时也不会Copy这个CFData。在Release的同时由Core Graphics自动释放CFData的内存，开发者不需要管理内存。\n\n剩余的具体初始化方法可以看文档说明，总而言之，CGDataProvider提供了各种各样的访问模式\u0010，如直接访问，拷贝访问，惰性访问等。而现在问题就来了，前面说到，Image/IO创建CGImage的时候，也需要提供一个DataProvider来指明图像的Bitmap Buffer数据从哪里获取，它是具体用了什么方式呢？\n\n答案是使用了一个私有API`CGImageCreateWithImageProvider`，经过查看，这个方式实际类似`CGDataProviderCreateDirect`，也就是通过一组callbacks，提供了一个直接访问，允许惰性提供Data Buffer的方式。换句话说，这也就意味着，Image/IO，其实采取的是一种惰性解码方式。解码器只预先扫描一遍压缩格式的容器，提取元信息，但是不产生最终的Bitmap Buffer，而是通过惰性回调的方式，才生成Bitmap Buffer。\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/2019/01/18/15477913743261.jpg)\n\n\n换句话说，通过所有`CGImageSourceCreateImageAtIndex`这种API生成的CGImage，其实它的backing store（就是Bitmap）还没有立即创建，他只是一个包含了一些元信息的空壳Image。这个CGImage，在最终需要获取它的Bitmap Buffer的时候（即，通过相应的API，如`CGDataProviderCopyData`，`CGDataProviderRetainBytePtr`），才会触发最后的Bitmap Buffer的创建和内存分配。\n\n## Image/IO和Force Decode\n\n理解到上面Image/IO的惰性解码行为，理解了上面一点，现在说明Force Decode所解决的问题。\n\n众所周知，iOS应用的渲染模式，是完全基于Core Animation和CALayer的（macOS上可选，另说）。因此，当一个UIImageView需要把图片呈现到设备的屏幕上时候，其实它的Pipeline是这样的：\n\n1. 一次Runloop完结 -> \n2. Core Animation提交渲染树CA::render::commit ->\n3. 遍历所有Layer的contents ->\n4. UIImageView的contents是CGImage ->\n5. 拷贝CGImage的Bitmap Buffer到Surface（Metal或者OpenGL ES Texture）上 ->\n6. Surface（Metal或者OpenGL ES）渲染到硬件管线上\n\n这个流程看起来没有什么问题，但是注意，Core Animation库自身，虽然支持异步线程渲染（在macOS上可以手动开启），但是UIKit的这套内建的pipeline，全部都是发生在主线程的。\n\n因此，当一个CGImage，是采取了惰性解码（通过Image/IO生成出来的），那么将会在主线程触发先前提到的惰性解码callback（实际上Core Animation的调用，触发了一个`CGDataProviderRetainBytePtr`），这时候Image/IO的具体解码器，会根据先前的图像元\u0010信息，去分配内存，创建Bitmap Buffer，这一步骤也发生在主线程。\n\n![屏幕快照 2019-01-18 下午1.44.45](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/2019/01/18/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-18%20%E4%B8%8B%E5%8D%881.44.45.png)\n\n这个流程带来的问题在于，主线程过多的频繁操作，会造成渲染帧率的下降。实验可以看出，通过原生这一套流程，对于一个1000*1000的PNG图片，第一次滚动帧率大概会降低5-6帧（iPhone 5S上当年有人的测试）。后续帧率不受影响，因为是惰性解码，解码完成后的Bitmap Buffer会复用。\n\n所以，最早不知是哪个团队的人（可能是[FastImageCache](https://github.com/path/FastImageCache)，不确定）发现，并提出了另一种方案：通过预先调用获取Bitmap，强制Image/IO产生的CGImage解码，这样到最终渲染的时候，主线程就不会触发任何额外操作，带来明显的帧率提升。后面的一系列图片库，都互相效仿，来解决这个问题。\n\n具体到解决方案上，目前主流的方式，是通过CGContext开一个额外的画布，然后通过`CGContextDrawImage`来画一遍原始的空壳CGImage，由于在`CGContextDrawImage`的执行中，会触发到`CGDataProviderRetainBytePtr`，因此这时候Image/IO就会立即解码并分配Bitmap内存。得到的产物用来真正产出一个CGImage-based的UIImage，交由UIImageView渲染。\n\n## ForceDecode的优缺点\n\n上面解释了ForceDecode具体解决的问题，当然，这个方案肯定存在一定的问题，不然苹果研发团队早已经改变了这套Pipeline流程了\n\n### 优点\n\n+ 可以提升，图像第一次渲染到屏幕上时候的性能和滚动帧率\n\n\n### 缺点\n\n+ 提前解码会立即分配Bitmap Buffer的内存，增加了内存压力。举例子对于一张大图（2048*2048像素，32位色）来说，就会立即分配16MB(2048 * 2048 * 4 Bytes)的内存。\n\n由此可见，这是一个拿空间换时间的策略。但是实际上，iOS设备早期的内存都是非常有限的，UIKit整套渲染机制很多地方采取的都是时间换空间，因此最终苹果没有使用这套Pipeline，而是依赖于高性能的硬件解码器+其他优化，来保证内存开销稳定。当然，作为图片库和开发者，这就属于仁者见仁的策略了。如大量小图渲染的时候，开启Force Decode能明显提升帧率，同时内存开销也比较稳定。\n\n## WebP和软件解码\n\n当我们说完Image/IO系统库和Force Decode关系后，再来看看另一种情形。近些年来，一些新兴的图像压缩格式，如[WebP](https://developers.google.com/speed/webp/)，得益于开源，高压缩率，更好的动图支持，得到了很多开发者青睐。\n\n然而，这些图像格式，并没有被iOS系统解码器所支持，也没有对应的硬件解码。因此，现有的图片库在支持新图像格式的时候，都采取了使用CPU进行软件解码来处理。这些软件解码器，大部分是为了跨平台而实用的，因此，一般都有一个接口直接产出一个Bitmap Buffer来用于渲染。如WebP的官方解码器libwebp，就有这样一个接口：\n\n```c\nWEBP_EXTERN VP8StatusCode WebPDecode(const uint8_t* data, size_t data_size, WebPDecoderConfig* config);\n```\n\n上面我们知道CGImage和CGDataProvider的不同初始化方式，开发者面临这样的接口，有两个选择：\n\n1. 使用CGDataProviderCreateWithData，直接把产出的Bitmap buffer存储到CGImage中\n2. 参考Image/IO，使用CGDataProviderCreateDirect，使用惰性解码\n\n当然，为了最大程度的利用苹果系统的那套Pipeline和现有代码流程，第一直觉的使用方式当然是方案2。然而，理想是丰满的，现实是骨感的。之所以Image/IO能够采取惰性解码这一套流程，最大的原因在于**Image/IO的原生图像格式都是硬件解码，且解码速度足够快**\n\n同样的方式，套用到WebP上，反而会带来更大的问题。首先，WebP格式自身的压缩算法采取了VP8，比起JPEG/GIF的压缩算法要复杂的多，开销大。第二，libwebp只有软件解码的实现，无法利用硬件来加快解码速度。\n\n注：YY的作者有专门跑过测试，对于iPhone 6上，同样压缩比的有损JPEG和WebP相比，解码速度慢大概50%-100%，无损的PNG和WebP相比比较接近。参考：https://blog.ibireme.com/wp-content/uploads/2015/11/image_benchmark.xlsx\n\n\n所以，主流图片库最终的选择方式，都是方案1，即立即生成了一个含有Bitmap Buffer的CGImage。这样，到最终UIImageView渲染的时候，也不会有额外的主线程解码的开销，除了需要提前分配内存以外别的还好。\n\n## WebP软件解码和Force Decode\n\n前面说到，对于WebP等非硬件解码器支持的图片压缩格式，大多数图片库采取了方案1。但是现有的一些图片库（如SDWebImage/YYWebImage），仍然对这个非空壳的CGImage，执行了Force Decode的过程，按理论上说已经有了Bitmap Buffer，不会触发主线程解码，这又是为什么？\n\n这个原因，是源于先前的Force Decode的实现机制，利用到了`CGContextDrawImage`这个接口。\n\n`CGContextDrawImage`，内部实现非常复杂，因为对于一个CGImage来说，他只是Bitmap Buffer+图像元信息的合集，但是一个CGContext，是有一个固定的ColorSpace，渲染模式等等信息，是和具体的上下文相关的。\n\n因此，当通过这个API画在一个画布上时，会触发很多细节的逻辑，这里举几个比较有影响的。\n\n1. 首先会根据CGImage的ColorSpace转换到CGContext的ColorSpace（比如说CGImage使用了sRGB，CGContext用了P3+宽色域），需要去对Bitmap的每个像素做转换；如果Bitmap排列（如CGImage采取RGB888，CGContext采取BGRA8888）不同，也会以CGContext为准进行转换。\n2. CGContext如果有Blend Mode，也会在此流程中做Alpha合成。\n3. 如果CGContext和大小和CGImage不同，会触发对应的重采样过程，开发者可以控制重采样的质量高低\n4. 还有一个关于内存管理的，由于CGContext目标就是为了做渲染层，因此它依赖这个假设，当你调用`CGContextDrawImage`的时候，会直接把取到的Bitmap Buffer，立马提交到render server进程上（通过mmap），这样最后在渲染Pipeline（前文提到）中，就可以省去第5步（拷贝CGImage的Bitmap Buffer到Surface（Metal或者OpenGL ES Texture）上）。见下：\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/2019/01/18/Lark20190118-134314.png)\n\n\n其实对于大部分图片库的Force Decode来说，因为都开的是一个和CGImage同大小的空白画布，这里主要是第1和第4项会影响到性能。一些图片库，因此依旧保留了Force Decode的流程，也有各种各样的具体缘由。\n\n## WebP软件解码进行Force Decode的优缺点\n\n了解了为什么对于WebP等软件解码，依然使用Force Decode的缘由，再来看看这种Case下的优缺点\n\n### 优点\n1. 能够提前把Bitmap Buffer转移到渲染进程上，减少了未来渲染时的内存拷贝操作（虽然比起解码来说，这部分时间相当的小）\n2. 如果原始解码出来的Bitmap Buffer，iOS硬件屏幕不直接支持（如RGB888，CMYK），会提前转换好，避免渲染时主线程的转换\n3. （？）可以从Xcode视觉上看起来App占用内存变小，因为Bitmap Buffer提前拷贝到render进程了\n\n### 缺点\n\n1. 在已经有Bitmap Buffer的情况下，再开一个画布，并触发Draw，大图会出现一个临时的内存峰值（约250%~300%原始Bitmap Buffer的占用）\n\n可以看出，这也是一个类似空间换时间的策略。当然，这个策略的优势没有Image/IO那样大，因为实际上转换和拷贝内存的性能开销，比起解码和创建Bitmap Buffer都是非常低的。但是一些图片库把这个选择权利交给了用户，而自己不做这个策略选择。\n\nPS小轶闻：SDWebImage其实最早只有对Image/IO的那个ForceDecode流程，后来在4.0加入WebP支持的时候，也不清楚这个流程影响，顺便就一块使用这套流程了。可以说是所谓的误打误撞。\n\n# 总结\n\n这篇文章基本介绍了Image/IO的惰性解码流程，以及Force Decode这套流程它所解决的问题，以及优缺点。无论对图片库作者，还是图片库进阶使用者，都解释了相关的疑问。希望对图片编解码方向有兴趣的同学可以多多学习交流。\n\n","categories":["iOS"],"tags":["iOS","Image"]},{"title":"偶然发现的，关于C++指针的一点注意事项","url":"/2016/03/30/%E5%81%B6%E7%84%B6%E5%8F%91%E7%8E%B0%E7%9A%84%EF%BC%8C%E5%85%B3%E4%BA%8EC-%E6%8C%87%E9%92%88%E7%9A%84%E4%B8%80%E7%82%B9%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","content":"\nC++的指针是大一时期一直觉得头疼的一个东西。当年一直对指针敬而远之。一旦不小心，指针越界的后果就是程序崩溃……> <\n\n然而，偶然一次学妹问到关于动态数组的问题的时候……才偶然发现当年自己学指针似乎一直没有搞清楚这两者的关系：\n\n`pointer`和`pointer[i]`\n\n比如实现一个简单的动态数组，举例就是看如下代码：\n\n第一种方法：\n\n```cpp\n#include <iostream>\n\nusing namespace std;\nint main(int argc, char *argv[]) {\n\tint arrayInput;\n\tint arraySize = 0;\n\tint* arrayPointer;\n\tcout<<\"依次输入数字到这个数组中，输入EOF（Windows下为Ctrl＋Z，Unix/Linux下为Ctrl+D）来停止输入\"<<endl;\n\twhile(cin>>arrayInput){\n\t\tarrayPointer[arraySize] = arrayInput;\n\t\tarraySize++;\n\t}\n\tcout<<\"现在输出数组中元素\"<<endl;\n\tfor(int i = 0;i<arraySize;i++){\n\t\tcout<<i<<\"元素: \"<<arrayPointer[i]<<\" \";\n\t}\n}\n```\n\n第二种方法：\n\n```cpp\n#include <iostream>\n\nusing namespace std;\nint main(int argc, char *argv[]) {\n\tint arrayInput;\n\tint arraySize = 0;\n\tint* arrayPointer;\n\tcout<<\"依次输入数字到这个数组中，输入EOF（Windows下为Ctrl＋Z，Unix/Linux下为Ctrl+D）来停止输入\"<<endl;\n\twhile(cin>>arrayInput){\n\t\t*(arrayPointer+arraySize) = arrayInput;\n\t\tarraySize++;\n\t}\n\tcout<<\"现在输出数组中元素\"<<endl;\n\tfor(int i = 0;i<arraySize;i++){\n\t\tcout<<i<<\"元素: \"<<*(arrayPointer+i)<<\" \";\n\t}\n}\n```\n\n直到写完了，才发现自己其实一直没有搞懂，这种arrayPointer[i]表示什么。于是做了一个测试～\n\n```cpp\ncout<<\"现在输出数组中元素\\n第一种：\"<<endl;\nfor(int i = 0;i<arraySize;i++){\n\tcout<<i<<\"元素: \"<<arrayPointer[i]<<\" \";\n}\ncout<<\"\\n第二种：\"<<endl;\nfor(int i = 0;i<arraySize;i++){\n\tcout<<i<<\"元素: \"<<*(arrayPointer + i)<<\" \";\n}\n```\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/c/b8/7d8680b175f4e74b2de45bd2733e2.png)\n\n试验了一下，才发现，其实arrayPointer[i] 和*(arrayPointer + i) 是等价的，前者是代表从arrayPointer的首地址开始计数，而arrayPointer[0]代表就是arrayPointer指向的地址所对应的值。这一点应该注意一下（其实以前觉得数组和指针挺像的，但是从这一点就知道数组绝对是指针的一小部分子集）。\n\n\n给自己提个醒吧－ －顺便怀念一下远去的C++。","categories":["C++"],"tags":["C++"]},{"title":"分享一下Java作业－Swing开发的计算器","url":"/2016/03/29/%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%8BJava%E4%BD%9C%E4%B8%9A%EF%BC%8DSwing%E5%BC%80%E5%8F%91%E7%9A%84%E8%AE%A1%E7%AE%97%E5%99%A8/","content":"\n上周我们Java课程老师要求我们用Swing来开发一个计算器。\n\n说起来图形化的开发，我最早用的应该就是MFC了，当时就只会拖一下控件，然后双击一下写函数……改改属性什么的……\n\n其次接触到了Qt，是在我们大二上实训的时候。那个时候要求我们做一个Qt跨平台的聊天工具，我们最后的效果差不多就是这样，代码放在了GitHub：\n\nhttps://github.com/lizhuoli1126/SEU-Chat\n\n接下来，由于要加入到学校的一个组织（[先声网](http://herald.seu.edu.cn/index/)），于是又做了一款简单的Android下的天气应用，接触到了Android开发使用的XML来布局的方法。（为什么Qt不允许手动修改XML里面的内容啊啊啊！）\n\n之后，又做起了iOS开发，发现Xcode的图形化真是赞。无论是Storyboard还是Xib，都既能很好的支持图形化空间，又能手动编辑，而且那种按Control拖拽关联代码和图形空间的方式很有意思，也很有效率。于是就按照教程写了一个小的游戏……（之后会有文章说明）\n\n于是，问题来了，我为什么要说前面这么多呢，那是因为：Swing必须得手动写代码布局啊啊啊！（回声～）\n\n最开始用的是Eclipse，按照老师的方法，手写Java代码来进行界面布局，于是，你就得写几行代码跑一下，看看布局，再改再跑………………折腾了几次之后崩溃，想着必须得找解决办法。\n\n百度一下，就发现了Netbeans这款神器，建Java应用－添加JFrame，然后一个熟悉的GUI空间界面就出现了T.T（拖控件其实相当于在Java代码中自动写进去布局代码）终于可以愉快的玩耍了……\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/a/3c/3bfdef0a075c8130da1ba2fafd3b4.png)\n\n最终的成品就是这个样子（做得不好别打我，代码也不上传了）：\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/0/31/6e31b3c293f2be8bd75da3c977780.png)\n\n说这么多，其实我就是想说Java的Swing并没有提供一个把代码和布局通过灵活方式分开的方法（GUI之所以叫GUI，我认为这是一种交互方式，如果用CLI的交互方式开发GUI程序，这绝对产生不出完美的产品）。如果你们有什么想法或者吐槽的地方，尽情说出来吧！评论就有礼品送。:-P","categories":["Java"],"tags":["Java"]},{"title":"发现iOS SDK的Bug - Hopper使用教程向","url":"/2019/06/13/%E5%8F%91%E7%8E%B0iOS-SDK%E7%9A%84Bug-Hopper%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%E5%90%91/","content":"\n# Hopper简介\n\nHopper，全称Hopper Disassembler，是一个macOS和Linux平台上的反汇编IDE。提供了诸如伪代码，子程序，脚本，Debugger，Hex编辑等等一些列工具。相比于其他知名的反汇编工具如[IDA](https://www.hex-rays.com/products/ida/)，最大的好处是对平台特性，也就是Objective-C的反汇编有优化，提供非常贴近原始代码的伪代码（IDA目前则会是保留诸如objc_msgSend的伪代码），并且新版本也对Swift提供了一定的反汇编符号优化，因此作为探究iOS平台上的SDK实现，可以说是一利器。\n\n# Hopper安装\n\nHopper本身目前是收费的软件，提供了免费的使用（30分钟）。官方下载地址为：[https://www.hopperapp.com](https://www.hopperapp.com/)\n\nMac版本后解压，拖到Application下即可使用。\n\n对于个人使用，价格不菲，有两种方案，个人比较推荐第一种\n\n+ Per User：收费为¥700，允许同一时间唯一激活，不绑定机器硬件\n+ Per Computer，收费¥900，和一台电脑的机器硬件绑定\n\n对于只是尝鲜或者轻度使用，其实使用免费版即可。网上现在也有针对旧版本的Cracked版本，不过存在一些问题和崩溃。如果是在需要，可尝试[链接](https://xclient.info/s/hopper-disassembler.html)\n\n# Hopper使用\n\nHopper提供了一个教程，可以参考[官方简易教程](https://www.hopperapp.com/tutorial.html)\n\n针对我们的场景：分析iOS的SDK内实现或者问题，我这里提供了一个Step By Step的过程，教你如何查找问题。\n\n## 获取需要反汇编的二进制文件\n\n首先，我们需要获取一份iOS SDK的二进制Mach-O文件。最简单的方式，是通过Xcode提供的iPhone模拟器去获取它。在获取之前，我们先了解一下iOS SDK对应的二进制文件路径。\n\n+ Xcode自带模拟器，对应系统根路径：\n\nXcode 11:\n\n`/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Library/Developer/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot`\n\nXcode 10:\n\n`/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/`\n\n+ 已下载的历史版本固件的模拟器，对应系统根路径，自己根据版本版本修改中间的数字：\n\n`/Library/Developer/CoreSimulator/Profiles/Runtimes/iOS\\ 11.4.simruntime/Contents/Resources/RuntimeRoot/`\n\n+ 真机的系统根路径，不用说了吧：\n\n`/`\n\niOS 系统提的库和二进制，可以简单分以下几类，按照需要选择对应的相对根路径：\n\n+ 公开Framework: `/System/Library/Framework`\n+ 私有Framework：`/System/Library/PrivateFrameworks`\n+ 系统App：`/Applications`\n+ UNIX动态库: `/usr/lib`\n\n这里我们以Xcode 10自带的iOS 12 SDK，UIKitCore为例（注意，UIKit从iOS 12开始，为了支持部署到macOS，将代码基本全盘移动到了私有Framework的UIKitCore.framework中，UIKit.framework只是一个外层的壳），我们就能直接去访问这个路径，获取它的Mach-O二进制：\n\n`/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/System/Library/PrivateFrameworks/UIKitCore.framework/UIKitCore`\n\n一般来说，iPhone模拟器提供的二进制Mach-O即可够用，虽然它实际上是x86_64架构的编译产物，但是基本上的逻辑和真机上是一致的。如果涉及到需要只能在真机可用的库，如AVFoundation的摄像机，建议可以从真机中提取（也可以从iOS的IPSW固件中提取），见下文。\n\n\n### 真机获取系统库的二进制文件\n\n### 获取dyld shared cache\n\n在真机上，为了加快动态库的加载，并减少iOS 占用磁盘的体积，dyld采取了一个缓存，将多个Mach-O文件合并到一起，由系统启动后就预热。因此，实际上系统库（公开和私有）的路径上，只有Framework和其中的资源文件，却没有对应的Mach-O二进制。我们需要首先获取到这个cache，然后解压出来对应的二进制。参考[dyld_shared_cache](https://iphonedevwiki.net/index.php/Dyld_shared_cache)\n\n对应dyld shared cache路径（以arm64机器为例）：`/System/Library/Caches/com.apple.dyld/dyld_shared_cache_arm64`\n\n当然，除了使用已经越狱的真机，我们还可以通过IPSW，即iOS的固件包，来直接提取对应的dyld shared cache，并解压得到对应的Mach-O文件。\n\nIPSW可以从这个[网页](https://ipsw.me/)上下载，选择你的设备以及iOS版本号，就可以下载对应的IPSW文件。\n\n将下载的IPSW解压（建议使用zip命令行，或者BetterZip之类的解压软件，Mac自带的解压似乎会报错），可以找到一个最大容量的DMG文件，双击即可加载\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/2019/06/13/15604236336003.jpg)\n\n加载后就是完整的iOS系统根路径了，从对应路径下找到dyld shared cache。\n\n### 解压dyld shared cache\n\n为了解压dyld shared cache，市面上一些工具其实早已过期，要么不支持arm64，要么存在Bug。但实际上，Apple自己开源的dyld源代码，就已经包含了这样一个命令行工具，叫做`dsc_extractor`，我们这里直接用来源码来编译一份来使用即可。\n\n进入[opensource.apple.com](https://opensource.apple.com/，)选择最新的macOS的版本，我这里例子使用的是我写这篇文章最新公开的 [macOS 10.14.1](https://opensource.apple.com/release/macos-10141.html)\n\n然后下载两份代码，一份是[dyld](https://opensource.apple.com/tarballs/dyld/dyld-635.2.tar.gz)，一份是[CommonCrypto](https://opensource.apple.com/tarballs/CommonCrypto/CommonCrypto-60118.220.1.tar.gz)\n\n为了编译，需要一点小技巧，但是对于iOS开发者我觉得挺简单\n\n1. 用Xcode，打开dyld代码中的`dyld.xcodeproj`\n2. 修改Build Settings中，把对应的Base SDK，从`macosx.internal`改成公开的`macOS`\n3. 进入`dsc_extractor.cpp`，看到最后有一个`test program`，把上面的`#if 0`改成`#if 1`\n4. 我在编译新版本时发现依赖了一个叫做`CommonDigestSPI.h`的私有头文件，这个在下载的CommonCrypto工程中，拖进来改一下引用方式即可\n5. 选择`dsc_extractor`，Archive得到一个产物，叫做`dsc_extractor.bundle`，然而他实际就是一个Mach-O二进制，直接删掉后缀，chmod+x，即可使用\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/2019/06/13/15604271114928.jpg)\n\n如果上面的编译比较麻烦，可以直接下载我这里编译好的一份二进制，然后放到你的PATH路径下：[dsc_extractor](https://raw.githubusercontent.com/dreampiggy/dsc_extractor/master/bin/dsc_extractor)\n\n然后我们可以使用`dsc_extractor`来解压我们提取到的dyld shared cache，很简单的命令\n\n```\ndsc_extractor ./dyld_shared_cache_arm64e ./output\n```\n\n会得到所有dyld shared cache中的二进制Mach-O文件，按照路径排列，然后我们就可以用自己想反编译的库，如UIKitCore，来使用Hopper了。\n\n\n## 载入Hopper\n\n现在我们已经有了一个UIKitCore的Mach-O文件了，我们打开Hopper来载入它。我们可以使用Command+Shift+O来选择一个Mach-O文件，也可以将文件拖动到Hopper界面上来打开。\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/2019/06/13/15604335461822.jpg)\n\n载入Mach-O文件后，Hopper会弹出框来选择具体分析的内容，大部分情况直接确认即可。如果是分析其他类型的文件，可能有特例如下：\n\n+ 分析一个.a或者.dylib，并且该二进制由多个.a或者.dylib合成，这时候会提示你选择具体的某个编译产物\n+ 分析一个FAT Binary，这时候会提示你选择具体的某一个架构的文件\n\n载入开始后，一般需要等待一段时间来分析（下方会有进度条），等待分析完成后，你可以将当前分析的结果，保存成一个`.hop`结尾的文件，未来就不再需要分析了，非常有用（注：免费版不可用）。\n\n## 符号分析\n\n左侧有一个符号框，从左到右依次表示：\n\n+ Labels: C/C++Objective-C的符号，包括类名，方法名，全局变量等\n+ Proc：子程序，对应C/C++的函数，Objective-C的方法，Block代码段等\n+ Str：常量段，包括了所有C/C++Objective-C字面量，即代码中直接用`@\"\", \"\"`写的内容\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/2019/06/13/15592985644004.jpg)\n\n每项内容都支持搜索，一般来说取决于我们要解决的问题，有大概几个场景\n\n1. 分析特定方法的实现：使用Proc搜索\n2. 运行时抛出的异常或者Log：使用Str搜索关键字\n3. 得知一个类的所有方法：可以使用Label，但更好的方式是通过Class-dump获取头文件（见下）\n\n## Class-dump与私有头文件\n\n[Class-dump](https://github.com/nygard/class-dump)是一个能够解析Mach-O文件，对应的Objective-C符号，以生成一个完整的头文件的工具。得益于Objective-C运行时和符号的特点，可以方便的还原回基本接近原始的类声明代码。具体使用也很简单，参见项目的Readme，编译得到二进制，放到PATH中，然后执行：\n\n```\nclass-dump UIKitCore.framework -r -o output -H\n```\n\n对于重头戏，关于iOS SDK的所有头文件，早有专人建立了一个在线网站去分析，点击跳转：[iOS Runtime Headers](http://developer.limneos.net/)\n\n在这个网页上，可以支持Framework/类/方法级别的搜索，支持点击头文件跳转链接，非常的方便，一般的分析iOS SDK都可以采取这个网页的结果来辅助分析。\n\n\n## 伪代码分析\n\n当我们了解到需要分析的符号方法后，下一步一般就会进行伪代码分析。在Hopper中，点击到一个子程序入口，然后点击上方的这个像是`if (b)`代码的图标，即可打开伪代码分析框\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/2019/06/13/15592994457947.jpg)\n\n对于简单的代码，我们基本上能够还原回100%可读的Objective-C代码，由于ARC时便一起，我们可以看到对应的Retain和Realse调用\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/2019/06/13/15592995793557.jpg)\n\n\n### 分析调用关系\n\n我们可以通过对应的子程序页面，右键选择\"References To Selector\"，来查看所有对这个Selector的调用。（由于Objective-C运行时的特点，只能是Selector级别的调用，如果有不同类的同名Selector，可以在弹出的窗口中搜索或者依次检查）\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/2019/06/13/15593006542887.jpg)\n\n\n## 常见的分析姿势\n\n### Block\n\nObjective-C会使用到Block，而Block由于其实现原理，会生成对应的C方法，Hopper目前原生解析的Block语法并不是很直观，这里提供一个简单的说明。\n\n其实Hopper反编译出来就是Block实现的原理，如果对于Block实现原理不清楚，建议可以先看一遍[《这个教程》](https://blog.devtang.com/2013/07/28/a-look-inside-blocks/)\n\n### 简单Block\n\n```c\ndispatch_async(dispatch_get_main_queue(), ^{\n    printf(\"%d\", 1);\n});\n```\n\nHopper原生反编译如下，实际Block代码会单独在另一个C方法中，在`block implemented at:`提示对应的方法中\n\n```c\ndispatch_async([objc_retainAutoreleaseReturnValue(*__dispatch_main_q) retain], ^ {/* block implemented at ___29-[ViewController viewDidLoad]_block_invoke */ } });\n\nvoid ___29-[ViewController viewDidLoad]_block_invoke(void * _block) {\n    printf(\"%d\", 0x1);\n    return;\n}\n```\n\n### 捕获变量\n\n如果Block捕获了变量，那么根据Block的实现原理，可以知道这些变量在Block中可见的变量都是被值宝贝，对于NSObject就是指针\n\n如果使用`__block`修饰，那么会保留原始的变量的指针，对于NSObject就是对象指针的指针，我们可以通过这个简单识别。\n\n比如对于这样代码：\n\n```c\nNSObject *obj = [NSObject new];\n__block NSObject *obj2 = [NSObject new];\n[self testBlock:^(int value){\n    NSLog(@\"%@\", obj);\n    obj2 = nil;\n}];\n```\n\n实际反编译出来的结果长这样：\n\n```c\nint ___29-[ViewController viewDidLoad]_block_invoke(int arg0, int arg1) {\n    NSLog(@\"%@\", *(arg0 + 0x20));\n    rax = objc_storeStrong(*(*(arg0 + 0x28) + 0x8) + 0x28, 0x0);\n    return rax;\n}\n```\n\n对应的`arg0`就是第一个参数，而最后参数对应的是`block_impl_0`实现结构体，可以忽略。\n\n\n\n## CGRectMake等inline的C方法\n\n一些带有inline数值计算的方法，会被苹果的clang在编译时优化，实际上并不是你看到的头文件的样子，这种就需要我们枚举出来，人肉还原回他的实现，举个例子：\n\n\n这样的代码：\n\n```c\nCGRect rect = CGRectMake(0, 1, 2, 3);\nNSLog(@\"%@\", NSStringFromCGRect(rect));\n```\n\n反编译结果：\n\n```c\nintrinsic_movsd(xmm1, *double_value_1);\nintrinsic_movsd(xmm2, *double_value_2);\nintrinsic_movsd(xmm3, *double_value_3);\n_CGRectMake(&var_30, _cmd, rdx, rcx);\nNSLog(@\"%@\", [NSStringFromCGRect(*(&var_30 + 0x10), *(&var_30 + 0x18)) retain]);\n```\n\n可以看到有`mov`之类的汇编命令调用，其实这就是为了压栈其实大部分场景我们只要熟悉简单的`mov` `add` `sub` `mul`几个基本的汇编命令的意义即可。\n\n## Swift\n\nSwift作为Apple一致力推的下一代官方编程语言，随着iOS 13的发布，现在已经可以作为第一优先的SDK支持语言了，iOS 13上出现了4个Swift Only的库，因此对于Swift相关的反编译需求，也会慢慢出现。然而，不同于动态性强的Objective-C代码，Swift天生的静态强类型语言特性，造成了相当高的反编译难度（堪比C++开O2优化），在这里基本不细讲，只是大概说一下目前的状况。\n\nHopper从v4开始支持了对Swift符号的符号化，我们不再需要使用swift来反解决mangled的符号名。\n\n由于Swift支持完整的命名空间，查询符号需要带上完整的符号\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/2019/06/13/15604313892455.jpg)\n\n\n同时，Swift由于clang的优化，会讲很多编译器检查到的频繁的代码调用，自动转换为一个以`sub`开头的函数，以减少二进制大小。\n\n对于Swift非`@objc`和`dynamic`的属性和方法，会类似于C++的虚函数表，实际上的调用都是编译器展开的地址偏移，而不像Objective-C那样有符号可查。这种时候我们需要就是类似C++反编译那样，通过分析Swift class或者struct的属性，来对照偏移量得知调用。\n\n对于Swift的会触发运行态的一些语法，需要你对Swift语言实现有了解，比如Protocol Extension Where子句，会生成Protocol Witness，我们可以在Hooper中搜索到它\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/2019/06/13/15604319451736.jpg)\n\n可以看到，目前的Hopper对Swift有相应的支持，但受限于Swift的语言性质很难直观阅读，必要时候还是需要一些汇编，以及传统C++的反编译分析模式去对待它\n\n\n# 总结\n\n这篇教程基本上是从我个人的使用经验来介绍，以工具和流程为主，主要是为了给目标iOS平台，且不是专攻二进制安全的人来阅读。\n\n其实对大部分iOS平台开发者，最主要的目的，其实是为在发现一些iOS SDK表现奇怪的行为，或者Crash时，能够有一定的分析和判断能力，去尝试定位原因，绕过问题，并最终能够有底气，去向Apple提交Bug Report。\n\n反编译本身就是二进制安全中的灰色地带，而且还有类似二进制加固等攻防模式，并不是万能方式去了解一个程序运行的方式。还需要配合自己的编写代码经验，才能更好地解决问题\n\n\n# 参考\n\n+ https://github.com/bartcone/reverse-engineering-blog\n+ http://stevenygard.com/projects/class-dump/\n+ https://worthdoingbadly.com/dscextract/\n+ http://iphonedevwiki.net/index.php/Dyld_shared_cache\n+ http://www.toves.org/books/arm/\n\n","categories":["iOS"],"tags":["iOS","Objective-C","逆向","Hopper"]},{"title":"发誓我不写Monad教程","url":"/2016/03/30/%E5%8F%91%E8%AA%93%E6%88%91%E4%B8%8D%E5%86%99Monad%E6%95%99%E7%A8%8B/","content":"\n> 我保证，不再在网上又发布一篇Monad教程(By Erik Meijer)\n\n自我娱乐，附赠各种Functional with OO，参见[GitHub][1]\n\n```javascript\n//Define\nMonad = function() {\n    this.value = arguments[0];\n};\nMonad.prototype.unit = function (value) {\n    this.value = value;\n    return this;\n}\nMonad.prototype.bind = function (func) {\n    var value = func(this.value);\n    var monad = new Monad(value);\n    return monad;\n}\nMonad.prototype.extract = function () {\n    return this.value;\n}\n\n//Use\nvar monad = new Monad;\nvar monad = new Monad(10);\n\nmonad.unit(20);\nmonad.unit(new Monad(30));\n\nmonad.bind(function (value) { return value });\nvar result = monad.bind(function (value) {\n    return value.extract() * 2;\n})\n\nconsole.log(result.extract());//60\n\n//Test\nvar monad = new Monad;\nmonad.unit(10);\n\nconsole.log(monad.extract());//10\n\nvar firstMonad = monad.bind(function (value) {\n    return value / 2;\n});\n\nconsole.log(firstMonad.extract());//5\n\nvar secondMonad = monad.bind(function (value) {\n    return value + 1;\n}).bind(function (value) {\n    return value + 2;\n}).bind(function (value) {\n    return value + 3;\n});\n\nconsole.log(monad.extract())//10\nconsole.log(secondMonad.extract());//16\n```\n\n [1]: https://github.com/lizhuoli1126/Functional-OO","categories":["JavaScript"],"tags":["Functional","JavaScript"]},{"title":"圣诞节快乐","url":"/2016/03/30/%E5%9C%A3%E8%AF%9E%E8%8A%82%E5%BF%AB%E4%B9%90/","content":"\n一年一度的圣诞节又到了……或许这又意味这一年的开始了。\n\n这一年中，有很多人给了我帮助，有欢乐之时，也有低落之时。曾经以为自己能够找到自己的目标，却发现自己还是原地踏步。希望来年之时，心中这份迷茫能够或许减少一分吧。\n\n感慨就到这里，希望在这个圣诞日子中，你我能够忘却烦恼，睁开眼睛发现属于自己的幸福，勇于追求自己的未来，不要被周遭而所困扰。\n\n最后，谨祝愿：\n\n自己能够追寻自己的梦想，看到这的你能够拥抱自己的幸福与喜悦。\n\n最后，献上我的圣诞贺卡～\n\n最近有点忙，所以就找别人做好的模版啦（顺便感觉WebGL好厉害……），以后有空可能自己做一个自己的贺卡～感谢大家\n\n贺卡链接：http://www.dreampiggy.com/wp-site/christmas/\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/1/35/a9f2b746ae91a4d2f985966e93de8.png)","categories":["Life"]},{"title":"学期感想和总结","url":"/2016/03/30/%E5%AD%A6%E6%9C%9F%E6%84%9F%E6%83%B3%E5%92%8C%E6%80%BB%E7%BB%93/","content":"\n> 又是一个学期过去了，我在软件工程这条路上又迈出一步，这只是写给自己的，对自己这一学期的总结罢了。\n\n# 最后的PHP？\n\n学期初，最开始便是做的一个基于ThinkPHP的毕业生投票网站，也做了一个简单的微信和手机Web版本。\n\n嘛，关于PHP我还是比较冷静的，PHP适用于传统中等业务逻辑和低并发要求的Web应用。\n\n毕竟没有太多时间，我和另一个同学就直接用了ThinkPHP这种简单无脑框架(当然，还理所应当的踩了坑，这些细节就不说了)\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/5/8c/38da4b884adeda88d1fc1ca859f9f.png)\n所谓国人自己的框架——ThinkPHP\n\n最后嘛，我基本上只是做了5天就转战别的东西了，留下队友暴力撸前端…最后也没多少钱分，主要就是又熟悉了一下框架，知道了一点SMTP协议的东西和关于数据库事务的设计和使用(毕竟投票需要多次SQL，安全、事务和回滚是非常重要的)。\n\n# 入坑iOS开发\n\n对于我这种从来不能静下心来的人，完成了上个Web项目之后，由于加入了学校的[先声网][2]，于是我就又有活干了……先声网是我们学校的一个提供各种校园在线服务的组织，一个技术至上的团队（技术栈包括了Java，PHP，C++，Android开发，iOS开发，Web安全等，也承办各种程序设计大赛，短码比赛之类的活动）。当然，作为我这种菜鸟进去的时候前辈已经积累下了很多经验，而我主要最后就加入了iOS开发。\n\n我们最早的iOS客户端－[先声][3]，是由学长开发的，而那名学长最后也转向别的方向，所以我主要就是在此之上二次开发的。对于我这种从前对iOS开发一无所知的新手，看到Objective-C所谓的：\n\n```objectivec\nNSLog(@\"%@\",@\"fuck\");\n@property\n@interface\n#ifndef\n#endif\ncompare(nil, Nil, NULL, NSNull);\ncompare(0, 1, YES, NO);\nFuck *fuckPointer = [[Fuck alloc] init];\n```\n    \n\n“优雅”语法，我发现我实在难以平静下心来写，于是就直接上手了Swift来重构整个项目。 学习的过程其实是挺愉快的，最开始当然就是看《The Swift Programming Language》中英配合，大概也就2天时间。Swift的语法真是爱不释手，比如你可以这么写for-in 循环\n\n```swift\nfor i in 1...101{\n    if(i % 2) == 1{\n        println(i)\n    }\n}\n```\n\n由于Swift支持FP，你甚至可以这么简写闭包函数，与lambda表达式无异\n\n```swift\n//little calculator\nknownOps[\"+\"] = Op.BinaryOperation(\"+\"){ $0 + $1 }\nknownOps[\"-\"] = Op.BinaryOperation(\"-\"){ $1 - $0 }\nknownOps[\"*\"] = Op.BinaryOperation(\"*\"){ $0 * $1 }\nknownOps[\"/\"] = Op.BinaryOperation(\"/\"){ ($0 != 0) ? $1 / $0 : nil }\n```\n    \n\n虽然Swift 2.0之前，没有异常处理（全靠assert，或者optional处理……），不能有static成员（可以自己构造一个计算属性，里面存一个static变量……），可选链经常容易写错……等等各种小问题，但是有各种方法和框架来解决，并且随着如今Swift 2.0已经发布，这些问题都将不会再困扰初学者……\n\n之后，幸好找到了Stanford的[CS193P课程][4]，那个课程老师讲的非常详细，代码写的也是非常顺……（live code），由于紧接着就是五一，所以直接连着看了3天……现在回想起来真是一个悲惨的时光……\n\n从最开始ViewController的生命周期，delegate，消息，UIKit，TableView，Autolayout……一系列以前从未仔细考虑过的东西慢慢的理解。其中对我感触最大的，就是multi-MVC模式，以前对MVC的理解大概只停留在view层分离UI层，controller控制数据流，从模型层拿，而model直接面向数据库或者数据生成……而multi-MVC更上了一层，每个MVC都可以以其它MVC为model，从而使得整体的模型复用程度提升，而又不会导致过高的耦合。消息机制和代理模式的实际使用也让我对GUI编程可能有了更多的理解（只是GUI编程而不是GUI哦，我现在还是很讨厌做UI或者前端……）\n\n总之，技能的培养这样慢慢起来了，原来看起来那样离我很遥远的iOS开发，渐渐的我也可以稍微接触了。当然，我也许不能当一个iOS开发者吧，毕竟所有的UI都是靠XIB拖控件以及使用Autolayout和Size Classes做出来的，并没有一丝代码控制……（实际上我并不会），这在大型项目中是不可能的。或许我只适合写逻辑或者模型层吧。Anyway，我最后还是花了大概1周时间把整个项目重构，iOS客户端就变成了如今的样子……API封装成一个可动态修改的模式，所有类型转换都采用optional控制，也是基本达到了最后的要求……\n\n虽然也许我今后可能不会真正入坑iOS开发，但是GUI编程来说，Cocoa Touch框架以及Swift确实让我感受到了一种编程的乐趣以及这种高效率的爽快（对比Android SDK来说……有点可怕的Activity和Fragment很难让我有这种感觉）。\n\n# 再战JavaScript-Node.js\n\n或许是这种二流学校的命吧，我们有一个叫做“SRTP”－课外研学学分的东西，所以，我被迫（也是无奈）选择了一个SRTP项目做。由于我点偏了技能点导致Web后端知识比较多，我们选择了一个实时协作编辑系统作为项目要求，当然，最开始的目标就是做成Google Docs那种可以同时看到多个人编辑的位置。 当时Node.js非常火，而且具有事件驱动和非阻塞IO两大特点，感觉上非常适合这个情景。于是我就再次面对了JavaScript这门比较奇葩的语言。\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/8/61/1805572762590de47e5071b94362e.png)\n我们的目标\n\n如今许多前端工程师都想凭借Node.js深入后端领域，达到所谓大前端或者全栈的理想境界，但实际上，Node.js对新手极不友好…… 首先，由于非阻塞的IO，各种事件，包括数据库读写，文件读写都是异步的，由事件轮询来处理，看起来先后顺序依次的a(),b(),c()三个函数，实际执行顺序完全可能是c()->b()->a()。\n\n为了强行让他们按照顺序执行，聪明的你可能会使用回调写法，但是很快就会面对最可怕的`callback hell`\n\n```javascript\nfunction validate() {\n   log(\"Wait for it ...\");\n   // Sequence of four Long-running async activities\n   setTimeout(function () {\n      log('result first');\n      setTimeout(function () {\n         log('result second');\n         setTimeout(function () {\n            log('result third');\n            setTimeout(function () {\n               log('result fourth')\n            }, 1000);\n         }, 1000);\n      }, 1000);\n   }, 1000);\n};\nvalidate();\n```\n\n由于人类写代码都是竖直向下的，如此横向发展绝对不是一个好事情。当然，我们现如今也有各种解决方案，包括依旧是回调的高级语法糖`async`，全部使用事件处理的`EventEmitter`，同步思维写异步的`promise`，都是不错的解决方法……\n\nNode.js有很多槽点（以至于我不想展开写），但是我基本配合着《Node.js权威指南》，外加网上各种教程，GitHub各种开源轮子，把我们的项目做起来了。说是项目，其实更是一个实验新技术的体验，我们整个技术中，有核心的Node.js,Redis,Mongodb，有我以前从未使用过的Mongoose(ORM框架)，而且由于Node.js的纯粹性，对HTTP协议认识（比如手动实现multipart/form-data），Session手动处理，非关系性数据的组织，路由控制，RESTful API设计都有了一些认识，也许是不幸中的万幸吧……\n\n# 奇怪的技能点\n\n当然，我现在承认我就是一个容易三心二意的人，在这一学期中，我又开始点奇怪的技能点了。\n\n最早是括号神教的`Lisp`（这也是我为什么喜欢Swift的原因，FP自然有它的优势，高阶逻辑写起来是非常爽的一件事）\n\n接下来还有蟒蛇大法`Python`，也许挺惭愧，大一真的只学过C++的我，一直对Python就是只会Hello world，如今也是真正花了一周入门Python 2（很抱歉不是3……），Python对我的感觉就是非常精简，动态，类似于Ruby的体验（我并未深入过Ruby，不过还是见识一些简单的语法的），以及FP的支持，（lambda），有各种非常好用的库来简化所有开发，你想做什么基本都可以在Python中找到，怪不得Stanford如今采用Python作为CS新生的入门课程……\n\n最后，我也得安利一下微软，`C#`相比于Java的优势，不是在你看书和Java对比的时候，而是当你写下第一行C#时才会发现……（抱歉又黑了Java），无论是非常丰富的关键字，还是在语法层面提供的委托方法（而不是Java的设计模式撑起的东西），也有灵巧的`async`和`lineq`，都会让你眼前一亮。当然，虽然C#已开源，但是跨平台还并不可信，想要靠这个吃饭，还是得跟着微软帝国干。当然，现如今搞游戏用Unity开发也是不错的前景，你看仙剑六，啊不，比如最近我喜欢玩的一个音乐游戏（MUSYNC），无论是画面还是游戏性都是非常之棒，而Java阵营在游戏的表现或许只有那个代码不堪入目的Minecraft吧……\n\n# 总结\n\n也许扯了很长时间，不过反正这也是给自己看的。如果说大一一学期我是完全迷惘地度过，那么大二上我第一次觉得自己能做些什么，大二下我便认为自己能有资格说可以做什么。或许在编程这方面，我已经接触过多，接触过浅，正如我“装作什么都懂的……xx菜鸟，xx菜鸟……”知乎签名一样，我到现在并没有下定决心要去做某个领域的开发，或者其他之类，但是我也许大概了解了这些领域是在干什么，或许在今后的选择中不会茫然无措。\n\n大二终将结束，如此迷茫的我，或许终于找到了一点点前进的方向了吧。\n\n [2]: http://herald.seu.edu.cn/index/\n [3]: https://itunes.apple.com/cn/app/xian-sheng/id871801426?mt=8\n [4]: http://web.stanford.edu/class/cs193p/cgi-bin/drupal/","categories":["Life"],"tags":["感悟"]},{"title":"客户端上动态图格式对比和解决方案","url":"/2017/03/06/%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8A%E5%8A%A8%E6%80%81%E5%9B%BE%E6%A0%BC%E5%BC%8F%E5%AF%B9%E6%AF%94%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","content":"\n> 对各种客户端来说，无论是Web还是移动端，图片占据的容量和传输资源一定是非常大的。对于静态图，我们常见的PNG和JPEG格式在压缩率和画质无损上都存在着不尽如人意的地方，而动图格式的GIF更是存在着很多问题，比如因此，在很多情况下，我们需要迁移到新的图片格式。\n\n\n# GIF\n为什么我们不用GIF呢，GIF由于时代限制，存在的天生的问题。GIF的规范最新版本是在1989年制定的，一个24位色都没有普及的时代，因此，GIF规范只支持256色索引颜色，并且只能通过抖动、差值等方式模拟较多丰富的颜色。更为悲剧的是，它的alpha通道只有1bit，换言之，一个像素要么完全透明，要么完全不透明，而不像现在PNG的RGBA的8bit alpha通道，alpha值也可以和RGB一样都有255个透明值。这导致了所有GIF的图片带上透明度以后，边缘会出现明显的锯齿。所以如果你的客户端需要展示带透明度的动图，GIF基本上可以不考虑\n\n![](http://blog.ibireme.com/wp-content/uploads/2015/11/gif_apng_demo.gif \"GIF和APNG对比\")\n\n实际的在线Demo，建议用Safari或者Chrome+插打开：[http://apng.onevcat.com/demo](http://apng.onevcat.com/demo)\n\n# APNG\n\nAPNG是Mozilla在2008年发布的图片格式，本质上是在PNG的基础上加上一个扩展，而且非常简单即可实现。因此能够完全支持RGBA。规范可以参见[APNG Specification](https://wiki.mozilla.org/APNG_Specification)。\n\n虽然这个规范没有加入PNG开发组，但是很多浏览器已经支持了APNG。\n最主推的是Apple的Safari（OS X 10.10以后的Safari，以及iOS 8以后的Safari和内置WebView），已经完全支持。Firefox亲儿子当然一直是支持的。Chrome桌面端已经从Chrome 59开始支持，现在就差Edge了。具体支持程度参见[浏览器兼容性](http://caniuse.com/#feat=apng)。\n\nAPNG的优势，在于时间比较长，各种动图制作工具，优化工具都有相应的项目来支持。而且在iOS上的WebView里面是除GIF外，唯一官方支持的动图格式，因此如果做移动端开发需要WebView页引入动图，APNG还是必不可少的。\n\n当然，APNG终究是在PNG的基础上扩展，并没有引入特别出色的压缩算法，而且遗憾的是，短期内APNG还没有引入到Chrome，也就意味着Android平台的WebView也没有原生支持，因此，移动开发又会面临两端兼容性问题，这个后话再说。\n\n![APNG，Chrome需要59或者更高](https://upload.wikimedia.org/wikipedia/commons/1/14/Animated_PNG_example_bouncing_beach_ball.png \"APNG，Chrome需要插件支持或在线预览\")\n\n## 相关APNG工具\n\nAPNG图形化制作工具和在线预览:[iSparta](http://isparta.github.io/index.html)\nAPNG大小优化:[APNG Optimizer](https://sourceforge.net/projects/apng/files/APNG_Optimizer/)\nAPNG Chrome插件:[APNG for Chrome](https://chrome.google.com/webstore/detail/apng/ehkepjiconegkhpodgoaeamnpckdbblp)\n\n# WebP\n\nWebP是Google在2010年发布的图片格式，完全开源，使用了VP8（就是WebM视频所用到的解码器）作为帧压缩编码器，而且在Chrome，Android上得到了原生的支持，具体规范参见:[WebP](https://developers.google.com/speed/webp/)\n\n同样的支持RGBA，而且静态WebP的压缩率比起同质量PNG平均要高上20%左右。现在各大App厂商已经有开始迁移WebP。除了静态的WebP，还有动态WebP格式(Animated WebP)支持，不过动态WebP需要libwebp 0.4以后才正式支持，并需要mux和demux模块，如果自行编译需要注意。\n\nGoogle官方提供了libwebp这个解码库在各个平台的二进制版本和Makefile，并且可以定制开启的功能。不过由于不像APNG那样基于PNG扩展，相关的工具很欠缺，基本全靠WebP Project提供的工具。\n\n`cwebp`:PNG/JPEG -> WebP\n`dwebp`:WebP -> PNG/JPEG\n`vwebp`:WebP命令行预览工具\n`webpmux`:多张WebP制作动态WebP\n`gif2webp`:GIF -> 动态WebP\n\n![Animated WebP，Safari不支持](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/0/9e/63a17a7087e6ab1a209460b54136b.webp \"Animated WebP，Safari不支持\")\n\n## WebP工具\n\n基本上来说，手动制作WebP会比较麻烦，因为Google没有提供WebP Optimizer之类的东西，如果我有100帧基本无差别的图使用webpmux合成动图，最终输出的文件大小会比较大。因此，一般推荐的做法，是先通过PNG制作APNG（比如iSparata），经过APNG Optimizer之后，再从APNG转换到动态WebP，这个流程可以用这个项目来一键搞定。\n同时，也可以使用ffmpeg来转换视频到Animated WebP，一般使用MOV封装格式（UE常用的Pr导出的MOV可以支持alpha通道）。不过经过测试转换出来的Anmimated WebP大小相对比较大的（尤其同样的lossless下），不如PNG->APNG->Animtated Webp这个流程效果好。\n\n[apng2webp](https://github.com/Benny-/apng2webp):APNG -> Animated WebP\n[ffmpeg](https://gist.github.com/dreampiggy/52c658253de3ba22fd3dec4d3f3182ab):MOV -> Animated WebP\n\n# 其他粗暴的解决方案\n像国内的微博桌面版，提供的动图是通过PNG配合CSS Spirit，靠着不断JS轮播切换PNG子图所拼出来的，这个带来的带宽消耗会是非常高的，因为完全是多张图片混合，除非有着兼容性包袱（IE之类），一般不推荐使用。\n\n![暴力实现](http://img.t.sinajs.cn/t6/style/images/common/steps_gold2.png \"暴力实现\")\n\n# APNG和WebP各平台实现\n## Web\n[APNG 浏览器支持](http://caniuse.com/#feat=apng)\n[WebP 浏览器支持，注意Animated WebP支持](http://caniuse.com/#feat=webp)\n\n## iOS\n\nAPNG:\n+ [YYImage](https://github.com/ibireme/YYImage)\n+ [APNGKit](https://github.com/onevcat/APNGKit)\n\nAnimated WebP:\n+ [YYImage](https://github.com/ibireme/YYImage)\n\nWebP:\n+ [SDWebImage](https://github.com/rs/SDWebImage)，注意SD使用的libwebp并没有加入mux和demux，故无法支持Animated WebP\n\nWebView:\n+ UIWebView，WKWebView和SafariViewController均只支持APNG（iOS 8以后），不支持Webp和Animated WebP\n\n\nYYImage，对显示动态图，使用了一个UIImageView的子类YYAnimatedImageView，通过直接插入了一个CALayer来作为图片的渲染layer，并用`CADisplayLink`这个帧定时器来刷新动图帧，通过异步线程处理解码，还有一些C的动态分配和回收内存来避免非常高的内存占用，保证了性能。并且自动处理了从视图消失以及滚动（可以切换到RunLoopCommonMode来滚动时候依然显示动图而不暂停）情况的问题，实现也非常有意思，有兴趣的人可以看一看。\n\n## Android\n\nAPNG:\n+ [APNG View](https://github.com/sahasbhop/apng-view)\n\nAnimated WebP:\n+ [Fresco](https://github.com/facebook/fresco)\n\nWebView:\n+ Android 4.3以后才支持带lossless和alpha的WebP\n\nAndroid基本上对APNG可以说是没有什么支持的，所以如果是移动开发两个平台兼顾，建议同时准备APNG（for iOS WebView）和Animated WebP，客户端上建议都是用Animated WebP，因为VP8的解码速度相对于APNG有一些优势。\n\n![](http://blog.ibireme.com/wp-content/uploads/2015/11/anim_bench.png)\n\n# 存在的坑\n\n## Web和移动端对于APNG和Animated WebP循环次数不同\n这个是一个非常大的坑，在Safari for iOS（Safari for macOS正常）和Chrome预览APNG和Animated WebP的时候，动图的循环次数为对应原图的loop+1。比如Animated WebP有100帧，loop为2，那么Chrome会循环总计展示300帧\n\n刚开始我以为是移动端实现库的问题，毕竟Google和Apple这种大厂一般不会出现问题。但是再参阅了APNG和Animated WebP的规范，发现确实是Safari和Chrome本身的问题，可以参考[APNG规范](https://wiki.mozilla.org/APNG_Specification)中的`num_plyas`字段，和[WebP规范](https://developers.google.com/speed/webp/docs/riff_container)的`loop_count`字段\n\n```\nLoop Count: 16 bits (uint16)\nThe number of times to loop the animation. 0 means infinitely.\nThis chunk MUST appear if the Animation flag in the VP8X chunk is set. If the Animation flag is not set and this chunk is present, it SHOULD be ignored.\n```\n\n规范提到的伪代码描述也表示，loop count为0表示无限循环展示首帧到尾帧，而loop count >= 1，展示首帧到尾帧loop count次。\n\n```python\nassert VP8X.flags.hasAnimation\ncanvas ← new image of size VP8X.canvasWidth x VP8X.canvasHeight with\n         background color ANIM.background_color.\nloop_count ← ANIM.loopCount\ndispose_method ← ANIM.disposeMethod\nif loop_count == 0:\n    loop_count = ∞\nframe_params ← nil\nassert next chunk in image_data is ANMF\nfor loop = 0..loop_count - 1\n    clear canvas to ANIM.background_color or application defined color\n    until eof or non-ANMF chunk\n        frame_params.frameX = Frame X\n        frame_params.frameY = Frame Y\n        frame_params.frameWidth = Frame Width Minus One + 1\n        frame_params.frameHeight = Frame Height Minus One + 1\n        frame_params.frameDuration = Frame Duration\n        #......\n        Show the contents of the canvas for\n            frame_params.frameDuration * 1ms.\n```\n\n同样的，APNG对应的`num_plays`字段意思是一样的，大家可以使用这个在线测试用例，Safari表现错误而多循环了一次：[https://philip.html5.org/tests/apng/tests.html#num-plays-1](https://philip.html5.org/tests/apng/tests.html#num-plays-1)\n\n解决办法：\n由于不能更改浏览器的实现，部分情况也不好引入JS来手动实现，因此，对于APNG，一般只用在iOS的WebView上，因此可以直接制作APNG图的时候，把循环减一。而Animated WebP，可以在客户端实现加一个Hack，如果loop不是0手动减一，保持和Web一致性（当然，也可以专门提供一个loop count加一的图给Chrome/Android的WebView），希望之后两大浏览器是否可以把这个Bug修复了（当然，不排除联合一起更改了规范的可能性）\n\n# 总结\nGIF作为一个动图格式已经太过于古老了，尤其是当前移动和Web站需要引入各种动态表情，头像的时候，GIF的透明问题已经是不可接受的。WebP长期发展也是比较看好（相比APNG没有进入PNG开发组，基本不再活跃），开源外加无授权费用，或许能够和WebM一样，成为互联网下首选的图片和视频格式。而移动客户端，在很多种需求下（动态表情，用户标志，广告）等上面，采用这种APNG和Animated WebP就能够轻松解决。\n\n","categories":["iOS"],"tags":["iOS","Web","Image"]},{"title":"开源者行-见识更大的世界","url":"/2016/03/30/%E5%BC%80%E6%BA%90%E8%80%85%E8%A1%8C-%E8%A7%81%E8%AF%86%E6%9B%B4%E5%A4%A7%E7%9A%84%E4%B8%96%E7%95%8C/","content":"\n> [《开源者行》活动链接][1]\n\n* * *\n\n# 初到上海\n\n上周五，我们I++聚乐部的3人[我][2]、[吴涛][3]和杨佳星三人，一同参加了一个叫做《开源者行》上海站的活动。\n\n*其实当初听说的时候我是拒绝的，因为我看介绍里面没有什么干货，透露着一种安(chuan)利(xiao)开源的性质。但我认为，这次活动远比一次技术讲座来的有意义。*\n\n不过，经过2个小时的旅途跋涉，1个小时的酒店等待，半个小时的带队路途(?)，我们终于到达了一处别墅：[GitCafe][4]的办公地点：\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/7/2b/ce5bb993f7ca4e494e7a2c9e9e11d.jpg)\n\n> *真*土豪\n\n这是我当时的第一感受，当然，里面的设施也是比较豪华的，比如各种Mac……（5K等等）\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/7/1e/dfe067a89b418466913b250387ce9.jpg)\n\n活动人员都是非常热心的，各种福袋、饮料、小吃都上齐了，然后他们自我介绍，我们自我介绍，大家很快就熟识了。里面有来自各地的高校的，上海的，四川的，南京的（东大竟然还有1个**学姐**也来参加了，真是有缘）……\n\n各地的开源社区都不一样，有纯技术导向的，有开源Linux导向的，还有偏宣传的，其中那个[多火团队][7]就非常不错，还有华科来的联创团队的人（真是厉害），大家有些人也在讨论代码问题（当然不是`PHP是不是最好的语言`这种）。我觉得能有一处让我们这些国内预备`程序员(媛)`交流的地方，真是非常不错。\n\n# 讲座\n\n从活动开始以后，基本每天都会有讲座，来的人各式各样，有开源社区的，有商业公司的，比如[Docker][8]，[MoPaaS][9]，[GitCafe][4]等等，讲座基本有各种方面的，有技术的，有人文方面（比如开源历史），还有一些其他的（比如Web设计，社区管理）……基本是讲到什么算什么，大家只是交流一下，气氛也十分轻松。\n\n# Ideathon\n\n其实这三天的活动安排倒是不是很紧凑，基本就是白天一些简单的讲座，然后第二天晚上布置了任务，进行一场Ideathon(也就是一场创意赛)，围绕着`机器人`和`餐厅`关键字头脑风暴并且要有简单的Presentation和可行性分析。\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/3/13/b69e8077b787a0c009be79adcbcef.jpg)\n\n其中我们的点子经历过3个阶段，几小时讨论的结果一次次被砍掉，最终才确立了想法，然后便开始各种做PPT和做可行性分析…………晚上1点睡，早上9点过去又继续，直到下午最后演讲前才差不多准备好。\n\n或许是`那个评委非常看重技术可行分析吧`，我们强大的[思维导图][11]配合幻灯片呈现出了我们全部的想法，最终我们组获得了第一名，并且我和另一个同学（演讲能力超群的）获得了全程报销的参加华科的Hackathon的资格（最近有参加过Hackathon的求支援！！相关链接：[知乎][12]）\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/b/3c/cb820e9a5e716f8e5a964b245e1a0.jpg)\n\n# 总结\n\n总的来说，这次开源者行比我想象的要好的多，其实有时候干货与否，技术与否全看在你的理解，多与各地高校同学交流，你才会发现更大的世界，了解更多的无论是技术还是非技术问题，知道自己存在的问题，对你这条程序员(媛)亦或是其他道路都有非常大的促进作用。\n\n感谢这次GitCafe的活动，或许正如他们的目标：成为全国最大的高校开源盛会，赶紧报名参加吧！！\n\n> 全体成员合影\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/d/62/6241981cd7166f4abf6b6a4158ba6.jpg)\n\n [1]: http://www.ubuntukylin.com/news/shownews.php?lang=cn&id=459\n [2]: http://www.dreampiggy.com\n [3]: http://neverchanje.github.io\n [4]: https://gitcafe.com\n [7]: http://www.duohuo.org\n [8]: https://www.docker.com\n [9]: http://www.mopaas.com\n [11]: http://zh.wikipedia.org/wiki/心智图\n [12]: http://www.zhihu.com/question/20621242","categories":["Life"],"tags":["开源活动"]},{"title":"我的个人博客建成啦！^^","url":"/2016/03/29/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E6%88%90%E5%95%A6%EF%BC%81/","content":"\n首先，欢迎大家来到我的博客～\n\n本人想着，作为一个软件工程专业的学生，怎么也得有属于自己的一个网站或者博客吧？于是，趁着有空，抽出时间做出了这个博客。\n\n博客主要用于记录个人的生活感想，编程方面的知识，设计方面的想法以及其他杂谈，希望大家能够多多提出意见，与我进行交流，来者不拒。\n\n博客采用了WordPress开发，借用了他人的第三方主题并加以修改（大一学到的PHP终于有了一点用武之地了T.T），服务器为新浪云（SAE），并购买了www.dreampiggy.com域名，大家以后要多多来看哦。\n\n博客可以在电脑浏览器上浏览，也可以手机浏览（虽然暂时的响应式设计是根据分辨率判断的，可能高分辨率设备会被误认为电脑……以后再改进为UA判断，先让我休息一会……）。\n\n博客允许用多说评论，大家可能不知道多说，这是一个广泛采用的论坛或者博客的评论系统，可以使用第三方，包括微博，QQ，人人等主流平台账号登陆，并且自动更新头像，还可以获取通知，甚至在其他网页上采用多说的评论时会自动同步。希望大家尽量不要游客评论（游客我也分不清呀……用第三方平台账号登陆很快滴）\n\n现在刚建成，内容几乎为0，大家可以在这篇文章后面自由吐槽。我之后会定期更新博文，也可以链接到我的GitHub上面的一些项目，希望能收到各式各样的人的建议，无论你是做什么的，或者对于软件工程一无所知，只要你能浏览我的博客，与我交流，我就心满意足了。\n\n最后，再次祝贺我的个人博客建成，散花！`*\\(^o^)/*`"},{"title":"探秘越来越复杂的ImageIO框架","url":"/2022/11/07/%E6%8E%A2%E7%A7%98%E8%B6%8A%E6%9D%A5%E8%B6%8A%E5%A4%8D%E6%9D%82%E7%9A%84ImageIO%E6%A1%86%E6%9E%B6/","content":"\n> ImageIO是Apple提供的上层框架，用于处理常见图像格式的编解码支持。这篇文章主要讲述了三个子话题：WebP/AVIF的支持进展，IOSurafce和硬件解码优化50%内存开销，以及CGImageSource机制变化导致的线程安全问题\n\nImageIO的定位是上层的支持框架，其封装了诸多的苹果的底层解码器，开源编解码器，硬件HEVC/ProRes加速器等等底层细节，致力于提供和上层UI框架（如UIKit/CoreGraphics）的可交互性。\n\n在早些年的时候，我写过一系列文章，介绍了其API使用的基本流程（参考：[《iOS平台图片编解码入门教程（Image/IO篇）》](https://dreampiggy.com/2017/10/30/iOS%E5%B9%B3%E5%8F%B0%E5%9B%BE%E7%89%87%E7%BC%96%E8%A7%A3%E7%A0%81%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%88Image:IO%E7%AF%87%EF%BC%89)），以及有关其惰性解码的机制（参考：[《主流图片加载库所使用的预解码究竟干了什么》](https://dreampiggy.com/2019/01/18/%E4%B8%BB%E6%B5%81%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%BA%93%E6%89%80%E4%BD%BF%E7%94%A8%E7%9A%84%E9%A2%84%E8%A7%A3%E7%A0%81%E7%A9%B6%E7%AB%9F%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88)）。\n\n实话说，自从重心从iOS开发，转移到做LLVM工具链相关工作之后，我本以为不会再写这些上层iOS框架的文章了，但是[SDWebImage](https://github.com/SDWebImage/SDWebImage)这个开源库依旧没有合我预期的新Maintainer，来作为交接，因此现在还是忍不住先写这一篇吐槽和说明文章。\n\n这篇文章会介绍，自iOS 13时代之后，苹果在ImageIO上做的一系列优化（“机制变化”），以及对开发者生态带来的影响。\n\n### WebP/AVIF新兴图像格式支持\n\n> 自从HEVC/HEIF在苹果高调提供支持之后，由于硬件解码器的加持，本以为苹果会对其他竞争的媒体格式不再抱有兴趣，但实际上并非如此\n\n#### WebP\n\nWebP作为Google主导的无专利费的图像格式，其诞生后就一直跟随Chrome推广到各大Web站点，如今已经占据了互联网的一大部分（虽然其兄弟的WebM视频编码并没有这么热门）。\n\n早在iOS 11时代，我就呼吁并提Radar希望Apple的ImageIO能够支持原生的WebP，而最终，时隔3年，在iOS 14上，ImageIO终于迎来了其内置的WebP支持，并且能够在Mac，iPhone上的各种原生系统应用中，预览WebP图像了。\n\n那么，ImageIO对WebP的支持到底如何呢？答案其实很简单，ImageIO直接内置了开源的libwebp的一份源码和VP8的支持，并且去掉了编码的能力支持，所以能够以软件解码的形式支持WebP，不支持硬件解码。\n\n![screenshot-20221107-210603](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-11-07/media/screenshot-20221107-210603.png)\n\n换言之，使用这个ImageIO的系统解码器解码WebP，和使用我写的[SDWebImageWebPCoder](https://github.com/SDWebImage/SDWebImageWebPCoder)没有本质上的巨大差异（最多是一些编译器优化导致的差异），而后者还支持WebP编码（虽然耗时很慢）\n\n#### AVIF\n\n[AVIF](https://aomediacodec.github.io/av1-avif/v1.1.0.html)是基于AV1视频编码的新兴图像格式，作为HEVC的无专利费的竞争对手。AVIF与AV1，HEIF和HEVC，这两大阵营的关系一直是在相互竞争中不断发展的。而各大视频站如YouTube，Netflix，以及国内的Bilibli都在积极的推广这一视频格式，减少CDN带宽和专利费的成本。\n\n而随着Apple在2018年加入[AOM-Alliance for Open Media](https://aomedia.org/)之后，我就预测有朝一日能够看到苹果拥抱这一开源标准。在2021年WebKit的开源部分曾经接受了[PR并支持AVIF软件解码](https://bugs.webkit.org/show_bug.cgi?id=207750)。而在2022的今年，iOS 16/macOS 13搭载的Safari 16，已经正式宣布[支持了AVIF](https://webkit.org/blog/13152/webkit-features-in-safari-16-0/)\n\n虽然目前没有在其他系统应用中可以直接预览AVIF，但是我们已经看到这一趋势。在ImageIO的反编译结果中也看到了对`.avif`的处理和UTI的识别，虽然目前其本身只是会fallback到AVCI（[AVC编码](https://en.wikipedia.org/wiki/H.264/MPEG-4_AVC)的HEIF，并不是AV1），但是我相信，后续OS版本一定会带来其对应的原生SDK和应用层的整体支持，甚至未来可以看到新iPhone搭载AV1的硬件解码器。\n\n![screenshot-20221107-211812](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-11-07/media/screenshot-20221107-211812.png)\n\nPS：广告时间，我之前也尝试过一些利用开源AV1解码器实现的[AVIF解码库](https://github.com/SDWebImage/SDWebImageAVIFCoder)，以及macOS专用的[Finder QuickLook插件](https://github.com/dreampiggy/AVIFQuickLook)，在未来到来之前，依旧可以发挥其最后的功用：）\n\n```\nbrew install avifquicklook\n```\n\n### IOSurface和硬件解码优化\n\n> IOSurface，作为iOS平台上古老的一套在多进程，CPU与GPU之间共享内存的方案，在早期iOS 4时代就已经诞生，但是一直仅仅作为系统私有的底层XPC通信用的数据格式\n\n而从iOS 13之后，苹果对硬件解码的支持的图像格式的上屏渲染，大量使用了IOSurface，抛弃了原有的“主线程触发CGImage的惰性解码”的模式。\n\n也就是说，《主流图片加载库所使用的预解码究竟干了什么》这篇文章关于ImageIO的部分已经彻底过时了，至少对于JPEG/HEIF而言是这样。\n\n如何验证这一点呢？可以从一个简单的Demo，我们这里有一个`4912*7360`分辨率的JPEG和HEIC图（[链接](https://p11.douyinpic.com/img/douyin-admin-obj/a67f70f5b8c681b25e768cf5ecde0b9b~noop.heic)），使用UIImageView渲染上屏，开启Instruments，对比内存占用\n\nIOSurface：\n\n```swift\n// JPEG/HEIF格式限定，iOS 13，arm64真机限定\nlet image = UIImage(contentsOfFile: largeJpegUrl.path)\nself.imageView.image = image\n```\n\nCGImage：\n\n```swift\n// JPEG/HEIF格式限定，iOS 13，arm64真机限定\nlet source = CGImageSourceCreateWithURL(data as CFURL, nil)!\nlet cgImage = CGImageSourceCreateImageAtIndex(source, 0, nil)!\nlet image = UIImage(cgImage: cgImage)\nself.imageView.image = image\n```\n\n数据较多，直接看IOSurface的结果，可以发现，除了峰值上HEIC出现了翻倍，最终稳定占用都为**51.72MB**\n\n而直接用CGImage（或者你换用模拟器而不是真机），则结果为**137.9MB**（RGBA8888）\n\n+ JPEG（IOSurface）\n\n![screenshot-20221107-220103.png](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-11-07/media/screenshot-20221107-220103.png)\n\n\n+ HEIC（IOSurface）\n\n![screenshot-20221107-220104.png](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-11-07/media/screenshot-20221107-220104.png)\n\n备注：\n1. 在iOS 15+之后，这部分的Responsible Library会变成CMPhoto，iOS 15+新增的`UIImage.preparingForDisplay()`也利用了它的能力\n2. 使用`UIImage(contentsOfFile:)`和这里的`UIImage(data:)`，在iOS 15上并无明显差异，但是在低版本如iOS 13/14上，可能出现`UIImage(data:)`对于HEIC格式，无法利用IOSurface的Bug，因此更推荐使用文件路径的接口\n\n#### 50%内存开销的奥秘\n\n反编译可以发现，苹果系统库的内部流程，已经废弃了CGImage来传递这种硬件解码器的数据Buffer，而直接使用IOSurface，以换取更小的内存开销，达到同分辨率下RGBA8888的内存占用的**37.5%（即3/8）**，同分辨率下RGB888的内存占用的**50%（即1/2）**\n\n你可能会表示很震惊，因为数学公式告诉我们，一个Bitmap Buffer的内存占用为：\n\n```\nBytes = BytesPerPixel * Width * Height\n```\n\n而要实现这个无Alpha通道的50%内存占用，简单计算就知道，意味着`BytesPerPixel`只有1.5，也就是说12个Bit，存储了3个256（2\\^8）色彩信息，换句话说0-255的数字用4个Bit表示！\n\n你觉得数学上可能吗？答案是否定的，因为实际上是用了[色度采样](https://en.wikipedia.org/wiki/Chroma_subsampling)，并不是完整的0-255的数字，学过数字图像处理的同学都应该有所了解。\n\n打开调试器，给IOSurface的`initWithProperties:`下断点，发现这个创建的IOSurface很有意思，`PixelFormat = 875704438('420v')`，即`kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange`，看来使用了[YUV 4:2:0的采样方式](https://markrepo.github.io/avcodec/2018/06/28/YUV/)\n\n![screenshot-20221107-215148](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-11-07/media/screenshot-20221107-215148.png)\n\n因此，这里应该对应有两个Plane，分别对应了Y和U两个采样的平面，最终由GPU渲染时进行处理。这里不采取YUV 4:4:4的原因是，大多数JPEG/HEIF的无透明度的图像，在肉眼来看，采样损失的色度人眼差异不大，这一优化能节省50%内存占用，无疑是值得的。\n\n值得注意的是，这里苹果处理具体采样的逻辑也是和原图像编码有关的，如果YUV 4:4:4编码的，则最终CMPhoto可能依旧会采取YUV 4:4:4进行解码并直接上屏，苹果专门的策略类来进行处理。\n\n\n#### IOSurface和跨进程Buffer\n\n不过，除了这一点，为什么只有真机能支持色度采样呢？答案和Core Animation的跨进程上屏有关。\n\n之前有文章分享过之前，iOS的UI渲染是依赖于SpringBoard进程的中的CARenderServer子线程来处理的，因此这就有一个问题，我们如何才能将在App进程的Bitmap Buffer传给另一个进程的CARenderServer呢？\n\n在iOS 13之前我们的方案，就是利用mmap，直接分配内存。但是mmap的问题在于，在最终Metal渲染管线传输时，我们依旧要经过一次额外的把Bitmap Buffer转为Texture并拷贝到显存的流程，因此这一套历史工作的横竖还有一些局限性。\n\n在A12+真机的设备上，这一步借助IOSurface来实现跨CPU内存和GPU显存的高效沟通。\n\n参考苹果的文档以及一些相关资料\n+ [Transferring Data Between Connected GPUs](https://developer.apple.com/documentation/metal/resource_fundamentals/transferring_data_between_connected_gpus)\n+ [Cross-process Rendering](http://www.russbishop.net/cross-process-rendering)\n\nIOSurface的资源管理本质上是Kernel-level而不是User-level的mmap的buffer，Kernel已经实现了一套高效的传输模型，借助Lock/Unlock来避免多个进程或者CPU/GPU之间发生资源冲突，因此这是上述优化的一个必要条件。\n\n```swift\nlet surface: IOSurface\nsurface.lock(options: .readOnly, seed: nil)\ndefer { surface.unlock(options: .readOnly, seed: nil) }\n\n// Use surface.baseAddress to read the pixel data\n// Make sure to step by bytesPerRow for each row\n```\n\n#### 开发者的痛，我的Public API呢？\n\n现在揭秘了苹果优化JPEG和HEIF硬件解码内存开销之后，下一个问题是：\n\n> 作为开发者，我如果加载一个JPEG/HEIF网络图，有办法也利用这个优化吗？\n\n答：可以，但是使用时需要遵守以下几个原则：\n\n1. 对JPEG/HEIF网络图，如果仅有内存中的数据，则优先考虑使用`-[UIImage initWithData:]`\n2. 如果能够将数据下载到本地存储产生文件路径，则优先考虑使用`-[UIImage imageWithContentsOfFile:]`加载\n3. 如果直接使用ImageIO接口，需要注意，调用`CGImageSourceCreateImageAtIndex`返回的是惰性解码的占位CGImage，而`CGImageSourceCreateThumbnailAtIndex`返回的是解码后的CGImage（也就根源上无法利用IOSurface优化）\n4. 如果要进行预解码，在iOS 15之后，请不要使用老文章写的，使用CGContext提取Bitmap Buffer的方案，优先调用`+[UIImage imageByPreparingForDisplay]`，甚至是如果仅有CGImage的情况下，也推荐创建一个临时UIImage再来调用。其原理是，对于上文提到的，惰性解码的占位CGImage，CMPhoto能间接进行IOSurface的创建（利用后文讲到的`CGImageGetImageSourcce`)，达到偷梁换柱的作用，而手动创建CGContext并没有这样的能力（可以参考[#3368](https://github.com/SDWebImage/SDWebImage/pull/3368)）\n\n如果遵守以上几点，那么我们依旧可以利用到这个优化，节省内存占用。否则会退化到传统的RGBA8888的内存开销上。尤其是关于第4点，苹果这个设计本想让开发者淡化IOSurface和CGImage的差异，但是我感觉反而增加了理解成本和性能优化成本。\n\n另外，ImageIO和UIKit并没有提供更详细的IOSurface的公开API，只有其内部流程，本质间接使用了以下私有接口：\n\n+ `-[UIImage initWithIOSurface:]`\n+ `CGImageSourceCreateIOSurfaceAtIndex`\n\n诚然，我们都知道能够直接调用任意的Objective-C/C API的姿势，这里也不再展开，只是需要注意，上文提到的这些优化，都存在特定iPhone硬件（A12+）和格式（JPEG/HEIF）的限定，需要注意检查可用性。\n\n此外，从实践来看，苹果UIKit和ImageIO的上层接口，都更推荐文件路径的形式（因为可以优化为mmap读取，文件扩展名的Hint等逻辑），如果我还继续维护SDWebImage下去的话，未来也许会提供基于URLSessionDownloadTask以及文件路径模式的解码方案，或许就能更好地支持这一点。\n\n### 不再安全的ImageIO\n\n> 曾经，在我的最佳设计模式观念里，一个Producer，产出的Product，永远不应该反向持有Producer本身。但是这个想法被ImageIO团队打破了\n\n#### 从一个崩溃说起\n\n在iOS 15放出后的很长一段时间里，SDWebImage遇到一个奇怪的崩溃问题[#3273](https://github.com/SDWebImage/SDWebImage/issues/3273)，从堆栈来看是典型的多线程同时访问了CFData（CFDataGetBytes）导致的野指针。起初我对此并没有在意，以为又是小概率问题，并且@kinarobin提了一个可能的CGImageSource过度释放的修复后，我就关闭了这个问题。但是随后越来越多用户依旧反馈这个崩溃，因此重新打开仔细看了一下，发现了其背后的玄机。\n\n玄机在于，iOS 15之后，Core Animation在主线程渲染CGImage时，会调用一个新增的奇怪的接口`CGImageGetImageSource`。如果带着疑问进一步追踪调用堆栈，发现在调用`CGImageSourceCreateImageAtIndex`时，ImageIO会通过`CGImageSetImageSource`绑定一个CGImageSource实例，到CGImage本身的成员变量（实际来说，是绑定到了其结构体指针存储的CGImageProperty字典）。随后，Core Animation会通过获取到这个CGImageSource，后续在渲染时间接调用CGImageSource的相关接口。持有链条为 UIImage -> UIImageCGContent -> CGImageSource\n\n![screenshot-20221107-185536](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-11-07/media/screenshot-20221107-185536.png)\n\n\n#### 崩溃的背后\n\n这一机制改变，同时带来了一个隐患是：ImageIO它不再线程安全了。而且开发者不能修改Core Animation代码来强制加锁。\n\n主要原因是，CGImageSource支持渐进式解码，而第三方自定义UIImage的子类时，有可能自己创建并持有这个渐进式解码的CGImageSource，并不断更新数据。在SDWebImage本身的设计中，我们通过加锁来保证，所有的对渐进式解码的调用，以及更新数据的方法，均能被同一把锁保护。\n\n而当我们产出的CGImage，传递给了Core Animation，它无法访问这一把锁，而直接获取CGImageSource，并调用其相关的解码调用，就会出现多线程不安全的崩溃问题。\n\n总而言之，这一设计模式的打破，即把Product和本不应该关心的Producer一起交给了外部用户，但是外部用户无法保障Producer的生命周期和调用，最终导致了这样的问题。\n\n#### Workaround方案\n\n最终，针对这个问题，SDWebImage提供了两套解决思路，第一个思路是直接通过CGContext提取得到自己的Bitmap Buffer，得到一个新的CGImage，切断整个持有链，最简单粗暴的修复，代价是全量关闭惰性解码无法用户控制，可能带来更高的内存占用（[#3387](https://github.com/SDWebImage/SDWebImage/pull/3387)，修复在5.13.4版本上）\n\n第二个思路是，通过抹除掉CGImage持有的这些额外信息，采取通过CGImageCreate重新创建一个复制的CGImage，但是依旧保留了惰性解码的可选能力（[#3425](https://github.com/SDWebImage/SDWebImage/pull/3425)，方案在5.14.0版本上）。顺便提一句，通常动图（GIF/AWebP）都不支持硬件解码且切换帧频率较高，关闭惰性解码依旧是小动图的最佳实践。\n\nPS：对感兴趣的小伙伴详细解释一下，第二个解决思路利用了CGImageProperty（类似于CGImage上存储的一个字典，按Key-Value形式存取）的时机特性，使用`CGImageCreate`重建CGImage时会完全丢失所有CGImageProperty（只有`CGImageCreateCopy`能够保留）。\n\n而上文提到的`CGImageGetImageSource/CGImageSetImageSource`这些私有接口，本质上是操作这个`com.apple.ImageIO.imageSourceReadRef`的Key（全局变量`kImageIO_imageSourceReadRef`），Value存储了ImageIO的C++对象，并可以还原回一个CGImageSourceRef指针。一旦我们把CGImageProperty丢失掉，那么就能打断这个持有链条。\n\n![screenshot-20221107-202706](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-11-07/media/screenshot-20221107-202706.png)\n\n\n总结起来，ImageIO Team做出如此重大的设计模式改变，并没有在任何公开渠道同步过开发者，也没有提供公开接口能够控制这个行为，或者至少，没有暴露对应的`CGImageSetImageSource`接口，导致第三方开发者不得不采取曲线救国的解决方案去Workaround，这一点很值得让人吐槽。\n\n### 总结\n\n这篇文章看似讲了三个话题，其实背后有着一贯的缘由背景：\n\n早期的ImageIO和各种上层框架的设计，是针对iPhone的低内存的机型做了深入优化，希望能尽量利用惰性解码，mmap缓存，换取较低内存开消，并且对各种无硬件解码的开源格式完全不感兴趣。\n\n而最近几年，随着苹果芯片团队的努力，高内存，M1的统一内存，以及高性能芯片的诞生，苹果已经有充足的能力能够通过软件解码，共享内存，越来越多硬件解码器技术来满足主流的多媒体图像支持，本身这是一件好事。\n\n不过问题在于历史遗下来的API，依旧保持了之前的设计缺陷，Apple团队却一直在，通过越来越Trick和Hack的方式解决问题，并没有给开发者可感知的新机制和手段来跟进优化（除开这一点吐槽，AppKit上的NSImage的NSImageRep这种代理对象设计，比UIImage的私有类UIImageContent设计要适宜的多，也灵活的多）\n\n个人看法：软硬件一体加之闭源，会导致开源社区的实现，永远无法及时跟上其一体的私有集成，最终会捆绑到开发者和用户（开发者越强依赖苹果API和SDK，就会越强迫用户更新OS版本，进而捆绑硬件换代销售），这并不是一个好的现象🙃\n\n### 招募\n\n[SDWebImage](https://github.com/SDWebImage/SDWebImage)开源项目如今缺少长久维护的Maintainer，如果你对iOS/macOS框架开发感兴趣，对图像渲染和Apple平台有所涉猎，对Swift/Objective-C大型开源项目贡献有所期待，可以在[我的GitHub](https://github.com/dreampiggy)上，以Email，Twitter私信等方式联系我。","categories":["iOS"],"tags":["Image","AVIF","ImageIO","WebP"]},{"title":"接上一话，在Swift中使用代理来中转请求和响应","url":"/2016/03/30/%E6%8E%A5%E4%B8%8A%E4%B8%80%E8%AF%9D%EF%BC%8C%E5%9C%A8Swift%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%E6%9D%A5%E4%B8%AD%E8%BD%AC%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94/","content":"\n> 这一次主要讲讲代理（Delegate）在iOS开发中的重要意义\n\n上一次说道通过一个类的静态方法来把所有的垃圾初始化代码扔到一起，减少每次创建新的VC所带来的重复劳动问题，这次主要说一下如果通过代理，来使你的代码更为简单，调用一个API： \"Could not be simple\"\n\n所谓的代理，就是意思被代理的类把自己的方法交给代理人那个类来执行\n\n首先，为了做一个代理，你必须要定义一个协议（称作APIGetter），这里我是把所有的返回结果放在代理，发送请求通过类的静态方法来使用（类名就叫做HeraldAPI吧～）\n\n协议：\n\n```swift\n@objc protocol APIGetter{\n  func getResult(APIName:String, results:NSDictionary)\n  func getError(APIName:String, statusCode:Int)\n}\n```\n    \n\n由于我使用的是AFNetworking的库，可以方便的进行网络通信，AFNetworking就不再介绍了，这里还通过上层封装了两个方法，还有一个对AFNetworking的代理（代理也可以传递的……）：\n\n```swift\nvar httpController:HttpController//对AFNetworking的代理，暂时不要管他啦\nfunc didReceiveDicResults(results: NSDictionary, tag: String)//返回通过POST调用API的结果\nfunc didReceiveErrorResult(code: Int, tag: String)//返回通过POST请求调用API失败，code为HTTP状态码\n```\n    \n\n然后，你便可以大展身手，设置你的代理了。首先，你当然需要一个类的成员变量，一般就叫做delegate\n\n```swift\n    var delegate:APIGetter?\n```\n\n之后，我是通过类的静态方法来发送的（因为和APIGetter的代理无关可以略过……虽然这个sendAPI用了AFNetworking的代理……所谓可以层层封装代理）\n\n而对于接受请求结果，只需要这样：\n\n```swift\nfunc didReceiveDicResults(results: NSDictionary, tag: String) {\n    switch tag{\n    case \"cardDetail\":\n        self.delegate?.getResult(tag, results: results[\"content\"] as NSDictionary)\n    default:break\n    }\n}\n\nfunc didReceiveErrorResult(code: Int, tag: String) {\n    switch tag{\n    case \"cardDetail\":\n        self.delegate?.getError(tag, statusCode: code)\n    default:break\n    }\n}\n```\n\n这样，你就已经定义好了一个代理，现在只需要代理人类（就是真正的VC）只要把自己当作代理人（设置自己为delegate就好了）\n\n在你自己的VC中首先确保自己实现了这个协议，比如：\n\n```swift\nSeuCardTableViewController: UIViewController, UITableViewDataSource, UITableViewDelegate, APIGetter {\n\n//......\n\n\tvar API = HeraldAPI()\n\toverride func viewDidLoad() {\n\t\tself.API.delegate = self\n\t\t//......\n\t}\n\n//......\n}\n```\n\n然后，在实现代理方法中，干自己想干的任何事情\n\n```swift\nfunc getResult(APIName: String, results: NSDictionary) {\n    println(results)\n}\n\nfunc getError(APIName: String, statusCode: Int) {\n    println(\"Oh no!\")\n}\n```\n\n**你就完成了整个东西……**\n\n你可能觉得很奇怪，自己在VC中的getResult里面的results和APIName是从哪里来的？很简单，你实现了这个协议，这个协议，作为被代理者，它不知道自己什么时候执行。然而，当我们每次通过类的静态方法发送一个请求的时候，AFNetworking会通过代理，然后调用\n\n```swift\nfunc didReceiveDicResults(results: NSDictionary, tag: String) {....}\n```\n\n这时候，在里面的\n\n```swift\nself.delegate?.getResult(tag, results: results[\"content\"] as NSDictionary)\n```\n\n会把直接调用被代理者的方法，然后，由于我们在VC中是一个代理者，自然可以接收到这个代理信息（方法的内容），也就完成了数据传递。 **数据的流向：从AFNetworking，经过我们的类，然后转入APIGetter协议，最后到了VC的方法里面**\n\n其实，主要是由了AFNetworking这个代理在这里，才让过程分析比较复杂（其实这构成了一个含有2个代理的代理链……）\n\n现在，我任何的VC中只需要6行代码就可以搞定之前需要100行的东西，多重构才是王道……代理的作用十分明显，以后除了内部算法实现，千万千万不要写基于过程或者拿靠函数堆积的那种代码了，多用代理，多用协议，继承，才是真正意义上的iOS开发。","categories":["iOS"],"tags":["iOS","Swift"]},{"title":"推荐一个Swift以及iOS开发的Git合集","url":"/2016/03/30/%E6%8E%A8%E8%8D%90%E4%B8%80%E4%B8%AASwift%E4%BB%A5%E5%8F%8AiOS%E5%BC%80%E5%8F%91%E7%9A%84Git%E5%90%88%E9%9B%86/","content":"\n<p style=\"text-align: left;\">\n  地址在此：\n</p>\n\n<p style=\"text-align: left;\">\n</p>\n\n<a title=\"SwiftGuide\" href=\"https://github.com/ipader/SwiftGuide\" target=\"_blank\"><strong>https://github.com/ipader/SwiftGuide</strong></a>\n\n里面包括但不限于这些内容：\n\n1.  <span style=\"font-size: 13px;\">Swift语法</span>\n2.  Swift和Objective-C合作\n3.  <span style=\"font-size: 13px;\">iOS开发</span>\n4.  <span style=\"font-size: 13px;\">Cocoa框架</span>\n5.  设计模式\n6.  函数式编程思想\n7.  常用UI控件、库\n8.  实际Swift项目\n\n喜欢的赶紧过去看看点个Star……重要的事情我只说一遍    ","categories":["iOS"],"tags":["iOS"]},{"title":"朋友圈好友关系建模设计—动态评论设计","url":"/2016/03/30/%E6%9C%8B%E5%8F%8B%E5%9C%88%E5%A5%BD%E5%8F%8B%E5%85%B3%E7%B3%BB%E5%BB%BA%E6%A8%A1%E8%AE%BE%E8%AE%A1%E2%80%94%E5%8A%A8%E6%80%81%E8%AF%84%E8%AE%BA%E8%AE%BE%E8%AE%A1/","content":"\n接上一篇，我们有了好友关系之后，就又涉及到了怎么样处理“只能看到好友的动态，和好友在好友动态下的评论）\n\n其实关于获取好友状态，已经不成问题，从数据库中读取出来就行了，最后统一出一个好友列表，然后进行查询就行了。关键的地方在于这个好友动态的排序以及评论呈现。\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/1/c6/189c18dfe1efe7c7e93052ad0edf2.png)\n\n1、关于评论和动态的获取\n\n我们采取的方式是：后端返回全部动态，前端进行排序。这样的好处是大幅减小了后端的压力，因为如果不这样，后端得依次进行如下操作：\n\n**获取当前用户 -> 获取用户的好友列表 -> 对每个用户的好友选择出所有动态 -> 对所有好友选择出来的动态进行排序 -> 对最后结果只返回前n个（后续的再次发送请求获取）**\n\n这样的方式对于小型服务器来说是致命的，举个例子，1个人有50个好友，每个好友20个动态，每个动态5条好友评论，光是获取所有好友动态就必须查询50*20*5=5000条记录，然后还要对这5000条记录进行排序，最后选择出指定100条。这中间还没有包括根据好友进行评论过滤，匿名信息的转换之类的过程，可想而知，一旦大量用户登录查看动态，服务器将压力非常大。\n\n因此，我们将排序做到了前端，后台在进行查询的时候，查询的时候只查询到动态层面，评论在用户点击指定动态之后才会获取，将一步的动作分成两步，用户在下拉浏览的同时发送新的获取评论请求，服务器再返回指定动态的评论，这样就将5000化为50*20+n*5,n为每页显示的动态数，大大减缓了服务器的压力。同时，通过缓存技术比如Memcached，保存用户的好友动态，防止用户首页快速刷新造成大量的请求。\n\n2、关于评论的呈现\n\n仔细一想，评论其实满足了一种树形结构，因为我不但可以评论这条动态，也可以评论之前的评论，所以，在存储评论的时候，我们可以加入一个parentID，再配合messageID（根节点，动态的ID），就可以进行前端的评论的树形结构生成，大概的数据表就是这样：\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/2/39/165349718710a96085446deca2c48.png)\n\n这样，基本的功能就完成了，其实现在想想都是很简单的设计，只不过以前并没有做过和思考，导致当时开发遇到了一点点小问题－ －～\n\n就到这里吧，最后再次广告：github：https://github.com/lizhuoli1126/FriendCircle","categories":["Web"],"tags":["PHP","SQL"]},{"title":"朋友圈好友关系建模设计—好友关系设计","url":"/2016/03/29/%E6%9C%8B%E5%8F%8B%E5%9C%88%E5%A5%BD%E5%8F%8B%E5%85%B3%E7%B3%BB%E5%BB%BA%E6%A8%A1%E8%AE%BE%E8%AE%A1%E2%80%94%E5%A5%BD%E5%8F%8B%E5%85%B3%E7%B3%BB%E8%AE%BE%E8%AE%A1/","content":"\n上周学院举办了一个建模比赛中：http://www.ippclub.org/index.php/archives/33/\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/3/96/05ea1626712a1db418daf7b65050c.png)\n\n最后成品放在了github上面：https://github.com/lizhuoli1126/FriendCircle\n\n为了实现这个朋友圈的关系，确实有很多值得思考的地方。\n\n第一个难点就在于这种朋友关系的设计。\n\n第一种方案就是最简单直观的方法：一条记录对应一个朋友关系，user1和user2是好友，relation为friend。但是这样导致的问题就是会出现一条重复纪录，因为 ‘朋友’ 是一个双向关系，所以不应当user1,user2,friend和user2,user1,friend重复出现。\n\n第二种方案就是在后端选择的时候加以判断，用 or 来选择两者之一。这样虽然后端的复杂程度增加了，但是其实只是一个选择判断语句，却换来了一半的IO请求，能大幅提高效率。查询的时候使用如下的SQL语句就可以了。\n\n```php\n$userFriendList = $this->query(\"SELECT userID1,userID2 FROM relation WHERE (userID1 = '%s' OR userID2 = '%s') AND state = 'friend'\",$userID, $userID);\n```\n\n随后，就是实现添加好友和删除好友。同样的，如果不加以选择，又回产生冗余纪录。添加好友肯定有一方是发送方，一方是接收方。如果不加以判断，会出现user1,user2,send和user2,user1,accept这种等价的两条记录，影响数据库读写效率，不可取。所以，正确的方法应该是在relation里面只有send，通过后端选择的时候进行判断，添加好友时候，如果user1和当前user相同，就是user1,user2,send，否则，就产生一个user2,user1,send。即如下：\n\n```php\nif($checkFriendState[0]['userID1']==$userID1){\n\treturn true;\n}\nelse{\n\t$userFriendSet = $this->execute(\"UPDATE relation SET state = 'friend' WHERE userID1 = '%s' AND userID2 = '%s'\",$userID1,$userID2);\n\treturn true;\n}\n```\n\n第二个难点，也是二级需求里面的：3、屏蔽指定好友状态 4、禁止指定好友查看个人信息、朋友圈。\n\n仔细分析，其实发现这个问题就是两种屏蔽状态的组合：屏蔽好友动态和屏蔽好友信息。\n\n第一种方案：对屏蔽动态和屏蔽信息看成两个relation，都放在state字段中。这样的想法固然好，但是，如果继续要保证每两个用户之间只有一条记录，不仅state本身需要添加总共4×4（1对2屏蔽，2对1屏蔽，都不屏蔽，都屏蔽）个枚举值，后端的逻辑判断也非常复杂。这种方法虽然能想，但是不可取。\n\n那么怎么办？行不可以咱们就改成列，第二种方案：增加两个新的字段：forbidMessage和forbidInfo，分别对应屏蔽动态和屏蔽信息，每个字段有四种状态（1to2，2to1，none，all）这样，在后端查询的时候多选择两列就可以简单判断出两个好友之间的屏蔽关系（对于数据库，多select出一列远比多扫描一倍字段要来的快）\n\n查询大概就是这样的吧，比如查询是否屏蔽好友动态，可以这样，之后对forbidMessage进行判断就可以了。\n\n```php\n$userFriendList = $this->query(\"SELECT userID1,userID2,forbidMessage FROM relation WHERE (userID1 = '%s' OR userID2 = '%s') AND state = 'friend' AND forbidMessage != 'none'\",$userID, $userID);\n```\n\n有了这样的分析，数据库建立起来就很轻松了，relation表大概就是这样：\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/f/80/306bc9a3a895a5a424cb9899824b9.png)\n\n有兴趣的话，大家可以去我的github上看看最后的Demo（注意要看readme）~~~~~","categories":["Web"],"tags":["PHP","SQL","建模"]},{"title":"第一次Hackathon之旅","url":"/2016/03/30/%E7%AC%AC%E4%B8%80%E6%AC%A1Hackathon%E4%B9%8B%E6%97%85/","content":"\n> [Unique Hackday][1]之旅\n\n# 启程\n\n上周之前，我参加了由GitCafe举办的《开源者行》的上海站，在那里，不仅见识到了很多非常出色的小伙伴，最终的Ideathon上面，我们小组获得了优胜并且我被邀请组队参加了这次的Hackathon。\n\n我们这组小队都是《开源者行》选出的来的，有自北航的`林泉沛`（ACM算法向）、来自上交的`卢涛南`（JavaScript好手）、还有来自福建的`温荣泉`（Unity开发者），在经过1周的水群和漫无止境的脑洞之后，还是没有最终定下Idea。不过Whatever，大家还是非常乐观的一同奔赴武汉。\n\n6月5号，经过长达5小时的旅途（又是一段坑人的旅途），我终于成功面基，林大大展现出他的学长风范，带我小转并且吃了一顿，并深深的体会到了繁华的武汉的意义（对比南京郊区，我感到了深深的恶意……）我、林大还有温荣泉住在一起，大家又快速脑洞了一下，基本提出了几个点子，为了养精蓄锐，大家也就不浪了，快快入睡。\n\n# 开始\n\n早上我们早早到了华科的启明学院，感叹华科有钱的同时又感慨学校能够这么重视一个团队（启明学院基本上是各类专业的实验班，主要目标是创新和能力，而联创中大部分人都在启明学院），负责人很是贴心呀，给了各种小奖品还有一个T恤，我们默默的坐在了会议室后面，听前面各种开始讲解联创团队的历史，讲解创新工场的意义…………我们假装听得很感兴趣，底下边考虑着Idea。\n\n终于，到了12点，正式的Hackathon开始了，我们直奔2楼，抢了个风水宝地，大家拿出各式装备（这里省略各种土豪本，Retina MacBook 15`、HKKB等)，有人直接就开始敲起，我们则快速敲定最终idea，上网开始查资料。虽然我们最开始是想要做一个游戏的，但是总找不到好点子（缺少PM的队伍最可怕的结果），经过1个小时的疯狂脑洞，我们最终决定做这个看起来有点无聊，但是又不是那么无聊的弹幕系统\n\n**[CrystalBarrage][2]**\n\n> 最终成品\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/e/7a/2ede22b51443bf6ff2fb0629dbc16.png)\n\n# 编码\n\n这部分其实没有什么说的，我们风骚的敲起代码，我负责Web Server，卢涛南负责前端JS和那个Chrome插件，而温荣泉负责他的Unity版本，林泉沛负责临时当PM以及算法辅助。老样子，基于WebSocket的连接，确保了高效率，快速迭代，后端基本就是靠阿里云，同时微信再现场看看API怎么用，很快基本原型就弄好了。当然，其中也是有很多坑，比如`Unity`只支持`.NET 2.0`(我*)，所以WebSocket没有好的库，我和温荣泉硬是现场查了WebSocket协议，基于一个不能用的网络框架再手写让它跑了起来（真是……）\n\n# 熬夜\n\n其实我当天觉得精神非常不错，集中到一个点上你就忘记了时间。我基本保持了从中午12点坚持到了第二天早上7点多（原型大概只用了8小时，基本后面时间都在水，细化UI和安全之类），然后睡了2小时，大家一起做了PPT，排演了一下，还有压力测试之类的，10点不到就提交了上去……\n\n当然，我们并不是提交最快的，有一对甚至开场4小时就收工了。中间可以看到各个队伍的黑科技，有带单片机过来的，有的带了几个VR眼睛，还有理所当然的利用LeapMotion的……还有印象的中间提供的饭菜除了夜宵那个小龙虾以外，其他的都是异常之坑爹（……），Anyway，都结束了。\n\n# 展(nve)示(gou)\n\n终于到了展示环节了，一路上，你可以看到各种类型的游戏，有那种设计感非常好的（一看就是带了设计狮过来的），有那种黑科技非常多的（VR之类）……还有那种移动IM，医疗，音调识别等。\n\n我最喜欢的游戏是一个[`多人划桨游戏`][4]，大家摇手机表明划桨，每个人会分配到一个船的特定位置，然后根据不同人划桨（摇手机）频率决定了船是向左转还是右转，还是快速前进。无论是这个识别算法还是创意都非常好（大家一起摇手机……）\n\n我们队伍，嘛，充分利用了现场3台显示屏，一台显示PPT外加弹幕，另一台显示网页版的弹幕，还有一台是Unity的弹幕，然后调动现场观众加我们微信公众号，大家的活跃度确实厉害，弹幕基本没有停过，而且三台显示屏的同步效果非常好，至少我们觉得，足够表现我们的产品了。\n\n不过Sadly，最终我们也是酱油了一把（甚至那个划桨游戏也酱油了，不科学……）\n\n最终的大奖是一个基于iPhone的显微成像识别应用，有一个外设显微镜头，可以观察到载玻片上的细胞结构（非常之清晰），还能自动识别分辨出细胞核还是细胞壁，算法也是异常厉害，大家可以看[这里][5]。\n\n# 总结\n\n人生中的第一次Hackathon，其实感觉还是非常好的，虽然没有拿上奖，但是Hackathon正如它的精神一样，拿奖更是一个鼓励，只要大家能够享受这次24小时的努力，看着自己的成品从纸上的概念一点点通过代码实现，最终完成的过程，这才是最为吸引人的。同时，你更能体现出团队合作的意义 ，接触到各种你平时不容易接触到的人，无论是程序员还是设计狮们，都是非常有趣的体验！\n\n推荐大家都去尝试一次吧～\n\n> 合照\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/6/9f/051d44e76dc8adad53771328a99d2.jpeg)\n\n [1]: http://hacks.hustunique.com\n [2]: https://github.com/lizhuoli1126/Crystal-Barrage\n [4]: https://github.com/snowson/Boat4Four\n [5]: http://weibo.com/uniquestudio#_rnd1434008868583","categories":["Life"],"tags":["Hackathon"]},{"title":"简单的FP中思想在实际小项目中的应用","url":"/2016/03/30/%E7%AE%80%E5%8D%95%E7%9A%84FP%E4%B8%AD%E6%80%9D%E6%83%B3%E5%9C%A8%E5%AE%9E%E9%99%85%E5%B0%8F%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/","content":"\n[函数式编程][1]，无论是谁，第一次听到都会感到好奇，疑惑以及畏惧。因为一提到函数式编程就会让人想到很多数学或者计算机科学理论研究的深奥原理，无论是[Lamda演算][2]还是[高阶函数][3]，似乎都和平常自己所接触到的编程语言毫无关系。\n\n随着现代语言的发展，大多数传统面向对象语言已经支持了很多函数式编程中的语法，比如说：\n\n[闭包][4]：就是指一个函数块，把连同这个函数所需要的所有参数（全局的or局部的）放入一个闭包中，然后这个函数可以单独用来执行，不会因为外部变量被修改而产生额外影响。相当于这个函数的上下文全部被保留了下来。\n\nLamda表达式：通俗点说，就是一个简单的闭包函数，通过表达式的方式来进行执行，而不需要再写复杂的逻辑指令式代码，或者无数的花括号来表明相关的上下文逻辑。这点对于简化繁杂的逻辑代码非常有帮助。\n\n回调与改善的异步：其实，回调函数说实话也就是一个函数指针，也许很多人也用过，但是其实它的作用非行强大，如果你一直只接触过Java，C99的话是很难真正理解它对于IO或者网络请求的意义。尤其当你要处理多个异步事件流程，异常处理时，你就会发现它的真正意义。\n\n其实，如果不是一定要从理论高度彻底理解函数式编程，没有必要从头看SICP或者所谓《21天精通Haskell》……（别打我），像Swift，C#，Java8，Python，C++11这种面向现代的语言中，都会有对于Lamda表达式的支持，像JavaScript这种更是纯粹可以当作函数式语言来写。所以，其实你已经在不知不觉中使用了函数式的一些思想，今天我就大概举几个例子来说明一下。\n\n## 1\\. 闭包\n\n何谓“闭包”？简单的说就是一个把所有自由变量（全局变量，局部变量）包在一起的函数，什么叫做包在一起？就是指这个闭包中进行的任何操作，都不会对外部造成影响，外部变量的修改甚至是销毁，也不会影响闭包内部引用的全局变量。 是不是挺起来感觉有点奇怪，其实很多语言实现闭包的时候，都是把全局变量拷贝了一份到闭包内部，有些语言支持闭包内部修改外部变量（需要特殊的声明，比如说Swift的inout关键字） 比如下面一个简单的数组排序，用函数和闭包两种方法实现\n\n```swift\nvar name = [\"one\",\"two\"]\nfunc compareName(s1:String,s2:String) -> Bool{\n    return s1 < s2\n}\nvar sortArrayByFunc = name.sorted(compareName)\nvar sortArrayByClosure = name.sorted({\n    (s1:String,s2:String) -> Bool in\n    name.removeAll(keepCapacity: true)\n    return s1 < s2\n})\nprintln(name)\nprintln(sortArrayByClosure)\n```\n\n![](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/f/fa/c2499a9bce100ff9e18f392609d5d.png)\n\n结果正如我们所料，就算你在闭包内部把name数组清空了，排序后的新数组返回的内容还是不变，这个name数组在闭包被拷贝了一份，你所有更改都不会影响到它（甚至外部的name被release也是）。\n\n## 2\\.匿名函数\n\n匿名函数，顾名思义，就是没有名字的函数……这其实不是很稀奇，因为Swift中就有外部参数名和内部参数名，因为当你认为一个函数可以当作参数的时候，它的名字（外部参数名）就可以省略，也让整个代码看着简单一些。比如JavaScript可以这样写～\n\n```javascript\nfunction functionOne (functionTwo) {\n    functionTwo();\n}\nfunctionOne(function(){\n    console.log(\"I have no name~\");\n})\n```\n\nSwift就像这样写：\n\n```swift\nfunc functionOne(functionTwo:()->()) -> void{\n    functionTwo()\n}\n\nfunctionOne({\n    println(\"Seems like JavaScript!\")\n})\n```\n\n也很好理解吧？就是把一个函数的外部名称去掉而已，简化了代码的繁冗（不然你会看到一段代码中各种无意义的小函数的名称，而且还容易导致名称冲突……） 匿名函数通常都是一个闭包，意思你的匿名函数访问外部变量时候是通过拷贝的，当然，不同语言的语法可能不太一样，建议用的时候要多加注意。\n\n## 3\\.尾递归\n\n递归函数大家都会用，最简单的求阶乘的应用就可以用两行简单的递归搞定。\n\n```swift\nfunc factorial(n:Int64) -> Int64{\n    if (n == 1){\n        return 1\n    }\n    else{\n        return factorial(n - 1) * n\n    }\n}\n```\n\n看起来很完美对吧？（当然，为了简化，没有对参数进行任何验证，而且实际也不应该用Int64来存放数字），但是，有没有想过如果我传过来的参数非常大，比如100这样（结果非常大，实际上这时候的结果已经超过Int的最大值了，有人可能这时候就用String之类来存放结果，但是这里讨论的重点不是这个）\n\n![普通递归执行的示意图](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/b/f8/1d2434005481a33dde2ed357b09de.png)\n\n当执行factorial(100)的时候，会发生什么呢？你会在栈中存放100个factorial()，包括函数的地址，函数里面定义的参数，变量……如果再大一点，你马上就见识到[StackOverFlow][7]的美景。\n\n怎么办？这时候尾递归就派上用场了。尾递归，顾名思义，就是把前一次递归的函数直接返回一个结果，释放掉相应的空间（出栈），然后执行新的递归，无论有多深的递归，真实存在于栈中的只有一个，这样就不会因为栈空间不足而导致程序崩溃了。\n\nOK……其实一般来说改造都是很简单的，只需要对原来的参数新加一个，用来存放前一个递归的结果就可以。就像这样～\n\n```swift\nfunc factorialTail(n:Int64,result:Int64) -> Int64{\n    if (n == 1){\n        return result\n    }\n    else{\n        var product = result * n\n        return factorialTail(n - 1,product)\n    }\n}\n\nfunc factorialByTail(n:Int64) -> Int64{\n    return factorialTail(n, 1)\n}\n```\n\n(为了所谓的用户体验，所以用一个factorialByTail()来调用真正的递归……一般也是这样的，在这里进行一些数值判断或者更好的优化）\n\n![尾递归改良版的示意图](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/0/70/4985a8f68dd733af308d0da0c4905.png)\n\n和上一个版本的递归比，确实就是多了一个参数来存放上一次递归的结果，但是能非常有效的解决栈溢出的问题，在实际问题中也是非常实用的（甚至说必不可少的），大概到这里就可以了\n\n## 4\\.lambda表达式\n\n对于没有接触过lambda这个字母（希腊字母）的人，这个东西听起来就和我第一次听到什么半幺群的感觉一样…… 但其实，lamda表达式就是一个匿名函数的简化写法（别打……），不过正如很多编程大师说的，能够写出精简、易懂、易修改的代码才是真正的好代码。如果处处使用匿名函数，你的代码讲会变得异常之长，多层嵌套，各种花括号……这对于阅读和修改都是一个灾难，所以，这时候lamda表达式来拯救我们了。\n\n支持lamda表达式的现代语言有很多，比如C++11、C#、Java8、Scala、Python（可惜Swift只有闭包而没有支持lambda，一般是通过预先定义几个func来传入参数或者使用闭包的简写方法来简化代码，在这几个编程语言中基本我都是只停留在会语法的层面……所以这里我选择使用C++11来写）\n\n既然你已经知道lambda表达式实质就是一个匿名函数，那么我们就直接开始干活吧，看看C++11的写法\n\n> [详细的C++11 lambda表达式][9]\n\nC++11的lambda写法有点奇葩……大概是这样[]()->void{...}这样写(mutable是值是否在这个匿名函数内部修改外部的自由变量）\n\n```cpp\nvector<int> myVector(10,0);\nint counter = 0;\nfor_each(myVector.begin(), myVector.end(),[&](int i) mutable throw(string) ->void{\n    cout<<++counter<<endl;\n});\ncout<<counter<<endl;\n```\n\n怎么样……相比于for循环来遍历，其实这个有时候看的更清楚（真的吗？），当然，Swift也可以写出类似的优雅的代码～like this:\n\n```swift\ninit(){\n    knownOps[\"+\"] = Op.BinaryOperation(\"+\"){ $0 + $1 }\n    knownOps[\"-\"] = Op.BinaryOperation(\"-\"){ $1 - $0 }\n    knownOps[\"*\"] = Op.BinaryOperation(\"*\"){ $0 * $1 }\n    knownOps[\"/\"] = Op.BinaryOperation(\"/\"){ ($0 != 0) ? $1 / $0 : nil }\n    knownOps[\"^\"] = Op.UnaryOperation(\"^\"){ $0 * $0 }\n    knownOps[\"√\"] = Op.UnaryOperation(\"√\"){ $0 >= 0 ? sqrt($0) :nil }\n}\n```\n\n这是一个简单的计算器的计算函数，Op是一个枚举类型，Op.BinaryOperation对应双操作数的运算，Op.UnaryOperation对应单操作数的运算，不需要每个运算（加减乘除）定义一个函数，只需要一个简单的闭包（Swift的闭包简写，如果返回值只有一行语句可以把花括号放到整个参数列表后面，用`$0`代表第一个参数，所以写起来可以非常简单）\n\nlambda表达式的关键就在于能够配合很多内置的方法来使用，比如map，reduce，避免了繁荣的for循环，而且在多层嵌套里面再也不用数花括号的个数来写，看起来非常简单明晰，便于维护。所以我很推荐使用。\n\n**就到这里吧……正如题目所说，这里只写了简单的FP思想，以及简单的应用，不会深究函数式编程的实质和lambda演算的内容……有兴趣的话买一本[SICP][10]看看你就懂了～～～**\n\n [1]: http://zh.wikipedia.org/w/index.php?title=函數程式語言\n [2]: http://zh.wikipedia.org/wiki/Λ演算\n [3]: http://zh.wikipedia.org/wiki/高阶函数\n [4]: http://zh.wikipedia.org/zh-cn/闭包_(计算机科学)\n [7]: http://en.wikipedia.org/wiki/Stack_overflow\n [9]: http://en.cppreference.com/w/cpp/language/lambda\n [10]: http://book.douban.com/subject/1148282","categories":["Code"],"tags":["iOS","Functional","JavaScript"]},{"title":"近期参与的APNG和WebP开源项目的经历及感受","url":"/2017/07/25/%E8%BF%91%E6%9C%9F%E5%8F%82%E4%B8%8E%E7%9A%84APNG%E5%92%8CWebP%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%BB%8F%E5%8E%86%E5%8F%8A%E6%84%9F%E5%8F%97/","content":"\n> 这篇文章讲的是有关近期自己参与的几个开源项目的经历以及感受，不过巧合的是内容都和APNG和WebP这两种图像格式相关，阅读前建议先简单略读一下之前写的一篇文章：[客户端上动态图格式对比和解决方案](http://dreampiggy.com/2017/03/06/%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8A%E5%8A%A8%E6%80%81%E5%9B%BE%E6%A0%BC%E5%BC%8F%E5%AF%B9%E6%AF%94%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/)\n\n# SDWebImage\n\n[SDWebImage](https://github.com/rs/SDWebImage)是iOS平台上非常著名的图片下载、缓存库，而今年发布的SDWebImage 4.0在架构、接口变动并带来性能优化的同时，还支持了Animated WebP，因此我就高兴地去实验了一下，本想着可以替代之前使用的[YYImage](https://github.com/ibireme/YYImage)。但是一测试就发现渲染不正常，追回去看源码，发现SDWebImage的实现可以说是Too naive，压根没有按照WebP规范实现，大部分Animated WebP动图渲染都挂了，完全不可用（连测试都过不了，更别说生产环境了）。演示Demo在此：[AnimatedWebPDemo](https://github.com/dreampiggy/AnimatedWebPDemo)\n\n总结出来的具体问题有以下几个：\n\n1. SD绘制每帧的canvas大小不正确，在代码中，直接取得当前帧frame的大小，而非整个canvas的大小。这就导致最后生成的所有帧图片的数组中，每帧的图像大小不一致。这样渲染就会出现Bug（把所有帧拉伸到最大的那个图像大小上）。\n2. SD的实现没有考虑过[WebP Disposal Method](https://developers.google.com/speed/webp/docs/riff_container#animation)，这个在很多动图中都会用到，因为能够重复利用前一帧的画布，来大幅减少最后生成动图的体积。常见的动图格式如GIF、APNG生成工具一般都采用这种Disposal，不然最终文件体积较大（但Google提供的WebP工具暂时没有自带这种优化的方式，一般使用第三方工具处理）。\n3. UIKit自带的`UIImage.animatedImages`是非常弱的，SD并没有提供额外的抽象，而是直接用的这个接口。这带来的最大的问题，是UIImage需要提供一个图片数组和总时长，但是会对数组中每个图片平均分配时长。这与Animated WebP的规范就是不同的，后者允许对每帧设置一个不同的持续时长。\n4. UIImageView直接设置`image`属性，是不支持设置循环次数的，会默认无限循环播放。而有些Animated WebP图片需要有循环次数。\n\n\n既然知道这么多坑，想着SD毕竟是主流框架，就赶紧提了[Issue](https://github.com/rs/SDWebImage/issues/1951)，但是过了一周多，SD社区依然没有任何回应。于是尝试自己一个个解决。最后的成果也比较好，上述4个问题都得到了解决。\n\n## Canvas大小问题\n这个问题，可以直接通过libwebp的API，修改来使用canvas大小而不是frame大小，确保每帧最后的图像大小相同。其中，为了优化性能，对于透明的且frame比canvas要小的帧，绘制出来等价于将frame平移，然后所有剩余部分填充透明值。在使用CGBitmapContext的时候，可以直接在要传入的Bitmap矢量数据上做变换，减少绘制带来的开销（不过CGBitmapContext本身应该有优化，对于这个开销影响不大，但参考YYImage里面有这一步处理）\n\n## Disposal Method支持\n在绘制每帧时，按照Animated WebP规范，共享一个全局的CGContext当作canvas，根据每帧不同的Disposal Method，如果为Disposal Background，则在绘制完当前帧后清空CGContext，否则的话不处理，保留到下一帧继续绘制，最终测试和YYImage行为一致。\n\n## 每帧持续时长相等问题\n\n这个问题相对比较麻烦，因为你无法改动UIKit实现方式。最后想了一个比较Trick的方式。思路也简单，考虑这样的情况：第1帧持续时间：50ms，第2帧持续时间：100ms，第3帧持续时间：150ms，总共时长300ms。在依然使用UIImage的接口情况下（即数组每帧时长平均分配），那就可以提供一个[1, 2, 2, 3, 3, 3]（元素表示帧的编号）的图像数组，总时长300ms。这样的话平均分到每个元素是50ms，表面上看是6帧但实际渲染是3帧，也能达到最后的显示效果。这样实现的话，只要求一个所有帧持续时间的gcd，然后对每帧图像，按该帧所占的比例重复添加多次就可以了。\n\n## 循环次数问题\n\n由于SD的接口问题（用到了UIImageView的`sd_setImageWithURL`），是直接设置到`UIImageView.image`上的，而不是`animationImages`。而直接设置`image`会无视掉`animationRepeatCount`这个本来用于设置循环次数的属性。但如果SD框架自动设置`animationImages `属性的话，可能对使用者现有代码有影响（因为使用者还是用的`image`属性而不是`animationImages`属性），因此最后的解决方案，是在UIImage的扩展中，单独提供了一个`sd_webpLoopCount`的属性来获取循环次数，使用者可以自行设置UIImageView的属性，来实现指定循环次数。\n\n举个例子，一般情形下（显示的动图超过循环次数后停到最后一帧上）就可以这样子用。\n\n```objectivec\n[imageView sd_setImageWithURL:webpURL completed:^(UIImage * _Nullable image, NSError * _Nullable error, SDImageCacheType cacheType, NSURL * _Nullable imageURL) {\n    imageView.image = image.images.lastObject;\n    imageView.animationDuration = image.duration;\n    imageView.animationRepeatCount = image.sd_webpLoopCount;\n    imageView.animationImages = image.images;\n    [imageView startAnimating];\n}];\n```\n\n\n这也算是一个解决方式吧。\n\n## 感受\n\n在写完这些，跑过单元测试，提交了[Pull request](https://github.com/rs/SDWebImage/pull/1952)之后，回头来看，才能真正感到YYImage的实力。\n\nYYImage通过一个抽象层YYImageFrame，来把GIF、APNG和Animated WebP三种格式统一到一起，并且提供了Encoder和Decoder可以在三种格式来\u0010互相转换（这是重点）。关于绘制部分，还使用到了[Accelerate Framework](https://developer.apple.com/documentation/accelerate)，通过vImage的GPU加速的Bitmap变换来替代部分CGBitmapContext绘制。在缓存上，由于SD的抽象层存在，他使用了[ImageIO](https://developer.apple.com/documentation/imageio)来直接缓存CGImageSource（SD采用的是缓存了WebP的rawData），效率提升了很高也减少缓存大小（速度对比的话，可以从那个Demo工程看到，checkout到`fix_sd_animated_webp_canvas_size`分支上运行）。想想还是挺佩服ibireme这个人的，看来以后还要多使用YYKit并多学习。\n\n# apng2webp\n\n[apng2webp](https://github.com/Benny-/apng2webp)是一个转换APNG到Animated WebP图片的命令行工具，使用Python脚本 + 外部命令行工具来实现。在之前的工作需求中，使用到来优化APNG的大小，并且产出Animated WebP来让客户端使用。\n\n为什么要转换APNG到Animated WebP呢，其实是因为APNG这个规范由于没有进入到PNG标准规范中，一直处于一个不温不火的地步，网上的APNG动图数量也不多，很多网页的PNG图片上传也不支持。虽然如今各大浏览器都对APNG提供了支持（\u0010Chrome 59正式支持了APNG，iOS很早从8.0支持，FireFox就是亲爹一直推动），但是客户端上，Android端没有相对靠谱的解码和渲染组件能够使用。反倒是Animated WebP借助Google亲爹推动，成为Android天生支持的图像格式，并且iOS上也有YYImage来提供支持。随着WebP的流行，越来越多设备估计都会支持WebP和Animated WebP，甚至最终超越GIF这个广为流行，但是已有30年历史，只支持256色和1位alpha通道的古老动图格式。\n\n这次对apng2webp项目，主要是贡献了两个功能。\n\n1. Windows的支持，即现在三大桌面端命令行均可使用\n2. CI自动Build和Test\n\n## Windows的支持\n\n由于整个外部命令行工具(有四个工具，其中`cwebp`和`webpmux`是Google官方提供的，有Windows Build，另两个是源码编译）都是UNIX工具链下的，依赖几个C++库也挺常见，但是尝试过使用VS 2015源码编译跪了，使用[vcpkg](https://github.com/Microsoft/vcpkg)这个非常新的Windows上的C++包管理工具，又爆了一堆[link error](https://www.zhihu.com/question/62158323/answer/196189709)。对于我这种C++菜鸟来说，最后只好选择了直接上[Mysys2](http://www.msys2.org/)和MinGW-w64，一键`pacman -S`安装依赖，cmake makefile可用，跑了一遍测试也没问题，确实非常方便。由于MinGW-w64的编译产物，会依赖于libgcc，winpthreads，为了使最后的分发方便，于是在Windows上改用静态链接。\n\n## CI和单元测试\n\n关于Python的单元测试，由于这是一个简单的命令行工具，最后就通过引入pytest，直接对main函数和外部工具进行了测试，写起来也特别简单（自动匹配文件名和类名这点挺好）。用起来感觉比起Objective-C和Java的工具要好用多了。\n\n在CI Build上，对于Linux和macOS的话，一般都会使用GitHub官方合作的[Travis CI](travis-ci.org)，配置使用yml语法，再加上一系列的Bash命令。而Windows上使用的[Appveyor](https://ci.appveyor.com/)也非常好用，自带了`VS 2012,2015,2017`，`Msys2`，`MinGW-w64`，`cmake`等一系列工具，上手开箱即用。配置的话注意要使用CMD或者PowerShell，如果不熟悉，甚至可以用Msys2装一些UNIX工具来搞定（好处之一）。\n\n## 感受\n\n总体来说，这个项目主要是苦力活，不过也算熟悉了一下UNIX工具在Windows上移植的一种手段，而且还学习到了pytest和开源项目的CI Build方式，也算有点意思吧。\n\n# iSparta\n\n[iSparta](https://github.com/iSparta/iSparta)是一个图形化的APNG和WebP转换工具，包含了很多功能（APNG合成，WebP转换，图片压缩等），虽说是开源项目，但是上一次提交已经是三年前了。而我最希望的APNG转换Animated WebP功能却没有实现（这也难怪，三年前Animated WebP规范还没出来）。大概看了一眼，使用的是[NW.js](https://nwjs.io/)（其实用的是改名前叫做`node-webkit`的东西），是一个和[Electron](https://electron.atom.io/)类似的，使用前端技术栈来构建跨平台应用的框架，本质上都是一个Chromium的运行环境来提供渲染，再加上node.js来提供JS Runtime。上手相对容易。\n\n基本上的目标，是为了提供更好的GUI工具，因此主要就参考了一下iSparta的Issue，解决这几个问题：\n\n1. 支持APNG转换Animated WebP\n2. 支持i18n国际化\n\n由于我并不是专业前端出身（大二学过一段时间前端基本知识和Node.js简单应用，也接触过React Native），经过近两天的奋斗，才终于磕磕碰碰完成。期间遇到过各种问题（NW.js的问题，node第三方库的问题，跨平台行为不一致的问题等等），不过在这里略过说一下重点吧。\n\n## APNG支持Animated WebP\n\n关于这个功能，自然可以想到上面的apng2webp命令行工具，不过由于apng2webp本身是Python写的脚本来调用外部工具，没必要在NW.js里打包一个Python环境。因此最后就决定直接在JS里，实现了相同逻辑的脚本来完成。不过实话说这部分花费的时间不长，在GUI布局上才是重头。大体框架参考了项目中的已有写法，但CSS的部分由于实在生疏（原项目有一些布局Hack），最后使用了[flexbox](https://css-tricks.com/snippets/css/a-guide-to-flexbox/)布局来搞定的。\n\n## i18n国际化\n\n在网页端支持i18n国际化，这是确实是以前未接触过的地方。考虑到这个项目有大量散落的HTML文本中硬编码了中文文字，而又没有使用类似于Angular、React这种先进的技术来支持模板，因此就需要自行解决。最开始思考了使用服务端渲染的解决方案（即NW.js当作浏览器，本地起node使用express当作服务端，来返回渲染好对应国际化后的HTML），但是遇到了问题，当作纯浏览器后，NW.js无法再使用node端的本地包，这也就意味着无法调用外部的命令行工具（相当于RPC了）。因此这种方案不可行。\n\n再经过尝试后，最后使用的解决方案，是引入了[node-i18n](https://github.com/mashpie/i18n-node)和模板引擎（这里用的是[doT](olado.github.io/doT/)）。在项目目录下准备好i18n的文本资源（框架支持的是JSON格式）。然后在NW.js应用启动时加载一个空body的页面，执行JS来获取i18n后的字符串，再将这些字符串渲染到只有body的模板中，最后把国际化完成后的HTML body插入到原始的页面的body中。整个过程没有多余的开销（避免了模板未渲染前被显示出来，而且可以缓存模板结果，因为实际上给定一种locale，模板生成的HTML是固定的）。\n\n## 感受\n\n其实现在看看自己平时用到的应用，`Atom`、`VS Code`、`GitKraken`、`钉钉`，这些看起来已经足够复杂，也都能够用这种前端技术栈构建起来了。以前自己如果提到跨平台桌面客户端应用，第一反应就是Qt，不过现在看来，如果对前端技术栈有所了解，对性能和实时性要求不高，是可以使用Electron或者NW.js这种框架来构建。虽然曾经见过有人批判这些框架（体积庞大-打包了Chromium和Node；内存占用高，效率低下-WebKit渲染而不是原生UI组件），[reddit](https://www.reddit.com/r/programming/comments/64oqaq/electron_is_flash_for_the_desktop/)上甚至有讨论说这是新一代的Adobe Flash。\n\n但我个人看来，不排斥这样的框架，只是感觉如今的解决方案并不是十分完美，这些前端栈技术写的客户端最大的问题其实是代码复用问题，基本上是各家有自己的一套组件，而且很多解决方案很Trick。我觉得更为理想的情况，是能够提供一套完整的解决方案，包含了开箱即用的UI组件（并非指Bootstrap这种通用Web UI组件，而是专门针对桌面客户端优化的，符合客户端的交互方式），能够开发，构建，测试，打包一站式自动处理，足够多的Native桥接（这也是一大痛点，见过一些应用又回过头在Electron里面使用Flash），更多的优化，比如共享Chromium容器-不必每个应用的带上200MB的运行环境。\n\n总体来说，Electron或者NW.js这些框架的前途还是比较光明的，毕竟传统意义上的桌面应用开发成本还是太高，尤其是互联网公司的产品，追求跨平台的情况下，在成本，人力还有技术难点考虑来看，也是一个不错的选择。\n\n# 总结\n\n其实，这三个开源项目都是属于一时兴起才去贡献的，并不是为了而去专门寻找的，至于为什么都是WebP相关，或许真的是巧合吧。参与这些开源项目，虽然花费了一定的时间精力，但是获得的知识面上的提升确实非常大，包括但不限于：`WebP规范`、`Accelerate Framework`、`跨平台C++移植`、`Python单元测试`、`CI配置`、`NW.js`和`前端i18n`。\n\n说实话，参与开源项目的时候，你会发现一些社区是很有意思的，你能够和不认识的人去合作，还能够直观感受到其他人对项目的关注，更能够接触很多你之前从没有接触过的技术栈。我不能说自己是一个愿意花费大量个人时间去贡献开源事业的人，但是其实很多项目参与门槛不是那么高，无论是你自己平时用到的软件、类库，甚至是一个小工具、脚本、翻译、教程，都可以试着参与一下。我觉得程序员的知识，并不是为了单纯为了打工搬砖，能够把自己的想法与他人分享也是一个相当大的乐趣，不是吗？\n\n","categories":["Code"],"tags":["iOS","JavaScript","C++","Web","Image","开源活动"]},{"title":"阿里前端工程师（Node.js）向实习生面试经验","url":"/2016/03/30/%E9%98%BF%E9%87%8C%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%EF%BC%88Node-js%EF%BC%89%E5%90%91%E5%AE%9E%E4%B9%A0%E7%94%9F%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/","content":"\n## 前提说明：\n自己是在北邮论坛中找的学长内推，当时与学长问了关于阿里前端中是否有偏向JavaScript开发（中间件，工具库）的方向，学长说只有杭州有类似岗位，最后把我内推到了淘宝UED的团队去了。\n\n简历说明中侧重讲了关于Node.js的经历，JavaScript轮子的介绍以及一些使用了Node.js技术栈的Web项目。这点对于前端实习也是一个加分项。\n\n## 一面：\n一面面试官问了大概有4年开发经验（包括了Java和JavaScript），上来除了标准的自我介绍以外，大概主要谈论了关于Node.js，JavaScript语法以及Web开发的领域，对简历中提到的项目稍微深入问了一下。\n\n1. babel或者coffee Script的这些编译到JS的语言是如何工作的？\n这个问题是最纠结的，因为不太清楚面试官想问什么，大概说了关于Parse的东西，后面补充了关于babel的递归引用JS文件处理的东西，估计有问题。\n\n2. JavaScript的Async库基本原理是什么？\n这个网上都有，就是Async的parrllel，waterfall的简单实现，讲出了把callback function替换this域，用一个list来遍历执行，把最终的error或者result参数填回到Async.parallel([functionList], callback(err,result))中，差不多\n\n3. 你写的Functional.js中monad, curry, lazy的解释和意义？\n基本面向简历的作品，讲解了一点关于monad的简单意义（包裹，传递流，防止外部更改），curry化对JS库函数的意义，还有lazy list或者range对于那种大量数据处理的好处什么的。\n\n4. Node.js框架同其他语言框架的比较？\n答出Node.js特色的非阻塞IO和异步性，和Python的Flask对比，再讲解一下express中间件这种模式的特点，差不多了\n\n5. Node.js与Swift在Web领域的未来？（因为我简历写了iOS开发和Swift）\n随便扯吧……就是强类型的问题，基于原型面向对象优劣，语法糖的问题，还有支持库什么的。\n\n其他就是自由提问，知道了阿里淘宝对前端实习要求基本不高，主要是JS熟悉，会Node有加分，而且没有固定谁来切图谁写JS，一般都会一点跨栈的东西。\n\n## 二面：\n（二面充分暴露了自己的若菜本质）。面试官是Winter，就是那个知乎的温兆伦的Winter（P8）。二面是电话+网页coding的部分，需要在电脑，网络OK情况下进行，要自己提前准备好（不行就说明改个时间……）。开始电话问了一些关于JS的东西，什么闭包，Node.js的require依赖顺序什么的……之后就开始正式网页coding。\n\n1. 第一题：设计一个简单的红绿灯策略，比如红灯亮分别为console.log(\"red\")这种，要求按照红3s-黄1s-绿1s顺序不断循环展示。\n\n这个本来很简单的问题开始愣住了，因为原生的setTimeout好久没用了，问了问可以使用第三方库，但原生其实有笨办法，就是直接硬编三个setTimeout，时间分别为0，3s，4s，然后最外层一个10s延迟的setInterval的来重复。虽然效果但是这肯定不对，因为这直接无视了事件发生相对顺序，靠着全局时间来实现，长期下去由于JS引擎的延时会最终乱掉。\n\n第二种想法，我借用了Promise，大概就是用Promise里面resolve一个setTimeout的函数模拟事件结束，最后由Promsie.then控制流程，好处就是绝对不会出现事件先后顺序错乱，而且写起来简单。\n\n```js\nfunction button(color, time) {\n\tlet p = new Promise(function (resolve, reject) {\n\t\tsetTimeout(function() {\n\t\t\tresolve(\"Timestamp: \" + getTimestamp() + \" Color: \" + color)\n\t\t}, time);\n\t});\n\treturn p;\n}\n\n\nfunction flash() {\n\tbutton(\"red\", 3000) // after last task end, which means the last task will need 3s\n\t.then( (v) => {\n\t\tconsole.log(v);\n\t\treturn button(\"yellow\", 3000); // last spend 3s\n\t}).then( (v) => {\n\t\tconsole.log(v);\n\t\treturn button(\"green\", 1000); // last spend 1s\n\t}).then( (v) => {\n\t\tconsole.log(v);\n\t});\n}\n```\n\n2. 第二题：算法题，第一问是：给定一个整数金额的整钱n，还有2，3，5元三种货币，要你计算出所有能凑出整钱的组合个数。\n\n（这里又暴露自己思维模式问题）应该先从最简单想，假如n=10，把5，3，2元的取的张数定为i,j,k，一定要按照由大到笑顺序，那么就相当于从i=0,j=0,k=0开始循环，一旦组合总金额超过n，那么就break停止（因为从大到小取金额，最小的都无法凑出，那么之后再也不能取了），能凑齐就加一个组合。\n\n```js\nfunction countMoney(total) {\n\tif (total < 2) {\n\t\treturn 0;\n\t}\n\tvar result = 0;\n\tvar maxAmount = total / 2;\n\tfor (var i = 0; i <= maxAmount; i++) { // 5\n\t\tfor (var j = 0; j <= maxAmount; j++) { // 3\n\t\t\tfor (var k = 0; k <= maxAmount; k++) { // 2\n\t\t\t\tvar sum = i * 5 + j * 3 + k * 2;\n\t\t\t\tif (sum == total) {\n\t\t\t\t\tresult++;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (sum > total) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n}\nconsole.log(countMoney(10));\n```\n笨方法，但是外层不会超过 n / max[i]，所以复杂度最差也没有到O(n^3)\n\n第二问：假如这个能使用的货币列表是给定的，意思是输入一个整数list，比如[1,2,3,5]，还有金额n，求出所有组合数。\n现在货币列表不是定的，那么就得想别的方法，当时答的时候说要用递归，但是最终没写出来（唉……），在之后才写出来。\n\n前提思路用的是递归，function countMoney(amount, moneyArr)，amount为剩下的金额，moneyArr为可以选择的货币列表，返回的是产生的组合数，那么初始条件认为amount = n, moneyArr = list（排序，由高往低）。取出当前moneyArr（也就是当前最大的面值\n）的货币first，剩下的货币可选面额叫做smallerMoneyArr，然后从0到first最大能取的个数开始（即 0 ~ amount / first)，不断递归调用countMoney(remainingAmount, smallerMoneyArr)，加起来所有组合数即可。\n终止条件很简单，如果剩余余额不为0但可选货币为空，那么分割方法失败，返回0；如果余额是0，那么分割成功，返回1；搞定。\n```js\n//Recursive DP\n\nvar inputMoneyArray = [1,2,3,5];\ninputMoneyArray.sort().reverse(); // must from higher to lower\n\nfunction countMoney(amount, moneyArr) {\n\tif (amount != 0 && moneyArr.length == 0) {\n\t\treturn 0; // no use\n\t} else if (amount == 0) {\n\t  return 1; // success one\n\t}\n\t\n\tvar first = moneyArr[0];\n\tvar smallerMoneyArr = [];\n\tfor (var i = 1; i < moneyArr.length; i++) {\n\t\tsmallerMoneyArr[i-1] = moneyArr[i]; \n\t}\n\t\n\tvar sum = 0;\n\tfor (var i = 0; i <= amount / first; i++) {\n\t\tvar remainingAmount = amount - (first * i);\n\t\tsum += countMoney(remainingAmount, smallerMoneyArr);\n\t}\n\t\n\treturn sum;\n}\n\nvar result = countMoney(10, inputMoneyArray);\nconsole.log(result); // 20\n```\n\n然而……当时面试脑抽没想出来，后面就问了问一些前端开发要求还有工作环境什么的就没了……唉，还是没有准备的问题，如果真要面试，希望提前准备好一点常见题目，主要是思维方式要对，先最简单（从特例开始，变量假设为固定值），然后推广，复习一下递归，动态规划什么的就很简单。\n\n\n## 三面\n三面还是技术面，其实我也没有任何准备（以为二面挂了），面试官是淘宝一个P7级别的吧，也是上来自我介绍，然后开始问一些Node.js和JS（有前端JS）的问题，基本我全程都没遇到过HTML5，CSS，Web前端框架，构建工具等问题……可能是简历导致的吧。\n\n1. 说一下关于Node.js的文件读写方式和实现？\n基本解释一下fs.readFile，说明异步性，然后面试官开始追问：Node.js是单线程，如何实现多个同时的文件IO？\n紧接着就开始解释Node.js的fs调用V8的libuv中的`uv_fs_open`，绑定JS的callback到一个c的函数指针上，然后推入事件列表队列（QueueUserWorkItem），再根据操作系统，Windows下使用IOCP来完成异步IO，*NIX上使用libev来实现。说明Node.js从上层到V8是单线程，从libuv到IOCP或者libev是多线程IO读写\n\n2. 说一下JavaScript几种异步方法和原理？\n基础问题……先说callback function，说明问题，再讲Promise，包括Promise的原理和实现。然后还有co，利用generator和yield来实现异步控制，顺便也提到了async和await（虽然ES7还是没有加……简直服了），介绍一下使用经验，差不多了。\n\n3. 介绍一下Session和Cookie？\n不用解释了吧……服务端随机分一个SessionID然后HTTP字段Set-Cookie，内存存一个Map -> 浏览器存Session，以后请求都带Cookie字段（值为SessionID） -> 服务端看到Cookie字段，读SessionID对应的Map，执行逻辑。\n\n4. 前端方面，说明addEventListener使用？作用域？\n其实问的是如何给一个链接上鼠标事件，先说addEventListener。再追问说，现在IE8和Chrome不一致，IE的addEventListener绑定是window，而标准是document，如何设计一个库来兼容避免对window的污染？\n然后讲解首先库要做成一个全局匿名闭包，接受一个listener来处理作为执行函数，然后要把window.document保留为内部的变量，然后把listener的this域换位这个闭包的this，就是大概这样？由于不怎么写前端可能是错的……\n\n```js\n(function myAddEventListener(type, listener) {\n\tvar document = window.document;\n\tvar that = this;\n\t\n\tif (IE) {\n\t\tattachEvent.bind(that);\n\t\tattachEvent(type, listener);\n\t} else {\n\t\taddEventLisener(type, listener);\t\n\t}\n})();\n```\n\n5. 谈谈冒泡和捕获事件的区别，应用？\n就是Event捕获顺序，前者从底向上，后者从顶向下，说明可以stopPropagation，大家都会……\n\n然后就没了，最终谈了谈阿里对实习生要求不高，正式校招实习生只有免笔试的优惠，还得面试一轮，不过也觉得可以了。还知道内推是默认团队的，除非再人事申请，公开实习可以选择意向。HR面还没有，基本上没有意外一般不会又问题。\n\n## 总结\n\n前端工程师还是老老实实干前端吧，我这个面试经历算是特例。其实选择前端是因为阿里的后台开发只有Java岗位，而且都会考很多J2EE的东西（Servlet，SSH，设计模式，中间件，JavaBean什么的）感觉很不喜欢（毕竟是实习，想做一点感兴趣的东西），iOS开发也只要OC而且难度很高。其他公司倒有投后台和iOS的，基本上感觉以后还是很大可能搞iOS了。\n\n其实如果真想毕业找工作，大三下之前就最好决定自己方向（或者一个可选），不要技能栈拉太长，导致深度不够，这是很重要的。面试经历，基本上不准备不太可能（我这是特例……），多刷点简单OJ题（实习面试coding一般很简单），对一些框架，技术原理性要掌握（不一定实践过），项目要写的话一定确保自己还有印象，比较熟悉，不然被问到就很麻烦，基本上这样了。\n\n希望大家都能面试顺利，拿offer拿到手软～","categories":["Life"],"tags":["面试"]},{"title":"关于","url":"/about/index.html","content":"\n> 迁移Again (2016/11/1)\n\n我也是了解了国内这些云主机(PaaS)，云服务(SaaS)的作风了。之前使用的[DaoCloud](https://www.daocloud.io)，现在已经强制把所有免费的仅仅256MB的一个空间，变成了测试环境，每两天自动关闭应用，如果两周内再不管直接删数据库，也是见识了。\n\n不多说，这次直接换静态博客Hexo，托管到GitHub Pages上，主题就用[Next](https://github.com/iissnan/hexo-theme-next)主题，真心不想再折腾了（代码高亮、评论、LaTeX支持什么都费时间），以后纯粹慢慢写博文吧，毕竟还是要注重技术博客的技术，而不是这些表面上的东西。\n\n\n> 第二次迁移\n\n由于Coding现在也改为了收费机制（每天1块，想想以前的永久免费承诺，呵呵……），所以不得不再次选择迁移。本来也打算用阿里云主机直接跑，但是想想备案之路的异常艰辛，于是只能找到了国内另一家PaaS提供商：[DaoCloud](https://www.daocloud.io)\n\nDaoCloud允许免费的Docker镜像的部署，幸好我当时采用了七牛云来放图片资源，所以迁移异常轻松，简单写个Dockerfile，改下配置文件即可。\n\n```docker\nFROM node:0.12.14\n\n# Create work directory\nRUN mkdir -p /usr/local/app/\nWORKDIR /usr/local/app/\n\n# Install dependence\nCOPY . /usr/local/app/\nRUN npm install --unsafe-perm --registry=https://registry.npm.taobao.org\n\n# Expose port\nEXPOSE 80\n\n# Start\nCMD [\"npm\", \"start\"]\n```\n\n同时也支持对未备案域名的绑定（自动解析到海外），免去备案因素，比起Coding，由于支持Docker的部署，相当于所有类型应用都可以Docker化以后来部署，特别方便（代价是每次改动主题什么代码，部署可能得花10分钟……不过保证稳定而且不会出错）\n\n唉……现在想想如果之后这些PaaS提供商再抛弃用户，还是老老实实去备案了，真实服了国内的这种\"良好的互联网监管机制\"。\n\n> 第一次迁移\n\n我原先的博客是架设在[新浪云](http://www.sinacloud.com)（原先的SAE）上的，使用的是WordPress，用的PHP5.3。自己在别人基础上改进了主题和插件，也写了很多文章。然而，由于新浪云自从2016/3/21开始，对所有用户的数据库征收0.48元/天的租金（无论是否使用），并对应用实例征收0.1元/天/用户的租金，相当于一天0.58元，而一年下来总计211.7元。已经远远超出了一个空间提供商的费用，逼近主机提供商，于是看到Coding承诺对老用户的演示项目永不收费，便打算到Coding上来部署新的博客\n\n![http://www.sinacloud.com/index/price.html](https://lf3-client-infra.bytetos.com/obj/client-infra-images/lizhuoli/f7dac35688c54f2e9ac1a605b4295a39/2022-07-14/image/d/6d/77bd41d3257dc83b3345b8af594af.png)\n\n而同时我也早已对WordPress不满，落后的管理方式（主题->博客->内容）和不完全的GitHub Markdown和LaTeX支持（也还是要靠插件），过于繁冗，加之新浪云的PHP空间是禁止在线上传代码和写入服务器本地磁盘的，导致很多插件无法正常使用，于是最终还是决定全部迁移到现在流行的Ghost博客上面\n\n> Ghost的优点\n\n+ 完全支持GitHub Markdown语法，对熟悉GitHub的md格式的人很方便\n\n+ 方便集成[Disqus](http://www.disqus.com)，告别国内多说的各种推广广告，而且国际通用，自动同步，很不错\n\n+ 简单的LaTeX支持，使用[MathJax](http://www.mathjax.org)来简单支持LaTeX，我配置的是使用\n\n```latex\n$ \\latex $ 来行内渲染\n$$ \\latex $$ 来单独块渲染\n```\n\n+ 完善代码着色\n采取了[Prismjs](http://prismjs.com)来支持超级全面的代码着色，无论是\n\n```swift\nprint(\"Hello Swift\")\n```\n\n还是\n\n```haskell\nqsort :: (Ord a Bool) => [a] -> [a]\nqsort [] = []\nqsort (x:xs) = qsort (filter (<= x) xs) ++ [x] ++ qsort (filter (> x) xs)\n```\n\n更可能是\n\n```nasm\nsection     .text\nglobal      _start                              ;must be declared for linker (ld)\n\n_start:                                         ;tell linker entry point\n\n    mov     edx,len                             ;message length\n    mov     ecx,msg                             ;message to write\n    mov     ebx,1                               ;file descriptor (stdout)\n    mov     eax,4                               ;system call number (sys_write)\n    int     0x80                                ;call kernel\n\n    mov     eax,1                               ;system call number (sys_exit)\n    int     0x80                                ;call kernel\n\nsection     .data\n\nmsg     db  'Hello, world!',0xa                 ;our dear string\nlen     equ $ - msg                             ;length of our dear string\n```\n\n都能正确着色，还有语言名提示和其他插件支持，非常爽\n\n+ 图片存储和邮箱\n\n这也是Coding的缺陷，由于Coding演示不支持文件持久化（虽然能运行时写入了，但是一重新部署全部丢失），所以还是把图片等资源放在国内的[七牛云](http://www.qiniu.com)上，而且迁移方便，邮箱服务器就用Gmail就行。\n\n> 最后吐槽\n\nCoding竟然不支持绑定多个域名或者子域名，只能绑`www`域名了……唉，免费总是没有好处，主要是不想再用一个大陆以外的主机单独跑博客（Ghost用的Node.js还是比较吃资源的）\n\n什么？你说国内主机？我是备案一生黑。"},{"title":"全部分类","url":"/categories/index.html","content":""},{"title":"开发","url":"/develop/index.html","content":"\n> 这里提供了一些iOS开发相关知识、还有各种好玩的\n代码小片段、开发软件、各种脚本、各种实用网站等等\n\n\n# iOS开发\n+ Objective-C\n  + [Runtime](http://blog.devtang.com/2013/10/15/objective-c-object-model/)\n  + [Runloop & AutoreleasePool](http://blog.ibireme.com/2015/05/18/runloop/)\n  + [Blocks](http://tanqisen.github.io/blog/2013/04/19/gcd-block-cycle-retain/)\n  + [Associated Objects](http://nshipster.com/associated-objects/)\n  + [KVO](http://nshipster.cn/key-value-observing/)\n  + [Method Swizzling](http://nshipster.com/method-swizzling/)\n+ Swift\n  + [Reflect & MirrorType](http://swifter.tips/reflect/)\n  + [Functional](http://blog.callmewhy.com/2014/09/11/functional-swift-apis/)\n+ Develop\n  + [知识点](http://hit-alibaba.github.io/interview/index.html)\n  + [面试问题](https://github.com/ChenYilong/iOSInterviewQuestions)\n  + [性能优化](http://www.reviewcode.cn/article.html?reviewId=7)\n  + [防逆向](http://tanqisen.github.io/blog/2014/06/06/how-to-prevent-app-crack/)\n  + [自定义URL Scheme](http://objcio.com/blog/2014/05/21/the-complete-tutorial-on-ios-slash-iphone-custom-url-schemes/)\n\n\n# 代码片段\n+ [deep-copy-js](https://gist.github.com/lizhuoli1126/daff71c295dafc6e7b47)\n\n\n# 实用网站\n+ [visualgo](http://visualgo.net) 各种算法图形化解释和伪代码执行过程，学习、复习必备\n+ [shields.io](http://shields.io)\n生成各种GitHub上README.mk上常见的构建，版本，作者，Licence图标\n+ [regextester](http://www.regextester.com) 比较全面好用的正则表达式测试网站\n+ [oschina在线工具集](http://tool.oschina.net) 各种Web、移动、测试、对照表等工具集合\n+ [codelf](http://unbug.github.io/codelf/) 不知道怎么命名变量、函数、类？不知道英文名怎么写？参考这个，输入中英文，会从GitHub各开源项目中寻找相关命名，相当好用\n+ [NSHipster](http://nshipster.com) [中文](http://nshipster.cn) iOS开发，Cocoa，Swift，Objective-C技巧合集\n\n\n# OS X 必备软件\n\n### GUI\n+ [Homebrew](http://brew.sh)\n最好的OS X包管理工具，brew install解万难，不需要root权限\n+ [ShadowSocks](https://github.com/shadowsocks)\n必备代理工具……\n+ [aria2](http://brewformulas.org/Aria2) + [百度云](https://github.com/acgotaku/BaiduExporter) + [迅雷离线](https://github.com/binux/ThunderLixianExporter)\n超级好用下载工具，OS X上配合插件满速百度云、迅雷，不用担心各种管家。有[GUI封装版](https://github.com/yangshun1029/aria2gui)\n+ [Sublime](https://www.sublimetext.com) 大家都知道的轻巧快速的编辑器，当然还得有[Package Control](https://packagecontrol.io)，可以命令行启动\n+ [Atom](https://atom.io) 不说了吧，Hackable Editor，各种插件，除了速度和内存外完爆Sublime（其实这就是Sublime的优势……）\n+ [iTerm](https://www.iterm2.com) OS X必备的Shell模拟器，完爆自带的Terminal\n+ [Go2Shell](http://zipzapmac.com/go2shell) Finder上一键在当前路径下打开终端\n+ [Dash](https://kapeli.com/dash) 最好的API DocSet，作为开发者必备的一类工具，快速搜索各种API，类，函数，参数介绍等，无论何时何平台都得有一个以便随时查阅（总不能每次Google或者上Apple Developer、MSDN吧……）\n+ [SourceTree](https://www.sourcetreeapp.com) 超好用Git客户端，比起GitHub Desktop更好用，所有命令都可以图形化实现(比如很好用的rebase)\n+ [Paw](https://luckymarmot.com/zh-hans/paw) 原生HTTP API开发工具，Web开发必备，免费的话也可以选择[Postman](https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop)\n+ [WWDC Desktop](https://github.com/insidegui/WWDC) 一起搞iOS/OS X开发吧，各种发布会、教程录像合集\n+ [StarUML](http://staruml.io) 画UML的超好用工具，和(ProcessOn)[]差不多，更直观方便\n+ [MAMP](https://www.mamp.info) + [Postgres](http://postgresapp.com) 开发PHP/MySQL/PostgreSQL/MongoDB等各种Web和数据库图形化管理工具 \n+ [bitbar](https://github.com/matryer/bitbar)\n把各种小脚本放到通知栏上，配合下面很多CLI有奇效（原来曾经有个[TodayScript](https://github.com/SamRothCA/Today-Scripts)不过在10.11似乎有问题）\n+ [Tickeys](http://www.yingdev.com/projects/tickeys)\n让你享受机械键盘的快感，个人喜欢\"打字机\"的声音\n+ [AirServer](https://www.airserver.com) 把iOS设备屏幕投射到电脑上，开发iOS应用或者玩耍都是相当好用，价格还算能接受\n+ [SmoothScroll](https://www.smoothscroll.net) OS X对非Apple的鼠标很不友好，忍受不了反向滚动以及无平滑滚动的人终于有救了……然而这软件价格惊人(138/Year)……有钱的支持吧\n+ [f.lux](https://justgetflux.com) 护眼专用，自动改变色温，防止青光眼\n+ [Charles](http://www.charlesproxy.com) 高级代理调试抓包工具，HTTP(S)，Map local等等，可以配合下载一些缓慢资源，还有iOS 模拟器的代理抓包等，[参考Charles从入门到精通...](http://blog.devtang.com/2015/11/14/charles-introduction/)\n+ [Genymotion](https://www.genymotion.com) 超快的Android模拟器，调试工具，比起Android Studio自带的好很多……如果是Android开发者的话很推荐，当然，也能用来在电脑玩Android游戏（其实还有一个Chrome跑Android的[Chrome-ARChon](https://github.com/vladikoff/chromeos-apk)也行）\n+ [CrossOver](https://www.codeweavers.com/products) 图形化封装版Wine……对于OS X这种非主流平台，跑Windows软件（尤其是游戏）是一个无奈的现实（其实一般的话放个WinRar，FlashFXP，VC6.0，Microsoft Access什么的就差不多了……）虽然其实用这个主要是跑很多游戏的（Steam、GOG大法好）\n+ [awesome-osx](https://github.com/iCHAIT/awesome-osx) 里面有各种类型的软件，工具集合（主要面向开发者），时不时可以看看\n\n\n### CLI\n+ [oh-my-zsh](https://github.com/robbyrussell/oh-my-zsh)\n不得不用的Shell，完爆Bash，必备……\n+ [vim-spf13](http://vim.spf13.com)\n超爽的Vim一件配置工具……适用于各类开发者(C系,Shell系,Go,Python,Ruby,JS等)\n+ [axel](http://brewformulas.org/Axel)\n超快速下载工具， `axel -n100 \"{url}\"` 满速下Amazon S3（GitHub上全部资源都是S3的），MEGA等国外资源，还慢的话可以 `axel -S {url}` 搜镜像站点\n+ [hub](https://hub.github.com) 顾名思义，git + hub = github，git扩展\n+ [tree](http://brewformulas.org/Tree)\n必备的代替 `ls cd xxx ls` 的东西\n+ [trash](http://brewformulas.org/Trash)\n再不怕 `rm -rf` 手残了……\n+ [tldr](https://github.com/tldr-pages/tldr) Too long, don't read，还怕man手册的长文介绍？试试这个傻瓜命令行帮助手册\n+ [istats](https://github.com/Chris911/iStats)\n一键查看各硬件温度，风扇转速，电池容量等，免费，不需要安装不需要root权限，比iStat Menus好用多了\n\n\n# 小脚本\n\n+ [awesome-osx-command-line](https://github.com/herrbischoff/awesome-osx-command-line)\n真是各种OS X的命令行和脚本工具集合，你想要的都能找得到……\n+ [mama-bookmark](http://zythum.sinaapp.com/youkuhtml5playerbookmark/) 支持国内各大视频网站直接HTML5观看，拒绝Flash\n\n# 其它\n\n+ [multcloud](https://multcloud.com/home) 网盘迁移助手\n"},{"title":"全部标签","url":"/tags/index.html","content":""}]
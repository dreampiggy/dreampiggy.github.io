---
title: 个人笔记-《并发编程》
categories: Code
tags:
  - 笔记
  - 并发
updated: '2016-03-30 02:06:37'
date: 2016-03-30 02:06:06
---

1.  线程和锁
    
    *   线程锁的的问题:
    
    > 时序问题
    > 
    > 原子操作问题(Java内存读写机制->读.改.写)
    > 
    > 竞态条件(操作取决于线程执行的先后顺序)
    > 
    > JVM优化导致的问题（编译器静态优化，JVM动态优化，硬件指令的乱序执行）
    > 
    > 两把锁：死锁问题
    > 
    > 外部方法或者对象的线程安全问题
    > 
    > 效率问题synchronized()
    > 
    > ThreadLocal额外讲解，线程级别的局部变量，适用于数据库连接，网络请求
    
    *   使用concurrency
    
    > ReetrantLock的手动加锁解锁
    > 
    > 死锁也能中断(不推荐的方式lockInterruptibly())
    > 
    > tryLock()虽然能设定超时自动解锁，但是缺点明显：活锁（同时死锁再同时超时）
    > 
    > 条件锁：Condition类
    > 
    > 原子操作：Atomic 简单的解决方法，坑和缺点
    > 
    > 线程池 内置的Exeutors.newFixedThreadPool()

2.  函数式方法
    
    *   变量与可变状态导致的并发难题的终极解决方法->去掉变量
    
    > 函数式基础概念：顺序无关 map reduce 无穷序列和惰性求值 尾递归
    > 
    > Clojure简单方法：pmap
    > 
    > 两种Clojure并发模型：Future(给定一个函数在新线程跑，返回一个future对象) Promise（立即返回，惰性，调用deliver才会执行）
    > 
    > 原子变量(atom)，代理(deref @)，由引用(ref)构成的软件事务内存(STM)。对任何多个并发事务进行修改发生冲突，将会导致重试

3.  actor的魔力（略）
    
    *   纯粹的消息式的交流，几乎没有限制的进程数，随时加入和进行任务，任由错误发生，集中处理
    
    > actor：真正的消息传递，轻量级的进程开销
    > 
    > 分布式map，每个进程分配子map